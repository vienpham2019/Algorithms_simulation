{"ast":null,"code":"import { Node, Block } from './helper_method';\nimport { breadth_first_search, stop_breadth_first_search } from './solve_maze/breadth_first_search';\nimport { depth_first_search, stop_depth_first_search } from './solve_maze/depth_first_search';\nimport { a_star, stop_a_star } from './solve_maze/a_star';\nimport { greedy_best_first_search, stop_greedy_best_first_search } from './solve_maze/greedy_best_first_search';\nimport { dijkstra, stop_dijkstra } from './solve_maze/dijkstra';\nimport { bidirectional_dijkstra, stop_bidirectional_dijkstra } from './solve_maze/bidirectional_dijkstra';\nimport { bidirectional_a_star, stop_bidirectional_a_star } from './solve_maze/bidirectional_a_star';\nimport { recursive_dividion_maze } from './draw_maze/recursive_division_maze_generation';\nimport { prims_maze } from './draw_maze/prims_maze_generation';\nimport { depth_first_search_maze } from './draw_maze/depth_first_search_maze_generation';\nlet size, width, height, cols, rows;\nlet delay, speed, canvas, c, start_node, end_node, nodes, stack, frame_per_second, maze_speed, myTimeOut, draw_maze;\n\nconst setUp = props => {\n  stop_breadth_first_search();\n  stop_depth_first_search();\n  stop_a_star();\n  stop_dijkstra();\n  stop_bidirectional_dijkstra();\n  stop_greedy_best_first_search();\n  stop_bidirectional_a_star();\n  c = props.c;\n  canvas = props.canvas;\n  stack = [];\n  cols = props.cols;\n  rows = props.rows;\n  size = props.size;\n  draw_maze = props.draw_maze;\n  width = props.width;\n  height = props.height;\n  size = Math.floor(width / cols);\n  delay = 0;\n  speed = 40;\n  maze_speed = 700;\n  frame_per_second = 1000;\n  canvas.width = width;\n  canvas.height = height;\n  clearTimeout(myTimeOut);\n\n  if (draw_maze) {\n    nodes = [];\n    setTimeout(() => {\n      draw_divide_maze();\n    }, 300);\n  }\n};\n\nconst draw_divide_maze = () => {\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      let x = j * size + size / 2;\n      let y = i * size + size / 2;\n      let node = new Node(x, y, c, size);\n\n      if (i === 0 && j !== 0) {\n        node.walls[0] = true;\n      } else if (i === rows - 1) {\n        node.walls[2] = true;\n      }\n\n      if (j === 0) {\n        node.walls[3] = true;\n      } else if (j === cols - 1 && i !== rows - 1) {\n        node.walls[1] = true;\n      }\n\n      if (i === 0 && j === 0) {\n        stack.push(node);\n      }\n\n      nodes.push(node);\n    }\n  }\n\n  start_node = new Block(size / 2, size / 2, c, size, \"blue\");\n  end_node = new Block((cols - 1) * size + size / 2, (rows - 1) * size + size / 2, c, size, \"green\"); // depth_first_search_maze({nodes , canvas , c , stack , size , cols , rows , frame_per_second , speed })\n  // prims_maze({size , nodes , cols , rows , canvas , c , frame_per_second , speed})\n\n  let draw_delay = recursive_dividion_maze({\n    delay,\n    speed,\n    size,\n    cols,\n    rows,\n    nodes\n  }); // if(draw_delay){\n  //   myTimeOut = setTimeout(() => {\n  //     // depth_first_search({nodes , start_node , end_node , c , canvas , size})\n  //     a_star({start_node , end_node , nodes , c , canvas , size})\n  //   }, draw_delay * speed);\n  // }\n};\n\nconst run_solve_maze = () => {\n  stop_greedy_best_first_search();\n  stop_a_star();\n  stop_dijkstra();\n  stop_breadth_first_search();\n  stop_depth_first_search();\n  stop_bidirectional_dijkstra();\n  stop_bidirectional_a_star(); // depth_first_search({nodes , start_node , end_node , c , canvas , size})\n  // a_star({start_node , end_node , nodes , c , canvas , size})\n  // dijkstra({start_node , end_node , nodes , c , canvas , size})\n  // bidirectional_dijkstra({start_node , end_node , nodes , c , canvas , size})\n\n  bidirectional_a_star({\n    start_node,\n    end_node,\n    nodes,\n    c,\n    canvas,\n    size\n  }); // greedy_best_first_search({start_node , end_node , nodes , c , canvas , size})\n  // breadth_first_search({c , canvas , size , nodes , start_node , end_node })\n};\n\nexport { setUp, run_solve_maze };","map":{"version":3,"sources":["/Users/vienpham/Desktop/Algorithms_simulation/algorithms/src/Algorithms/mazeController.js"],"names":["Node","Block","breadth_first_search","stop_breadth_first_search","depth_first_search","stop_depth_first_search","a_star","stop_a_star","greedy_best_first_search","stop_greedy_best_first_search","dijkstra","stop_dijkstra","bidirectional_dijkstra","stop_bidirectional_dijkstra","bidirectional_a_star","stop_bidirectional_a_star","recursive_dividion_maze","prims_maze","depth_first_search_maze","size","width","height","cols","rows","delay","speed","canvas","c","start_node","end_node","nodes","stack","frame_per_second","maze_speed","myTimeOut","draw_maze","setUp","props","Math","floor","clearTimeout","setTimeout","draw_divide_maze","i","j","x","y","node","walls","push","draw_delay","run_solve_maze"],"mappings":"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","sourcesContent":["import { Node , Block } from './helper_method'\nimport { breadth_first_search , stop_breadth_first_search }from './solve_maze/breadth_first_search'\nimport { depth_first_search , stop_depth_first_search }from './solve_maze/depth_first_search'\nimport { a_star , stop_a_star }from './solve_maze/a_star'\nimport { greedy_best_first_search , stop_greedy_best_first_search }from './solve_maze/greedy_best_first_search'\nimport { dijkstra , stop_dijkstra }from './solve_maze/dijkstra'\nimport { bidirectional_dijkstra , stop_bidirectional_dijkstra }from './solve_maze/bidirectional_dijkstra'\nimport { bidirectional_a_star , stop_bidirectional_a_star }from './solve_maze/bidirectional_a_star'\n\nimport { recursive_dividion_maze } from './draw_maze/recursive_division_maze_generation'\nimport { prims_maze } from './draw_maze/prims_maze_generation'\nimport { depth_first_search_maze } from './draw_maze/depth_first_search_maze_generation'\n\nlet size , width , height , cols , rows \n\nlet delay , speed , canvas , c , start_node, end_node , nodes , stack , frame_per_second , maze_speed , myTimeOut , draw_maze\n\nconst setUp = (props) => {\n  stop_breadth_first_search()\n  stop_depth_first_search()\n  stop_a_star()\n  stop_dijkstra()\n  stop_bidirectional_dijkstra()\n  stop_greedy_best_first_search()\n  stop_bidirectional_a_star()\n\n  c = props.c\n  canvas = props.canvas \n  stack = []\n\n  cols = props.cols \n  rows = props.rows \n  size = props.size \n  draw_maze = props.draw_maze\n  width = props.width\n  height = props.height\n\n  size = Math.floor(width / cols)\n\n  delay = 0 \n  speed = 40\n  maze_speed = 700\n\n  frame_per_second = 1000\n\n  canvas.width = width\n  canvas.height = height\n\n  clearTimeout(myTimeOut)\n  if(draw_maze){\n    nodes = []\n    setTimeout(() => {\n      draw_divide_maze()\n    }, 300);\n  }\n\n}\n\nconst draw_divide_maze = () => {\n  for(let i = 0; i < rows ; i ++){\n    for(let j = 0; j < cols ; j ++){\n        let x = j * size + (size / 2)\n        let y = i * size + (size / 2)\n        let node = new Node(x, y , c , size )\n        if(i === 0 && j !== 0) {\n            node.walls[0] = true\n        }else if(i === rows - 1){\n            node.walls[2] = true\n        }\n\n        if(j === 0){\n            node.walls[3] = true \n        }else if(j === cols - 1 && i !== rows - 1){\n            node.walls[1] = true\n        }\n\n        if(i === 0 && j === 0){\n            stack.push(node)\n        }\n        nodes.push(node)\n    }\n  }\n\n  start_node = new Block((size / 2) ,(size / 2) , c , size , \"blue\")\n  end_node = new Block((cols - 1) * size + (size / 2),( rows - 1 ) * size + (size / 2) , c , size , \"green\" )\n\n  // depth_first_search_maze({nodes , canvas , c , stack , size , cols , rows , frame_per_second , speed })\n  // prims_maze({size , nodes , cols , rows , canvas , c , frame_per_second , speed})\n  let draw_delay = recursive_dividion_maze({delay , speed , size , cols , rows , nodes})\n  // if(draw_delay){\n  //   myTimeOut = setTimeout(() => {\n  //     // depth_first_search({nodes , start_node , end_node , c , canvas , size})\n  //     a_star({start_node , end_node , nodes , c , canvas , size})\n  //   }, draw_delay * speed);\n  // }\n}\n\nconst run_solve_maze = () => {\n  stop_greedy_best_first_search()\n  stop_a_star()\n  stop_dijkstra()\n  stop_breadth_first_search()\n  stop_depth_first_search()\n  stop_bidirectional_dijkstra()\n  stop_bidirectional_a_star()\n\n  // depth_first_search({nodes , start_node , end_node , c , canvas , size})\n  // a_star({start_node , end_node , nodes , c , canvas , size})\n  // dijkstra({start_node , end_node , nodes , c , canvas , size})\n  // bidirectional_dijkstra({start_node , end_node , nodes , c , canvas , size})\n  bidirectional_a_star({start_node , end_node , nodes , c , canvas , size})\n  // greedy_best_first_search({start_node , end_node , nodes , c , canvas , size})\n  // breadth_first_search({c , canvas , size , nodes , start_node , end_node })\n}\n\nexport {setUp , run_solve_maze}\n"]},"metadata":{},"sourceType":"module"}