{"ast":null,"code":"import { Node, Block } from './helper_method';\nlet size, width, height, cols, rows;\nlet canvas, c;\nlet nodes, block;\nlet visited_nodes, stack;\nlet quere, finish_path, nodes_path, path, current_node;\nlet start_node, end_node;\nlet myReq, myReqDraw;\n\nconst setUp = props => {\n  c = props.c;\n  canvas = props.canvas;\n  canvas.width = width;\n  canvas.height = height;\n  nodes = [];\n  visited_nodes = [];\n  stack = [];\n  quere = [];\n  nodes_path = [];\n  path = [];\n  finish_path = false;\n  cols = props.cols;\n  rows = props.rows;\n  size = props.size;\n  width = size * cols;\n  height = size * rows;\n  cancelAnimationFrame(myReq);\n  draw_frims_maze();\n};\n\nconst draw_frims_maze = () => {\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      let x = j * size + size / 2;\n      let y = i * size + size / 2;\n      let node = new Node(x, y, c, size);\n\n      if (i === 0 && j === 0) {\n        node.walls[3] = false;\n      }\n\n      if (j === cols - 1 && i === rows - 1) {\n        node.walls[1] = false;\n      }\n\n      if (i === 0 && j === 0) {\n        stack.push(node);\n        visited_nodes.push(node);\n      }\n\n      nodes.push(node);\n    }\n  }\n\n  start_node = new Block(size / 2, size / 2, c, size, \"blue\");\n  quere.push(start_node);\n  end_node = new Block((cols - 1) * size + size / 2, (rows - 1) * size + size / 2, c, size, \"green\");\n  setup_prims_maze(nodes, cols, rows);\n};\n\nlet neighbors_node = [];\nlet visited_neighbors_node = [];\nlet current_neighbor_node;\n\nconst setup_prims_maze = (nodes_array, w, h) => {\n  let midd_x = Math.floor(w / 2) * size + size / 2;\n  let midd_y = Math.floor(h / 2) * size + size / 2;\n  let center_node = nodes_array.find(node => node.x === midd_x && node.y === midd_y);\n  neighbors_node.push(center_node);\n  visited_neighbors_node.push(center_node);\n  current_neighbor_node = center_node;\n  draw_prims_maze();\n};\n\nconst draw_prims_maze = () => {\n  myReqDraw = requestAnimationFrame(draw_prims_maze);\n  c.clearRect(0, 0, canvas.width, canvas.height);\n\n  for (let i = 0; i < nodes.length; i++) {\n    nodes[i].draw();\n  }\n\n  if (neighbors_node.length === 0) {\n    cancelAnimationFrame(myReqDraw);\n  }\n\n  add_neighbor_node();\n};\n\nconst add_neighbor_node = () => {\n  let {\n    x,\n    y\n  } = current_neighbor_node;\n  let {\n    top,\n    right,\n    bottom,\n    left\n  } = get_top_right_bottom_left(current_neighbor_node, nodes);\n\n  if (top && !visited_neighbors_node.find(node => node.x === x && node.y === y - size) && !neighbors_node.find(node => node.x === x && node.y === y - size)) {\n    neighbors_node.push(top);\n    top.prev_node = current_neighbor_node;\n  }\n\n  if (right && !visited_neighbors_node.find(node => node.x === x + size && node.y === y) && !neighbors_node.find(node => node.x === x + size && node.y === y)) {\n    neighbors_node.push(right);\n    right.prev_node = current_neighbor_node;\n  }\n\n  if (bottom && !visited_neighbors_node.find(node => node.x === x && node.y === y + size) && !neighbors_node.find(node => node.x === x && node.y === y + size)) {\n    neighbors_node.push(bottom);\n    bottom.prev_node = current_neighbor_node;\n  }\n\n  if (left && !visited_neighbors_node.find(node => node.x === x - size && node.y === y) && !neighbors_node.find(node => node.x === x - size && node.y === y)) {\n    neighbors_node.push(left);\n    left.prev_node = current_neighbor_node;\n  }\n\n  neighbors_node = neighbors_node.filter(node => node.x === x && node.y === y ? false : true);\n  link_node_with_random_neighbor();\n};\n\nconst link_node_with_random_neighbor = () => {\n  if (neighbors_node.length === 0) return;\n  let random_num = getRandom(0, neighbors_node.length);\n  let random_neighbor = neighbors_node[random_num];\n  let {\n    top,\n    right,\n    bottom,\n    left\n  } = get_top_right_bottom_left(random_neighbor, visited_neighbors_node);\n\n  if (top && top.x === random_neighbor.prev_node.x && top.y === random_neighbor.prev_node.y) {\n    random_neighbor.walls[0] = false;\n    top.walls[2] = false;\n  }\n\n  if (right && right.x === random_neighbor.prev_node.x && right.y === random_neighbor.prev_node.y) {\n    random_neighbor.walls[1] = false;\n    right.walls[3] = false;\n  }\n\n  if (bottom && bottom.x === random_neighbor.prev_node.x && bottom.y === random_neighbor.prev_node.y) {\n    random_neighbor.walls[2] = false;\n    bottom.walls[0] = false;\n  }\n\n  if (left && left.x === random_neighbor.prev_node.x && left.y === random_neighbor.prev_node.y) {\n    random_neighbor.walls[3] = false;\n    left.walls[1] = false;\n  }\n\n  current_neighbor_node = random_neighbor;\n  visited_neighbors_node.push(random_neighbor);\n};\n\nconst get_top_right_bottom_left = (node, array) => {\n  let {\n    x,\n    y\n  } = node;\n  let top = array.find(n => n.x === x && n.y === y - size);\n  let right = array.find(n => n.x === x + size && n.y === y);\n  let bottom = array.find(n => n.x === x && n.y === y + size);\n  let left = array.find(n => n.x === x - size && n.y === y);\n  return {\n    top,\n    right,\n    bottom,\n    left\n  };\n};\n\nconst getRandom = (min, max) => {\n  return Math.floor(Math.random() * (max - min) + min);\n};\n\nconst run_solve_maze = () => {\n  myReq = requestAnimationFrame(run_solve_maze);\n  c.clearRect(0, 0, canvas.width, canvas.height);\n\n  for (let i = 0; i < nodes.length; i++) {\n    nodes[i].draw();\n  }\n\n  for (let i = 0; i < nodes_path.length; i++) {\n    nodes_path[i].draw();\n  }\n\n  start_node.draw();\n  end_node.draw();\n\n  if (end_node.prev_node) {\n    find_path();\n  }\n\n  if (finish_path) {\n    cancelAnimationFrame(myReq);\n  }\n\n  if (!end_node.prev_node && !finish_path) {\n    solve_maze();\n  }\n};\n\nconst solve_maze = () => {\n  let quere_nodes = [...quere];\n  quere.shift(); // visited_nodes_for_path.push(current_node)\n\n  if (end_node.prev_node) {\n    return;\n  }\n\n  for (let i = 0; i < quere_nodes.length; i++) {\n    check_neighbor_node(quere_nodes[i]);\n  }\n};\n\nconst check_neighbor_node = node => {\n  let x = node.x;\n  let y = node.y;\n  let color = \"MidnightBlue\";\n  let current_find_node = nodes.find(c_n => c_n.x === node.x && c_n.y === node.y); // top \n\n  let top = nodes.find(n => n.x === x && n.y === y - size);\n\n  if (top && !current_find_node.walls[0] && !nodes_path.find(n => n.x === top.x && n.y === top.y)) {\n    let top_x = top.x;\n    let top_y = top.y;\n\n    if (top_x === end_node.x && top_y === end_node.y) {\n      end_node.prev_node = node;\n      current_node = node;\n      return;\n    } else {\n      let top_block = new Block(top_x, top_y, color, node);\n      quere.push(top_block);\n      nodes_path.push(top_block);\n    }\n  } // right\n\n\n  let right = nodes.find(n => n.x === x + size && n.y === y);\n\n  if (right && !current_find_node.walls[1] && !nodes_path.find(n => n.x === right.x && n.y === right.y)) {\n    let right_x = right.x;\n    let right_y = right.y;\n\n    if (right_x === end_node.x && right_y === end_node.y) {\n      end_node.prev_node = node;\n      current_node = node;\n      return;\n    } else {\n      let right_block = new Block(right_x, right_y, color, node);\n      quere.push(right_block);\n      nodes_path.push(right_block);\n    }\n  } // bottom\n\n\n  let bottom = nodes.find(n => n.x === x && n.y === y + size);\n\n  if (bottom && !current_find_node.walls[2] && !nodes_path.find(n => n.x === bottom.x && n.y === bottom.y)) {\n    let bottom_x = bottom.x;\n    let bottom_y = bottom.y;\n\n    if (bottom_x === end_node.x && bottom_y === end_node.y) {\n      end_node.prev_node = node;\n      current_node = node;\n      return;\n    } else {\n      let bottom_block = new Block(bottom_x, bottom_y, color, node);\n      quere.push(bottom_block);\n      nodes_path.push(bottom_block);\n    }\n  } // left \n\n\n  let left = nodes.find(n => n.x === x - size && n.y === y);\n\n  if (left && !current_find_node.walls[3] && !nodes_path.find(n => n.x === left.x && n.y === left.y)) {\n    let left_x = left.x;\n    let left_y = left.y;\n\n    if (left_x === end_node.x && left_y === end_node.y) {\n      end_node.prev_node = node;\n      current_node = node;\n      return;\n    } else {\n      let left_block = new Block(left_x, left_y, color, node);\n      quere.push(left_block);\n      nodes_path.push(left_block);\n    }\n  }\n};\n\nconst find_path = () => {\n  current_node.color = \"green\";\n\n  if (current_node.x === start_node.x && current_node.y === start_node.y) {\n    finish_path = true;\n    return;\n  }\n\n  current_node = current_node.prev_node;\n};\n\nexport { setUp, run_solve_maze };","map":{"version":3,"sources":["/Users/vienpham/Desktop/Algorithms_simulation/algorithms/src/Algorithms/depth_first_search_maze.js"],"names":["Node","Block","size","width","height","cols","rows","canvas","c","nodes","block","visited_nodes","stack","quere","finish_path","nodes_path","path","current_node","start_node","end_node","myReq","myReqDraw","setUp","props","cancelAnimationFrame","draw_frims_maze","i","j","x","y","node","walls","push","setup_prims_maze","neighbors_node","visited_neighbors_node","current_neighbor_node","nodes_array","w","h","midd_x","Math","floor","midd_y","center_node","find","draw_prims_maze","requestAnimationFrame","clearRect","length","draw","add_neighbor_node","top","right","bottom","left","get_top_right_bottom_left","prev_node","filter","link_node_with_random_neighbor","random_num","getRandom","random_neighbor","array","n","min","max","random","run_solve_maze","find_path","solve_maze","quere_nodes","shift","check_neighbor_node","color","current_find_node","c_n","top_x","top_y","top_block","right_x","right_y","right_block","bottom_x","bottom_y","bottom_block","left_x","left_y","left_block"],"mappings":"AAAA,SAAQA,IAAR,EAAeC,KAAf,QAA2B,iBAA3B;AAEA,IAAIC,IAAJ,EAAWC,KAAX,EAAmBC,MAAnB,EAA4BC,IAA5B,EAAmCC,IAAnC;AAEA,IAAIC,MAAJ,EAAaC,CAAb;AAEA,IAAIC,KAAJ,EAAYC,KAAZ;AAEA,IAAIC,aAAJ,EAAoBC,KAApB;AAEA,IAAIC,KAAJ,EAAYC,WAAZ,EAA0BC,UAA1B,EAAuCC,IAAvC,EAA8CC,YAA9C;AAEA,IAAIC,UAAJ,EAAgBC,QAAhB;AAEA,IAAIC,KAAJ,EAAYC,SAAZ;;AAEA,MAAMC,KAAK,GAAIC,KAAD,IAAW;AACvBf,EAAAA,CAAC,GAAGe,KAAK,CAACf,CAAV;AACAD,EAAAA,MAAM,GAAGgB,KAAK,CAAChB,MAAf;AACAA,EAAAA,MAAM,CAACJ,KAAP,GAAeA,KAAf;AACAI,EAAAA,MAAM,CAACH,MAAP,GAAgBA,MAAhB;AACAK,EAAAA,KAAK,GAAG,EAAR;AACAE,EAAAA,aAAa,GAAG,EAAhB;AACAC,EAAAA,KAAK,GAAG,EAAR;AACAC,EAAAA,KAAK,GAAG,EAAR;AACAE,EAAAA,UAAU,GAAG,EAAb;AACAC,EAAAA,IAAI,GAAG,EAAP;AACAF,EAAAA,WAAW,GAAG,KAAd;AAEAT,EAAAA,IAAI,GAAGkB,KAAK,CAAClB,IAAb;AACAC,EAAAA,IAAI,GAAGiB,KAAK,CAACjB,IAAb;AACAJ,EAAAA,IAAI,GAAGqB,KAAK,CAACrB,IAAb;AACAC,EAAAA,KAAK,GAAGD,IAAI,GAAGG,IAAf;AACAD,EAAAA,MAAM,GAAGF,IAAI,GAAGI,IAAhB;AAEAkB,EAAAA,oBAAoB,CAACJ,KAAD,CAApB;AACAK,EAAAA,eAAe;AAChB,CArBD;;AAuBA,MAAMA,eAAe,GAAG,MAAM;AAC5B,OAAI,IAAIC,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGpB,IAAnB,EAA0BoB,CAAC,EAA3B,EAA+B;AAC3B,SAAI,IAAIC,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGtB,IAAnB,EAA0BsB,CAAC,EAA3B,EAA+B;AAC3B,UAAIC,CAAC,GAAGD,CAAC,GAAGzB,IAAJ,GAAYA,IAAI,GAAG,CAA3B;AACA,UAAI2B,CAAC,GAAGH,CAAC,GAAGxB,IAAJ,GAAYA,IAAI,GAAG,CAA3B;AACA,UAAI4B,IAAI,GAAG,IAAI9B,IAAJ,CAAS4B,CAAT,EAAYC,CAAZ,EAAerB,CAAf,EAAmBN,IAAnB,CAAX;;AAEA,UAAGwB,CAAC,KAAK,CAAN,IAAWC,CAAC,KAAK,CAApB,EAAuB;AACnBG,QAAAA,IAAI,CAACC,KAAL,CAAW,CAAX,IAAgB,KAAhB;AACH;;AAED,UAAGJ,CAAC,KAAKtB,IAAI,GAAG,CAAb,IAAkBqB,CAAC,KAAKpB,IAAI,GAAG,CAAlC,EAAoC;AAChCwB,QAAAA,IAAI,CAACC,KAAL,CAAW,CAAX,IAAgB,KAAhB;AACH;;AAED,UAAGL,CAAC,KAAK,CAAN,IAAWC,CAAC,KAAK,CAApB,EAAsB;AAClBf,QAAAA,KAAK,CAACoB,IAAN,CAAWF,IAAX;AACAnB,QAAAA,aAAa,CAACqB,IAAd,CAAmBF,IAAnB;AACH;;AAEDrB,MAAAA,KAAK,CAACuB,IAAN,CAAWF,IAAX;AACH;AACJ;;AAEDZ,EAAAA,UAAU,GAAG,IAAIjB,KAAJ,CAAUC,IAAI,GAAG,CAAjB,EAAmBA,IAAI,GAAG,CAA1B,EAA6BM,CAA7B,EAAiCN,IAAjC,EAAuC,MAAvC,CAAb;AACAW,EAAAA,KAAK,CAACmB,IAAN,CAAWd,UAAX;AACAC,EAAAA,QAAQ,GAAG,IAAIlB,KAAJ,CAAU,CAACI,IAAI,GAAG,CAAR,IAAaH,IAAb,GAAqBA,IAAI,GAAG,CAAtC,EAAyC,CAAEI,IAAI,GAAG,CAAT,IAAeJ,IAAf,GAAuBA,IAAI,GAAG,CAAvE,EAA4EM,CAA5E,EAAgFN,IAAhF,EAAsF,OAAtF,CAAX;AAEA+B,EAAAA,gBAAgB,CAACxB,KAAD,EAAQJ,IAAR,EAAeC,IAAf,CAAhB;AACD,CA7BD;;AA+BA,IAAI4B,cAAc,GAAG,EAArB;AACA,IAAIC,sBAAsB,GAAG,EAA7B;AACA,IAAIC,qBAAJ;;AAEA,MAAMH,gBAAgB,GAAG,CAACI,WAAD,EAAeC,CAAf,EAAmBC,CAAnB,KAAyB;AAChD,MAAIC,MAAM,GAAIC,IAAI,CAACC,KAAL,CAAWJ,CAAC,GAAG,CAAf,IAAoBpC,IAApB,GAA4BA,IAAI,GAAG,CAAjD;AACA,MAAIyC,MAAM,GAAIF,IAAI,CAACC,KAAL,CAAWH,CAAC,GAAG,CAAf,IAAoBrC,IAApB,GAA4BA,IAAI,GAAG,CAAjD;AACA,MAAI0C,WAAW,GAAGP,WAAW,CAACQ,IAAZ,CAAiBf,IAAI,IAAIA,IAAI,CAACF,CAAL,KAAWY,MAAX,IAAqBV,IAAI,CAACD,CAAL,KAAWc,MAAzD,CAAlB;AACAT,EAAAA,cAAc,CAACF,IAAf,CAAoBY,WAApB;AACAT,EAAAA,sBAAsB,CAACH,IAAvB,CAA4BY,WAA5B;AACAR,EAAAA,qBAAqB,GAAGQ,WAAxB;AAEAE,EAAAA,eAAe;AAChB,CATD;;AAWA,MAAMA,eAAe,GAAG,MAAM;AAC5BzB,EAAAA,SAAS,GAAG0B,qBAAqB,CAACD,eAAD,CAAjC;AACAtC,EAAAA,CAAC,CAACwC,SAAF,CAAY,CAAZ,EAAc,CAAd,EAAgBzC,MAAM,CAACJ,KAAvB,EAA8BI,MAAM,CAACH,MAArC;;AAEA,OAAI,IAAIsB,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGjB,KAAK,CAACwC,MAAzB,EAAiCvB,CAAC,EAAlC,EAAsC;AAClCjB,IAAAA,KAAK,CAACiB,CAAD,CAAL,CAASwB,IAAT;AACH;;AAED,MAAGhB,cAAc,CAACe,MAAf,KAA0B,CAA7B,EAA+B;AAC3BzB,IAAAA,oBAAoB,CAACH,SAAD,CAApB;AACH;;AAED8B,EAAAA,iBAAiB;AAClB,CAbD;;AAeA,MAAMA,iBAAiB,GAAG,MAAM;AAC9B,MAAI;AAACvB,IAAAA,CAAD;AAAKC,IAAAA;AAAL,MAAUO,qBAAd;AAEA,MAAI;AAACgB,IAAAA,GAAD;AAAOC,IAAAA,KAAP;AAAeC,IAAAA,MAAf;AAAwBC,IAAAA;AAAxB,MAAgCC,yBAAyB,CAACpB,qBAAD,EAAyB3B,KAAzB,CAA7D;;AAEA,MACI2C,GAAG,IACA,CAACjB,sBAAsB,CAACU,IAAvB,CAA4Bf,IAAI,IAAIA,IAAI,CAACF,CAAL,KAAWA,CAAX,IAAgBE,IAAI,CAACD,CAAL,KAAWA,CAAC,GAAG3B,IAAnE,CADJ,IAEG,CAACgC,cAAc,CAACW,IAAf,CAAoBf,IAAI,IAAIA,IAAI,CAACF,CAAL,KAAWA,CAAX,IAAgBE,IAAI,CAACD,CAAL,KAAWA,CAAC,GAAG3B,IAA3D,CAHR,EAIC;AACGgC,IAAAA,cAAc,CAACF,IAAf,CAAoBoB,GAApB;AACAA,IAAAA,GAAG,CAACK,SAAJ,GAAgBrB,qBAAhB;AACH;;AAED,MACIiB,KAAK,IACF,CAAClB,sBAAsB,CAACU,IAAvB,CAA4Bf,IAAI,IAAIA,IAAI,CAACF,CAAL,KAAWA,CAAC,GAAG1B,IAAf,IAAuB4B,IAAI,CAACD,CAAL,KAAWA,CAAtE,CADJ,IAEG,CAACK,cAAc,CAACW,IAAf,CAAoBf,IAAI,IAAIA,IAAI,CAACF,CAAL,KAAWA,CAAC,GAAG1B,IAAf,IAAuB4B,IAAI,CAACD,CAAL,KAAWA,CAA9D,CAHR,EAIC;AACGK,IAAAA,cAAc,CAACF,IAAf,CAAoBqB,KAApB;AACAA,IAAAA,KAAK,CAACI,SAAN,GAAkBrB,qBAAlB;AACH;;AAED,MACIkB,MAAM,IACH,CAACnB,sBAAsB,CAACU,IAAvB,CAA4Bf,IAAI,IAAIA,IAAI,CAACF,CAAL,KAAWA,CAAX,IAAgBE,IAAI,CAACD,CAAL,KAAWA,CAAC,GAAG3B,IAAnE,CADJ,IAEG,CAACgC,cAAc,CAACW,IAAf,CAAoBf,IAAI,IAAIA,IAAI,CAACF,CAAL,KAAWA,CAAX,IAAgBE,IAAI,CAACD,CAAL,KAAWA,CAAC,GAAG3B,IAA3D,CAHR,EAIC;AACGgC,IAAAA,cAAc,CAACF,IAAf,CAAoBsB,MAApB;AACAA,IAAAA,MAAM,CAACG,SAAP,GAAmBrB,qBAAnB;AACH;;AAED,MACImB,IAAI,IACD,CAACpB,sBAAsB,CAACU,IAAvB,CAA4Bf,IAAI,IAAIA,IAAI,CAACF,CAAL,KAAWA,CAAC,GAAG1B,IAAf,IAAuB4B,IAAI,CAACD,CAAL,KAAWA,CAAtE,CADJ,IAEG,CAACK,cAAc,CAACW,IAAf,CAAoBf,IAAI,IAAIA,IAAI,CAACF,CAAL,KAAWA,CAAC,GAAG1B,IAAf,IAAuB4B,IAAI,CAACD,CAAL,KAAWA,CAA9D,CAHR,EAIC;AACGK,IAAAA,cAAc,CAACF,IAAf,CAAoBuB,IAApB;AACAA,IAAAA,IAAI,CAACE,SAAL,GAAiBrB,qBAAjB;AACH;;AAEDF,EAAAA,cAAc,GAAGA,cAAc,CAACwB,MAAf,CAAsB5B,IAAI,IAAIA,IAAI,CAACF,CAAL,KAAWA,CAAX,IAAgBE,IAAI,CAACD,CAAL,KAAWA,CAA3B,GAA+B,KAA/B,GAAuC,IAArE,CAAjB;AAEA8B,EAAAA,8BAA8B;AAC/B,CA5CD;;AA8CA,MAAMA,8BAA8B,GAAG,MAAM;AAC3C,MAAGzB,cAAc,CAACe,MAAf,KAA0B,CAA7B,EAAgC;AAChC,MAAIW,UAAU,GAAGC,SAAS,CAAC,CAAD,EAAK3B,cAAc,CAACe,MAApB,CAA1B;AACA,MAAIa,eAAe,GAAG5B,cAAc,CAAC0B,UAAD,CAApC;AACA,MAAI;AAACR,IAAAA,GAAD;AAAOC,IAAAA,KAAP;AAAeC,IAAAA,MAAf;AAAwBC,IAAAA;AAAxB,MAAgCC,yBAAyB,CAACM,eAAD,EAAiB3B,sBAAjB,CAA7D;;AAEA,MAAGiB,GAAG,IAAIA,GAAG,CAACxB,CAAJ,KAAUkC,eAAe,CAACL,SAAhB,CAA0B7B,CAA3C,IAAgDwB,GAAG,CAACvB,CAAJ,KAAUiC,eAAe,CAACL,SAAhB,CAA0B5B,CAAvF,EAAyF;AACrFiC,IAAAA,eAAe,CAAC/B,KAAhB,CAAsB,CAAtB,IAA2B,KAA3B;AACAqB,IAAAA,GAAG,CAACrB,KAAJ,CAAU,CAAV,IAAe,KAAf;AACH;;AAED,MAAGsB,KAAK,IAAIA,KAAK,CAACzB,CAAN,KAAYkC,eAAe,CAACL,SAAhB,CAA0B7B,CAA/C,IAAoDyB,KAAK,CAACxB,CAAN,KAAYiC,eAAe,CAACL,SAAhB,CAA0B5B,CAA7F,EAA+F;AAC3FiC,IAAAA,eAAe,CAAC/B,KAAhB,CAAsB,CAAtB,IAA2B,KAA3B;AACAsB,IAAAA,KAAK,CAACtB,KAAN,CAAY,CAAZ,IAAiB,KAAjB;AACH;;AAED,MAAGuB,MAAM,IAAIA,MAAM,CAAC1B,CAAP,KAAakC,eAAe,CAACL,SAAhB,CAA0B7B,CAAjD,IAAsD0B,MAAM,CAACzB,CAAP,KAAaiC,eAAe,CAACL,SAAhB,CAA0B5B,CAAhG,EAAkG;AAC9FiC,IAAAA,eAAe,CAAC/B,KAAhB,CAAsB,CAAtB,IAA2B,KAA3B;AACAuB,IAAAA,MAAM,CAACvB,KAAP,CAAa,CAAb,IAAkB,KAAlB;AACH;;AAED,MAAGwB,IAAI,IAAIA,IAAI,CAAC3B,CAAL,KAAWkC,eAAe,CAACL,SAAhB,CAA0B7B,CAA7C,IAAkD2B,IAAI,CAAC1B,CAAL,KAAWiC,eAAe,CAACL,SAAhB,CAA0B5B,CAA1F,EAA4F;AACxFiC,IAAAA,eAAe,CAAC/B,KAAhB,CAAsB,CAAtB,IAA2B,KAA3B;AACAwB,IAAAA,IAAI,CAACxB,KAAL,CAAW,CAAX,IAAgB,KAAhB;AACH;;AAEDK,EAAAA,qBAAqB,GAAG0B,eAAxB;AACA3B,EAAAA,sBAAsB,CAACH,IAAvB,CAA4B8B,eAA5B;AACD,CA5BD;;AA8BA,MAAMN,yBAAyB,GAAG,CAAC1B,IAAD,EAAQiC,KAAR,KAAmB;AACnD,MAAI;AAACnC,IAAAA,CAAD;AAAKC,IAAAA;AAAL,MAAUC,IAAd;AACA,MAAIsB,GAAG,GAAGW,KAAK,CAAClB,IAAN,CAAWmB,CAAC,IAAIA,CAAC,CAACpC,CAAF,KAAQA,CAAR,IAAaoC,CAAC,CAACnC,CAAF,KAAQA,CAAC,GAAG3B,IAAzC,CAAV;AACA,MAAImD,KAAK,GAAGU,KAAK,CAAClB,IAAN,CAAWmB,CAAC,IAAIA,CAAC,CAACpC,CAAF,KAAQA,CAAC,GAAG1B,IAAZ,IAAoB8D,CAAC,CAACnC,CAAF,KAAQA,CAA5C,CAAZ;AACA,MAAIyB,MAAM,GAAGS,KAAK,CAAClB,IAAN,CAAWmB,CAAC,IAAIA,CAAC,CAACpC,CAAF,KAAQA,CAAR,IAAaoC,CAAC,CAACnC,CAAF,KAAQA,CAAC,GAAG3B,IAAzC,CAAb;AACA,MAAIqD,IAAI,GAAGQ,KAAK,CAAClB,IAAN,CAAWmB,CAAC,IAAIA,CAAC,CAACpC,CAAF,KAAQA,CAAC,GAAG1B,IAAZ,IAAoB8D,CAAC,CAACnC,CAAF,KAAQA,CAA5C,CAAX;AAEA,SAAO;AAACuB,IAAAA,GAAD;AAAOC,IAAAA,KAAP;AAAeC,IAAAA,MAAf;AAAwBC,IAAAA;AAAxB,GAAP;AACD,CARD;;AAUA,MAAMM,SAAS,GAAG,CAACI,GAAD,EAAKC,GAAL,KAAa;AAC7B,SAAOzB,IAAI,CAACC,KAAL,CAAWD,IAAI,CAAC0B,MAAL,MAAiBD,GAAG,GAAGD,GAAvB,IAA8BA,GAAzC,CAAP;AACD,CAFD;;AAIA,MAAMG,cAAc,GAAG,MAAM;AAC3BhD,EAAAA,KAAK,GAAG2B,qBAAqB,CAACqB,cAAD,CAA7B;AACA5D,EAAAA,CAAC,CAACwC,SAAF,CAAY,CAAZ,EAAc,CAAd,EAAgBzC,MAAM,CAACJ,KAAvB,EAA8BI,MAAM,CAACH,MAArC;;AAEA,OAAI,IAAIsB,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGjB,KAAK,CAACwC,MAAzB,EAAiCvB,CAAC,EAAlC,EAAsC;AAClCjB,IAAAA,KAAK,CAACiB,CAAD,CAAL,CAASwB,IAAT;AACH;;AAED,OAAI,IAAIxB,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGX,UAAU,CAACkC,MAA9B,EAAsCvB,CAAC,EAAvC,EAA2C;AACvCX,IAAAA,UAAU,CAACW,CAAD,CAAV,CAAcwB,IAAd;AACH;;AAEDhC,EAAAA,UAAU,CAACgC,IAAX;AACA/B,EAAAA,QAAQ,CAAC+B,IAAT;;AACA,MAAG/B,QAAQ,CAACsC,SAAZ,EAAsB;AAClBY,IAAAA,SAAS;AACZ;;AACD,MAAGvD,WAAH,EAAe;AACXU,IAAAA,oBAAoB,CAACJ,KAAD,CAApB;AACH;;AACD,MAAG,CAACD,QAAQ,CAACsC,SAAV,IAAuB,CAAC3C,WAA3B,EAAuC;AACnCwD,IAAAA,UAAU;AACb;AACF,CAvBD;;AAyBA,MAAMA,UAAU,GAAG,MAAM;AACvB,MAAIC,WAAW,GAAG,CAAC,GAAG1D,KAAJ,CAAlB;AACAA,EAAAA,KAAK,CAAC2D,KAAN,GAFuB,CAGvB;;AACA,MAAGrD,QAAQ,CAACsC,SAAZ,EAAsB;AAClB;AACH;;AACD,OAAI,IAAI/B,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAG6C,WAAW,CAACtB,MAA/B,EAAwCvB,CAAC,EAAzC,EAA6C;AACzC+C,IAAAA,mBAAmB,CAACF,WAAW,CAAC7C,CAAD,CAAZ,CAAnB;AACH;AACF,CAVD;;AAYA,MAAM+C,mBAAmB,GAAI3C,IAAD,IAAU;AACpC,MAAIF,CAAC,GAAGE,IAAI,CAACF,CAAb;AACA,MAAIC,CAAC,GAAGC,IAAI,CAACD,CAAb;AACA,MAAI6C,KAAK,GAAG,cAAZ;AACA,MAAIC,iBAAiB,GAAGlE,KAAK,CAACoC,IAAN,CAAW+B,GAAG,IAAIA,GAAG,CAAChD,CAAJ,KAAUE,IAAI,CAACF,CAAf,IAAoBgD,GAAG,CAAC/C,CAAJ,KAAUC,IAAI,CAACD,CAArD,CAAxB,CAJoC,CAKpC;;AACA,MAAIuB,GAAG,GAAG3C,KAAK,CAACoC,IAAN,CAAWmB,CAAC,IAAIA,CAAC,CAACpC,CAAF,KAAQA,CAAR,IAAaoC,CAAC,CAACnC,CAAF,KAAQA,CAAC,GAAG3B,IAAzC,CAAV;;AACA,MAAGkD,GAAG,IAAI,CAACuB,iBAAiB,CAAC5C,KAAlB,CAAwB,CAAxB,CAAR,IAAsC,CAAChB,UAAU,CAAC8B,IAAX,CAAgBmB,CAAC,IAAIA,CAAC,CAACpC,CAAF,KAAQwB,GAAG,CAACxB,CAAZ,IAAiBoC,CAAC,CAACnC,CAAF,KAAQuB,GAAG,CAACvB,CAAlD,CAA1C,EAA+F;AAC3F,QAAIgD,KAAK,GAAGzB,GAAG,CAACxB,CAAhB;AACA,QAAIkD,KAAK,GAAG1B,GAAG,CAACvB,CAAhB;;AACA,QAAGgD,KAAK,KAAK1D,QAAQ,CAACS,CAAnB,IAAwBkD,KAAK,KAAK3D,QAAQ,CAACU,CAA9C,EAAgD;AAC5CV,MAAAA,QAAQ,CAACsC,SAAT,GAAqB3B,IAArB;AACAb,MAAAA,YAAY,GAAGa,IAAf;AACA;AACH,KAJD,MAIK;AACD,UAAIiD,SAAS,GAAG,IAAI9E,KAAJ,CAAU4E,KAAV,EAAiBC,KAAjB,EAAwBJ,KAAxB,EAA+B5C,IAA/B,CAAhB;AACAjB,MAAAA,KAAK,CAACmB,IAAN,CAAW+C,SAAX;AACAhE,MAAAA,UAAU,CAACiB,IAAX,CAAgB+C,SAAhB;AACH;AACJ,GAnBmC,CAqBpC;;;AACA,MAAI1B,KAAK,GAAG5C,KAAK,CAACoC,IAAN,CAAWmB,CAAC,IAAIA,CAAC,CAACpC,CAAF,KAAQA,CAAC,GAAG1B,IAAZ,IAAoB8D,CAAC,CAACnC,CAAF,KAAQA,CAA5C,CAAZ;;AACA,MAAGwB,KAAK,IAAI,CAACsB,iBAAiB,CAAC5C,KAAlB,CAAwB,CAAxB,CAAV,IAAwC,CAAChB,UAAU,CAAC8B,IAAX,CAAgBmB,CAAC,IAAIA,CAAC,CAACpC,CAAF,KAAQyB,KAAK,CAACzB,CAAd,IAAoBoC,CAAC,CAACnC,CAAF,KAAQwB,KAAK,CAACxB,CAAvD,CAA5C,EAAsG;AAClG,QAAImD,OAAO,GAAG3B,KAAK,CAACzB,CAApB;AACA,QAAIqD,OAAO,GAAG5B,KAAK,CAACxB,CAApB;;AACA,QAAGmD,OAAO,KAAK7D,QAAQ,CAACS,CAArB,IAA0BqD,OAAO,KAAK9D,QAAQ,CAACU,CAAlD,EAAoD;AAChDV,MAAAA,QAAQ,CAACsC,SAAT,GAAqB3B,IAArB;AACAb,MAAAA,YAAY,GAAGa,IAAf;AACA;AACH,KAJD,MAIK;AACD,UAAIoD,WAAW,GAAG,IAAIjF,KAAJ,CAAU+E,OAAV,EAAmBC,OAAnB,EAA4BP,KAA5B,EAAmC5C,IAAnC,CAAlB;AACAjB,MAAAA,KAAK,CAACmB,IAAN,CAAWkD,WAAX;AACAnE,MAAAA,UAAU,CAACiB,IAAX,CAAgBkD,WAAhB;AACH;AACJ,GAnCmC,CAqCpC;;;AACA,MAAI5B,MAAM,GAAG7C,KAAK,CAACoC,IAAN,CAAWmB,CAAC,IAAIA,CAAC,CAACpC,CAAF,KAAQA,CAAR,IAAaoC,CAAC,CAACnC,CAAF,KAAQA,CAAC,GAAG3B,IAAzC,CAAb;;AACA,MAAGoD,MAAM,IAAI,CAACqB,iBAAiB,CAAC5C,KAAlB,CAAwB,CAAxB,CAAX,IAAyC,CAAChB,UAAU,CAAC8B,IAAX,CAAgBmB,CAAC,IAAIA,CAAC,CAACpC,CAAF,KAAQ0B,MAAM,CAAC1B,CAAf,IAAqBoC,CAAC,CAACnC,CAAF,KAAQyB,MAAM,CAACzB,CAAzD,CAA7C,EAA0G;AACtG,QAAIsD,QAAQ,GAAG7B,MAAM,CAAC1B,CAAtB;AACA,QAAIwD,QAAQ,GAAG9B,MAAM,CAACzB,CAAtB;;AACA,QAAGsD,QAAQ,KAAKhE,QAAQ,CAACS,CAAtB,IAA2BwD,QAAQ,KAAKjE,QAAQ,CAACU,CAApD,EAAsD;AAClDV,MAAAA,QAAQ,CAACsC,SAAT,GAAqB3B,IAArB;AACAb,MAAAA,YAAY,GAAGa,IAAf;AACA;AACH,KAJD,MAIK;AACD,UAAIuD,YAAY,GAAG,IAAIpF,KAAJ,CAAUkF,QAAV,EAAoBC,QAApB,EAA8BV,KAA9B,EAAqC5C,IAArC,CAAnB;AACAjB,MAAAA,KAAK,CAACmB,IAAN,CAAWqD,YAAX;AACAtE,MAAAA,UAAU,CAACiB,IAAX,CAAgBqD,YAAhB;AACH;AACJ,GAnDmC,CAqDpC;;;AACA,MAAI9B,IAAI,GAAG9C,KAAK,CAACoC,IAAN,CAAWmB,CAAC,IAAIA,CAAC,CAACpC,CAAF,KAAQA,CAAC,GAAG1B,IAAZ,IAAoB8D,CAAC,CAACnC,CAAF,KAAQA,CAA5C,CAAX;;AACA,MAAG0B,IAAI,IAAI,CAACoB,iBAAiB,CAAC5C,KAAlB,CAAwB,CAAxB,CAAT,IAAuC,CAAChB,UAAU,CAAC8B,IAAX,CAAgBmB,CAAC,IAAIA,CAAC,CAACpC,CAAF,KAAQ2B,IAAI,CAAC3B,CAAb,IAAkBoC,CAAC,CAACnC,CAAF,KAAQ0B,IAAI,CAAC1B,CAApD,CAA3C,EAAkG;AAC9F,QAAIyD,MAAM,GAAG/B,IAAI,CAAC3B,CAAlB;AACA,QAAI2D,MAAM,GAAGhC,IAAI,CAAC1B,CAAlB;;AACA,QAAGyD,MAAM,KAAKnE,QAAQ,CAACS,CAApB,IAAyB2D,MAAM,KAAKpE,QAAQ,CAACU,CAAhD,EAAkD;AAC9CV,MAAAA,QAAQ,CAACsC,SAAT,GAAqB3B,IAArB;AACAb,MAAAA,YAAY,GAAGa,IAAf;AACA;AACH,KAJD,MAIK;AACD,UAAI0D,UAAU,GAAG,IAAIvF,KAAJ,CAAUqF,MAAV,EAAiBC,MAAjB,EAAyBb,KAAzB,EAAiC5C,IAAjC,CAAjB;AACAjB,MAAAA,KAAK,CAACmB,IAAN,CAAWwD,UAAX;AACAzE,MAAAA,UAAU,CAACiB,IAAX,CAAgBwD,UAAhB;AACH;AACJ;AAEF,CArED;;AAuEA,MAAMnB,SAAS,GAAG,MAAM;AACtBpD,EAAAA,YAAY,CAACyD,KAAb,GAAqB,OAArB;;AACA,MAAGzD,YAAY,CAACW,CAAb,KAAmBV,UAAU,CAACU,CAA9B,IAAmCX,YAAY,CAACY,CAAb,KAAmBX,UAAU,CAACW,CAApE,EAAsE;AAClEf,IAAAA,WAAW,GAAG,IAAd;AACA;AACH;;AACDG,EAAAA,YAAY,GAAGA,YAAY,CAACwC,SAA5B;AACD,CAPD;;AASA,SAAQnC,KAAR,EAAgB8C,cAAhB","sourcesContent":["import {Node , Block} from './helper_method'\n\nlet size , width , height , cols , rows \n\nlet canvas , c \n\nlet nodes , block \n\nlet visited_nodes , stack \n\nlet quere , finish_path , nodes_path , path , current_node\n \nlet start_node, end_node \n\nlet myReq , myReqDraw\n\nconst setUp = (props) => {\n  c = props.c\n  canvas = props.canvas \n  canvas.width = width\n  canvas.height = height\n  nodes = []\n  visited_nodes = []\n  stack = []\n  quere = []\n  nodes_path = []\n  path = []\n  finish_path = false \n\n  cols = props.cols \n  rows = props.rows \n  size = props.size \n  width = size * cols \n  height = size * rows\n\n  cancelAnimationFrame(myReq)\n  draw_frims_maze()\n}\n\nconst draw_frims_maze = () => {\n  for(let i = 0; i < rows ; i ++){\n      for(let j = 0; j < cols ; j ++){\n          let x = j * size + (size / 2)\n          let y = i * size + (size / 2)\n          let node = new Node(x, y, c , size )\n\n          if(i === 0 && j === 0) {\n              node.walls[3] = false\n          }\n\n          if(j === cols - 1 && i === rows - 1){\n              node.walls[1] = false\n          }\n\n          if(i === 0 && j === 0){\n              stack.push(node)\n              visited_nodes.push(node)\n          }\n\n          nodes.push(node)\n      }\n  }\n\n  start_node = new Block(size / 2,size / 2, c , size, \"blue\")\n  quere.push(start_node)\n  end_node = new Block((cols - 1) * size + (size / 2),( rows - 1 ) * size + (size / 2) , c , size, \"green\")\n\n  setup_prims_maze(nodes, cols , rows)\n}\n\nlet neighbors_node = []\nlet visited_neighbors_node = []\nlet current_neighbor_node\n\nconst setup_prims_maze = (nodes_array , w , h) => {\n  let midd_x =  Math.floor(w / 2) * size + (size / 2)\n  let midd_y =  Math.floor(h / 2) * size + (size / 2)\n  let center_node = nodes_array.find(node => node.x === midd_x && node.y === midd_y)\n  neighbors_node.push(center_node)\n  visited_neighbors_node.push(center_node)\n  current_neighbor_node = center_node\n\n  draw_prims_maze()\n}\n\nconst draw_prims_maze = () => {\n  myReqDraw = requestAnimationFrame(draw_prims_maze)\n  c.clearRect(0,0,canvas.width, canvas.height)\n\n  for(let i = 0; i < nodes.length; i ++){\n      nodes[i].draw()\n  }\n\n  if(neighbors_node.length === 0){\n      cancelAnimationFrame(myReqDraw)\n  }\n\n  add_neighbor_node()\n}\n\nconst add_neighbor_node = () => {\n  let {x , y} = current_neighbor_node\n  \n  let {top , right , bottom , left} = get_top_right_bottom_left(current_neighbor_node , nodes) \n\n  if(\n      top \n      && !visited_neighbors_node.find(node => node.x === x && node.y === y - size)\n      && !neighbors_node.find(node => node.x === x && node.y === y - size)\n  ){\n      neighbors_node.push(top)\n      top.prev_node = current_neighbor_node\n  }\n\n  if(\n      right \n      && !visited_neighbors_node.find(node => node.x === x + size && node.y === y)\n      && !neighbors_node.find(node => node.x === x + size && node.y === y)\n  ){\n      neighbors_node.push(right)\n      right.prev_node = current_neighbor_node\n  }\n\n  if(\n      bottom \n      && !visited_neighbors_node.find(node => node.x === x && node.y === y + size)\n      && !neighbors_node.find(node => node.x === x && node.y === y + size)\n  ){\n      neighbors_node.push(bottom)\n      bottom.prev_node = current_neighbor_node\n  }\n\n  if(\n      left \n      && !visited_neighbors_node.find(node => node.x === x - size && node.y === y)\n      && !neighbors_node.find(node => node.x === x - size && node.y === y)\n  ){\n      neighbors_node.push(left)\n      left.prev_node = current_neighbor_node\n  }\n\n  neighbors_node = neighbors_node.filter(node => node.x === x && node.y === y ? false : true )\n\n  link_node_with_random_neighbor()\n}\n\nconst link_node_with_random_neighbor = () => {\n  if(neighbors_node.length === 0) return\n  let random_num = getRandom(0 , neighbors_node.length)\n  let random_neighbor = neighbors_node[random_num]\n  let {top , right , bottom , left} = get_top_right_bottom_left(random_neighbor,visited_neighbors_node)\n\n  if(top && top.x === random_neighbor.prev_node.x && top.y === random_neighbor.prev_node.y){\n      random_neighbor.walls[0] = false \n      top.walls[2] = false\n  }\n\n  if(right && right.x === random_neighbor.prev_node.x && right.y === random_neighbor.prev_node.y){\n      random_neighbor.walls[1] = false \n      right.walls[3] = false\n  }\n\n  if(bottom && bottom.x === random_neighbor.prev_node.x && bottom.y === random_neighbor.prev_node.y){\n      random_neighbor.walls[2] = false \n      bottom.walls[0] = false\n  }\n\n  if(left && left.x === random_neighbor.prev_node.x && left.y === random_neighbor.prev_node.y){\n      random_neighbor.walls[3] = false \n      left.walls[1] = false\n  }\n\n  current_neighbor_node = random_neighbor\n  visited_neighbors_node.push(random_neighbor)\n}\n\nconst get_top_right_bottom_left = (node , array ) => {\n  let {x , y} = node\n  let top = array.find(n => n.x === x && n.y === y - size)\n  let right = array.find(n => n.x === x + size && n.y === y)\n  let bottom = array.find(n => n.x === x && n.y === y + size)\n  let left = array.find(n => n.x === x - size && n.y === y)\n\n  return {top , right , bottom , left }\n}\n\nconst getRandom = (min,max) => {\n  return Math.floor(Math.random() * (max - min) + min)\n}\n\nconst run_solve_maze = () => {\n  myReq = requestAnimationFrame(run_solve_maze)\n  c.clearRect(0,0,canvas.width, canvas.height)\n\n  for(let i = 0; i < nodes.length; i ++){\n      nodes[i].draw()\n  }\n\n  for(let i = 0; i < nodes_path.length; i ++){\n      nodes_path[i].draw()\n  }\n\n  start_node.draw()\n  end_node.draw()\n  if(end_node.prev_node){\n      find_path()\n  }\n  if(finish_path){\n      cancelAnimationFrame(myReq)\n  }\n  if(!end_node.prev_node && !finish_path){\n      solve_maze()\n  }\n}\n\nconst solve_maze = () => {\n  let quere_nodes = [...quere]\n  quere.shift()\n  // visited_nodes_for_path.push(current_node)\n  if(end_node.prev_node){\n      return\n  }\n  for(let i = 0; i < quere_nodes.length ; i ++){\n      check_neighbor_node(quere_nodes[i])\n  }\n}\n\nconst check_neighbor_node = (node) => {\n  let x = node.x\n  let y = node.y\n  let color = \"MidnightBlue\"\n  let current_find_node = nodes.find(c_n => c_n.x === node.x && c_n.y === node.y )\n  // top \n  let top = nodes.find(n => n.x === x && n.y === y - size)\n  if(top && !current_find_node.walls[0] && !nodes_path.find(n => n.x === top.x && n.y === top.y)){\n      let top_x = top.x\n      let top_y = top.y\n      if(top_x === end_node.x && top_y === end_node.y){\n          end_node.prev_node = node \n          current_node = node \n          return \n      }else{\n          let top_block = new Block(top_x, top_y, color, node)\n          quere.push(top_block)\n          nodes_path.push(top_block)\n      }\n  }\n\n  // right\n  let right = nodes.find(n => n.x === x + size && n.y === y )\n  if(right && !current_find_node.walls[1] && !nodes_path.find(n => n.x === right.x  && n.y === right.y)){\n      let right_x = right.x \n      let right_y = right.y \n      if(right_x === end_node.x && right_y === end_node.y){\n          end_node.prev_node = node \n          current_node = node \n          return \n      }else{\n          let right_block = new Block(right_x, right_y, color ,node)\n          quere.push(right_block)\n          nodes_path.push(right_block)\n      }\n  }\n\n  // bottom\n  let bottom = nodes.find(n => n.x === x && n.y === y + size ) \n  if(bottom && !current_find_node.walls[2] && !nodes_path.find(n => n.x === bottom.x  && n.y === bottom.y )){\n      let bottom_x = bottom.x \n      let bottom_y = bottom.y \n      if(bottom_x === end_node.x && bottom_y === end_node.y){\n          end_node.prev_node = node \n          current_node = node \n          return \n      }else{\n          let bottom_block = new Block(bottom_x, bottom_y, color ,node)\n          quere.push(bottom_block)\n          nodes_path.push(bottom_block)\n      }\n  }\n\n  // left \n  let left = nodes.find(n => n.x === x - size && n.y === y)\n  if(left && !current_find_node.walls[3] && !nodes_path.find(n => n.x === left.x && n.y === left.y)){\n      let left_x = left.x \n      let left_y = left.y \n      if(left_x === end_node.x && left_y === end_node.y){\n          end_node.prev_node = node \n          current_node = node \n          return \n      }else{\n          let left_block = new Block(left_x,left_y, color , node)\n          quere.push(left_block)\n          nodes_path.push(left_block)\n      }\n  }\n\n}\n\nconst find_path = () => {\n  current_node.color = \"green\"\n  if(current_node.x === start_node.x && current_node.y === start_node.y){\n      finish_path = true\n      return\n  }\n  current_node = current_node.prev_node\n}\n\nexport {setUp , run_solve_maze}\n"]},"metadata":{},"sourceType":"module"}