{"ast":null,"code":"import { Block } from '../helper_method';\nlet start_node, end_node, nodes, c, canvas, size;\nlet open_list_1, close_list_1, current_node_1, open_list_2, close_list_2, current_node_2, myReq, finish_path, finish_search;\n\nconst bidirectional_a_star = props => {\n  start_node = props.start_node;\n  end_node = props.end_node;\n  nodes = props.nodes;\n  c = props.c;\n  canvas = props.canvas;\n  size = props.size; // end_node.prev_node = null\n\n  open_list_1 = [start_node];\n  close_list_1 = [];\n  open_list_2 = [end_node];\n  close_list_2 = [];\n  current_node_1 = null;\n  current_node_2 = null;\n  finish_path = false;\n  finish_search = false;\n  cancelAnimationFrame(myReq);\n  run_solve_maze();\n};\n\nconst stop_bidirectional_a_star = () => {\n  cancelAnimationFrame(myReq);\n};\n\nconst run_solve_maze = () => {\n  myReq = requestAnimationFrame(run_solve_maze);\n  c.clearRect(0, 0, canvas.width, canvas.height);\n\n  for (let i = 0; i < nodes.length; i++) {\n    nodes[i].draw();\n  }\n\n  print_close_and_open_list(close_list_1, open_list_1, 'DeepSkyBlue', 'MidnightBlue');\n  print_close_and_open_list(close_list_2, open_list_2, 'Cyan', 'DarkCyan'); // for(let i = 0 ; i < close_list.length ; i ++){\n  //     if(!end_node.prev_node){\n  //         close_list[i].color = 'MidnightBlue'\n  //     }\n  //     close_list[i].draw()\n  // }\n  // for(let i = 0 ; i < open_list.length ; i ++){\n  //     open_list[i].color = 'DeepSkyBlue'\n  //     open_list[i].draw()\n  // }\n\n  if (open_list_1.length > 0 && !finish_search) {\n    current_node_1 = open_list_1.sort((a, b) => a.f - b.f)[0];\n    close_list_1.push(current_node_1);\n    open_list_1 = find_child_node(current_node_1, end_node, open_list_1, close_list_1, close_list_2);\n  }\n\n  if (open_list_2.length > 0 && !finish_search) {\n    current_node_2 = open_list_2.sort((a, b) => a.f - b.f)[0];\n    close_list_2.push(current_node_2);\n    open_list_2 = find_child_node(current_node_2, start_node, open_list_2, close_list_2, close_list_1);\n  } // if(end_node.prev_node && !finish_path){\n  //     start_node.draw()\n  //     end_node.draw()\n  //     find_path() \n  // }\n\n\n  if (finish_path) {\n    cancelAnimationFrame(myReq);\n  }\n};\n\nconst print_close_and_open_list = (close_list, open_list, close_color, open_color) => {\n  for (let i = 0; i < open_list.length; i++) {\n    open_list[i].color = close_color;\n    open_list[i].draw();\n  }\n\n  for (let i = 0; i < close_list.length; i++) {\n    if (!finish_search) {\n      close_list[i].color = open_color;\n    }\n\n    close_list[i].draw();\n  }\n};\n\nconst find_child_node = (c_node, target_node, open_list, close_list, target_close_list) => {\n  let {\n    top,\n    right,\n    bottom,\n    left\n  } = get_top_right_bottom_left(c_node, nodes); // Right (x + size , y)\n\n  if (right && !right.walls[3] && !close_list.find(node => node.x === right.x && node.y === right.y)) {\n    let right_in_open = open_list.find(n => n.x === right.x && n.y === right.y);\n    let r_g = c_node.g + size;\n\n    if (target_close_list.find(node => node.x === right.x && node.y === right.y)) {\n      finish_path = true;\n      finish_search = true;\n    } else {\n      right_in_open && r_g < right_in_open.g ? update_node(right_in_open, r_g, c_node) : open_list.push(set_node(right, r_g, c_node, target_node));\n    }\n  } // top (x , y - size)\n\n\n  if (top && !top.walls[2] && !close_list.find(node => node.x === top.x && node.y === top.y)) {\n    let top_in_open = open_list.find(n => n.x === top.x && n.y === top.y);\n    let t_g = c_node.g + size;\n\n    if (target_close_list.find(node => node.x === top.x && node.y === top.y)) {\n      finish_path = true;\n      finish_search = true;\n    } else {\n      top_in_open && t_g < top_in_open.g ? update_node(top_in_open, c_node) : open_list.push(set_node(top, t_g, c_node, target_node));\n    }\n  } // left (x - size , y )\n\n\n  if (left && !left.walls[1] && !close_list.find(node => node.x === left.x && node.y === left.y)) {\n    let left_in_open = open_list.find(n => n.x === left.x && n.y === left.y);\n    let l_g = c_node.g + size;\n\n    if (target_close_list.find(node => node.x === left.x && node.y === left.y)) {\n      finish_path = true;\n      finish_search = true;\n    } else {\n      left_in_open && l_g < left_in_open.g ? update_node(left_in_open, c_node) : open_list.push(set_node(left, l_g, c_node, target_node));\n    }\n  } // bottom (x , y + size)\n\n\n  if (bottom && !bottom.walls[0] && !close_list.find(node => node.x === bottom.x && node.y === bottom.y)) {\n    let bottom_in_open = open_list.find(n => n.x === bottom.x && n.y === bottom.y);\n    let b_g = c_node.g + size;\n\n    if (target_close_list.find(node => node.x === bottom.x && node.y === bottom.y)) {\n      finish_path = true;\n      finish_search = true;\n    } else {\n      bottom_in_open && b_g < bottom_in_open.g ? update_node(bottom_in_open, c_node) : open_list.push(set_node(bottom, b_g, c_node, target_node));\n    }\n  }\n\n  return open_list.filter(node => node.x === c_node.x && node.y === c_node.y ? false : true);\n}; // const find_path = () => {\n//     current_node.color = \"LimeGreen\"\n//     if(current_node.x === start_node.x && current_node.y === start_node.y){\n//         finish_path = true\n//         return\n//     }\n//     current_node = current_node.prev_node\n//     return \n// }\n\n\nconst set_node = (node, g, c_node, target_node) => {\n  let color = \"MidnightBlue\";\n  let x_1 = node.x;\n  let y_1 = node.y;\n  let x_2 = target_node.x;\n  let y_2 = target_node.y;\n  let h = (Math.abs(x_1 - x_2) + Math.abs(y_1 - y_2)) * size;\n  let f = h + g;\n  let new_node = new Block(x_1, y_1, c, size, color, c_node, g, h, f);\n  return new_node;\n};\n\nconst update_node = (node, g, parent) => {\n  node.g = g;\n  node.f = g + node.h;\n  node.parent = parent;\n};\n\nconst get_top_right_bottom_left = (node, array) => {\n  let {\n    x,\n    y\n  } = node;\n  let top = array.find(n => n.x === x && n.y === y - size);\n  let right = array.find(n => n.x === x + size && n.y === y);\n  let bottom = array.find(n => n.x === x && n.y === y + size);\n  let left = array.find(n => n.x === x - size && n.y === y);\n  return {\n    top,\n    right,\n    bottom,\n    left\n  };\n};\n\nexport { bidirectional_a_star, stop_bidirectional_a_star };","map":{"version":3,"sources":["/Users/vienpham/Desktop/Algorithms_simulation/algorithms/src/Algorithms/solve_maze/bidirectional_a_star.js"],"names":["Block","start_node","end_node","nodes","c","canvas","size","open_list_1","close_list_1","current_node_1","open_list_2","close_list_2","current_node_2","myReq","finish_path","finish_search","bidirectional_a_star","props","cancelAnimationFrame","run_solve_maze","stop_bidirectional_a_star","requestAnimationFrame","clearRect","width","height","i","length","draw","print_close_and_open_list","sort","a","b","f","push","find_child_node","close_list","open_list","close_color","open_color","color","c_node","target_node","target_close_list","top","right","bottom","left","get_top_right_bottom_left","walls","find","node","x","y","right_in_open","n","r_g","g","update_node","set_node","top_in_open","t_g","left_in_open","l_g","bottom_in_open","b_g","filter","x_1","y_1","x_2","y_2","h","Math","abs","new_node","parent","array"],"mappings":"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","sourcesContent":["import { Block } from '../helper_method'\n\nlet start_node , end_node , nodes , c , canvas , size \n\nlet open_list_1 , close_list_1 , current_node_1 , open_list_2 , close_list_2 , current_node_2 , myReq , finish_path , finish_search \n\nconst bidirectional_a_star = props => {\n    start_node = props.start_node\n    end_node = props.end_node \n    nodes = props.nodes\n    c = props.c \n    canvas = props.canvas \n    size = props.size \n\n    // end_node.prev_node = null\n\n    open_list_1 = [start_node]\n    close_list_1 = []\n\n    open_list_2 = [end_node]\n    close_list_2 = []\n\n    current_node_1 = null \n    current_node_2 = null \n\n    finish_path = false \n    finish_search = false \n\n    cancelAnimationFrame(myReq)\n    run_solve_maze()\n}\n\nconst stop_bidirectional_a_star = () => {\n    cancelAnimationFrame(myReq)\n}\n\nconst run_solve_maze = () => {\n    myReq = requestAnimationFrame(run_solve_maze)\n    c.clearRect(0,0,canvas.width, canvas.height)\n\n    for(let i = 0 ; i < nodes.length ; i ++){\n        nodes[i].draw()\n    }\n\n    print_close_and_open_list(close_list_1 , open_list_1 , 'DeepSkyBlue' , 'MidnightBlue')\n    print_close_and_open_list(close_list_2 , open_list_2 , 'Cyan' , 'DarkCyan')\n\n    // for(let i = 0 ; i < close_list.length ; i ++){\n    //     if(!end_node.prev_node){\n    //         close_list[i].color = 'MidnightBlue'\n    //     }\n    //     close_list[i].draw()\n    // }\n\n    // for(let i = 0 ; i < open_list.length ; i ++){\n    //     open_list[i].color = 'DeepSkyBlue'\n    //     open_list[i].draw()\n    // }\n\n    if(open_list_1.length > 0 && !finish_search){\n        current_node_1= open_list_1.sort((a,b) => a.f - b.f)[0]\n        close_list_1.push(current_node_1)\n        open_list_1 = find_child_node(current_node_1 , end_node, open_list_1 , close_list_1 , close_list_2)\n    }\n\n    if(open_list_2.length > 0 && !finish_search){\n        current_node_2= open_list_2.sort((a,b) => a.f - b.f)[0]\n        close_list_2.push(current_node_2)\n        open_list_2 = find_child_node(current_node_2 , start_node, open_list_2 , close_list_2 , close_list_1)\n    }\n\n    // if(end_node.prev_node && !finish_path){\n    //     start_node.draw()\n    //     end_node.draw()\n    //     find_path() \n    // }\n\n    if(finish_path){\n        cancelAnimationFrame(myReq)\n    }\n}\n\nconst print_close_and_open_list = (close_list , open_list , close_color , open_color ) => {\n    for(let i = 0 ; i < open_list.length ; i ++){\n        open_list[i].color = close_color\n        open_list[i].draw()\n    }\n\n    for(let i = 0 ; i < close_list.length ; i ++){\n        if(!finish_search){\n            close_list[i].color = open_color \n        }\n        close_list[i].draw()\n    }\n}\n\nconst find_child_node = (c_node , target_node , open_list , close_list , target_close_list) => {\n\n    let {top , right , bottom , left} = get_top_right_bottom_left(c_node , nodes )\n\n    // Right (x + size , y)\n    if(right && !right.walls[3] && !close_list.find(node => node.x === right.x  && node.y === right.y)){\n        let right_in_open = open_list.find(n => n.x === right.x  && n.y === right.y)\n        let r_g = c_node.g + size\n\n        if(target_close_list.find(node => node.x === right.x  && node.y === right.y)){\n            finish_path = true \n            finish_search = true \n        }else{\n            right_in_open && r_g < right_in_open.g \n                ? update_node(right_in_open, r_g , c_node )\n                : open_list.push(set_node(right , r_g , c_node , target_node))\n        }\n    }\n\n    // top (x , y - size)\n    if(top && !top.walls[2] && !close_list.find(node => node.x === top.x && node.y === top.y)){\n        let top_in_open = open_list.find(n => n.x === top.x  && n.y === top.y)\n        let t_g = c_node.g + size \n\n        if(target_close_list.find(node => node.x === top.x && node.y === top.y)){\n            finish_path = true \n            finish_search = true \n        }else{\n            top_in_open && t_g < top_in_open.g \n                ? update_node(top_in_open , c_node)\n                : open_list.push(set_node(top , t_g , c_node , target_node))\n        }\n    }\n\n    // left (x - size , y )\n    if(left && !left.walls[1] && !close_list.find(node => node.x === left.x && node.y === left.y)){\n        let left_in_open = open_list.find(n => n.x === left.x  && n.y === left.y)\n        let l_g = c_node.g + size\n        if(target_close_list.find(node => node.x === left.x && node.y === left.y)){\n            finish_path = true \n            finish_search = true \n        }else{\n            left_in_open && l_g < left_in_open.g \n                ? update_node(left_in_open , c_node)\n                : open_list.push(set_node(left , l_g , c_node , target_node))\n        }\n    }\n\n    // bottom (x , y + size)\n    if(bottom && !bottom.walls[0] &&!close_list.find(node => node.x === bottom.x && node.y === bottom.y)){\n        let bottom_in_open = open_list.find(n => n.x === bottom.x  && n.y === bottom.y)\n        let b_g = c_node.g + size \n        if(target_close_list.find(node => node.x === bottom.x && node.y === bottom.y)){\n            finish_path = true \n            finish_search = true \n        }else{\n            bottom_in_open && b_g < bottom_in_open.g \n                ? update_node(bottom_in_open , c_node)\n                : open_list.push(set_node(bottom , b_g , c_node , target_node))\n        }\n    }\n\n    return open_list.filter(node => node.x === c_node.x && node.y === c_node.y ? false : true ) \n}\n\n// const find_path = () => {\n//     current_node.color = \"LimeGreen\"\n//     if(current_node.x === start_node.x && current_node.y === start_node.y){\n//         finish_path = true\n//         return\n//     }\n//     current_node = current_node.prev_node\n//     return \n// }\n\nconst set_node = (node, g , c_node , target_node) => {\n    let color = \"MidnightBlue\"\n    let x_1 = node.x \n    let y_1 = node.y \n    let x_2 = target_node.x \n    let y_2 = target_node.y    \n    let h = (Math.abs(x_1 - x_2) + Math.abs(y_1 - y_2)) * size \n    let f = h + g \n    let new_node = new Block(x_1 , y_1 , c , size , color , c_node , g , h , f)\n    return new_node \n}\n\nconst update_node = (node , g , parent) => {\n    node.g = g \n    node.f = g + node.h \n    node.parent = parent \n}\n\nconst get_top_right_bottom_left = (node , array ) => {\n    let {x , y} = node\n    let top = array.find(n => n.x === x && n.y === y - size)\n    let right = array.find(n => n.x === x + size && n.y === y)\n    let bottom = array.find(n => n.x === x && n.y === y + size)\n    let left = array.find(n => n.x === x - size && n.y === y)\n\n    return {top , right , bottom , left }\n}\n\nexport {bidirectional_a_star , stop_bidirectional_a_star}"]},"metadata":{},"sourceType":"module"}