{"ast":null,"code":"import{Block}from'../helper_method';import{get_top_right_bottom_left,add_to_heap,remove_from_heap}from'./helper_method/algorithms_helper_method';var start_node,end_node,nodes,c,canvas,size;var open_list,close_list,current_node,myReq,finish_path;var dijkstra=function dijkstra(props){start_node=props.start_node;start_node.distance=0;end_node=props.end_node;nodes=props.nodes;c=props.c;canvas=props.canvas;size=props.size;end_node.prev_node=null;open_list=[start_node];close_list=[];current_node=null;finish_path=false;cancelAnimationFrame(myReq);run_solve_maze();};var stop_dijkstra=function stop_dijkstra(){cancelAnimationFrame(myReq);};var run_solve_maze=function run_solve_maze(){myReq=requestAnimationFrame(run_solve_maze);c.clearRect(0,0,canvas.width,canvas.height);for(var i=0;i<nodes.length;i++){nodes[i].draw();}for(var _i=0;_i<close_list.length;_i++){if(!end_node.prev_node){close_list[_i].color='MediumBlue';}close_list[_i].draw();}for(var _i2=0;_i2<open_list.length;_i2++){open_list[_i2].color='LightSkyBlue';open_list[_i2].draw();}if(current_node&&end_node.x===current_node.x&&end_node.y===current_node.y){end_node.prev_node=current_node.prev_node;}if(open_list.length>0&&!end_node.prev_node){// current_node = open_list.sort((a,b) => a.distance - b.distance)[0] \ncurrent_node=open_list[0];close_list.push(current_node);find_child_node();}if(end_node.prev_node){start_node.draw();end_node.draw();find_path();}if(finish_path||open_list.length===0){cancelAnimationFrame(myReq);}};var find_child_node=function find_child_node(){open_list=remove_from_heap(open_list,function(a,b){return a.distance<b.distance;});var _get_top_right_bottom=get_top_right_bottom_left(current_node,nodes,size),top=_get_top_right_bottom.top,right=_get_top_right_bottom.right,bottom=_get_top_right_bottom.bottom,left=_get_top_right_bottom.left;// right (x + size , y)\nadd_node(right,3);// top (x , y - size)\nadd_node(top,2);// left (x - size , y )\nadd_node(left,1);// bottom (x , y + size)\nadd_node(bottom,0);open_list=open_list.filter(function(node){return node.x===current_node.x&&node.y===current_node.y?false:true;});};var add_node=function add_node(neighbor_node,wall_num){if(neighbor_node&&!neighbor_node.walls[wall_num]&&!close_list.find(function(node){return node.x===neighbor_node.x&&node.y===neighbor_node.y;})){var x=neighbor_node.x,y=neighbor_node.y;var node_in_open=open_list.find(function(n){return n.x===x&&n.y===y;});if(node_in_open){update_node(node_in_open);}else{var new_node=create_new_node(neighbor_node);open_list=add_to_heap(new_node,open_list,function(a,b){return a.distance<b.distance;});}}};var find_path=function find_path(){current_node.color=\"LimeGreen\";if(current_node.x===start_node.x&&current_node.y===start_node.y){finish_path=true;return;}current_node=current_node.prev_node;return;};var create_new_node=function create_new_node(node){var distance=find_distance(node);return new Block(node.x,node.y,c,size,'MediumBlue',current_node,null,null,null,distance);};var find_distance=function find_distance(node){// find distance from current node to next node \nvar x_1=current_node.x;var y_1=current_node.y;var x_2=node.x;var y_2=node.y;return(Math.abs(x_1-x_2)+Math.abs(y_1-y_2))*size+current_node.distance;};var update_node=function update_node(node){if(current_node.distance+size<node.distance){node.distance=find_distance(node);}};export{dijkstra,stop_dijkstra};","map":{"version":3,"sources":["/Users/vienpham/Desktop/Algorithms_simulation/algorithms/src/Algorithms/solve_maze/dijkstra.js"],"names":["Block","get_top_right_bottom_left","add_to_heap","remove_from_heap","start_node","end_node","nodes","c","canvas","size","open_list","close_list","current_node","myReq","finish_path","dijkstra","props","distance","prev_node","cancelAnimationFrame","run_solve_maze","stop_dijkstra","requestAnimationFrame","clearRect","width","height","i","length","draw","color","x","y","push","find_child_node","find_path","a","b","top","right","bottom","left","add_node","filter","node","neighbor_node","wall_num","walls","find","node_in_open","n","update_node","new_node","create_new_node","find_distance","x_1","y_1","x_2","y_2","Math","abs"],"mappings":"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","sourcesContent":["import { Block } from '../helper_method'\n\nimport {get_top_right_bottom_left , add_to_heap , remove_from_heap} from './helper_method/algorithms_helper_method'\n\nlet start_node , end_node , nodes , c , canvas , size \n\nlet open_list , close_list , current_node , myReq , finish_path\n\nconst dijkstra = props => {\n    start_node = props.start_node\n    start_node.distance = 0\n    end_node = props.end_node \n    nodes = props.nodes\n    c = props.c \n    canvas = props.canvas \n    size = props.size \n\n    end_node.prev_node = null\n    \n    open_list = [start_node]\n    close_list = []\n    current_node = null \n    finish_path = false \n\n    cancelAnimationFrame(myReq)\n    run_solve_maze()\n}\n\nconst stop_dijkstra = () => {\n    cancelAnimationFrame(myReq)\n}\n\nconst run_solve_maze = () => {\n    myReq = requestAnimationFrame(run_solve_maze)\n    c.clearRect(0,0,canvas.width, canvas.height)\n\n    for(let i = 0 ; i < nodes.length ; i ++){\n        nodes[i].draw()\n    }\n\n    for(let i = 0 ; i < close_list.length ; i ++){\n        if(!end_node.prev_node){\n            close_list[i].color = 'MediumBlue'\n        }\n        close_list[i].draw()\n    }\n\n    for(let i = 0 ; i < open_list.length ; i ++){\n        open_list[i].color = 'LightSkyBlue' \n        open_list[i].draw()\n    }\n\n    if(current_node && end_node.x === current_node.x && end_node.y === current_node.y){\n        end_node.prev_node = current_node.prev_node\n    }\n\n    if(open_list.length > 0 && !end_node.prev_node){\n        // current_node = open_list.sort((a,b) => a.distance - b.distance)[0] \n        current_node = open_list[0] \n        close_list.push(current_node)\n        find_child_node()\n    }\n\n    if(end_node.prev_node){\n        start_node.draw()\n        end_node.draw()\n        find_path() \n    }\n\n    if(finish_path || open_list.length === 0){\n        cancelAnimationFrame(myReq)\n    }\n}\n\nconst find_child_node = () => {\n    open_list = remove_from_heap(open_list , (a,b) => a.distance < b.distance)\n    let {top , right , bottom , left} = get_top_right_bottom_left(current_node , nodes , size)\n\n    // right (x + size , y)\n    add_node(right , 3)\n\n    // top (x , y - size)\n    add_node(top , 2)\n\n    // left (x - size , y )\n    add_node(left , 1)\n\n    // bottom (x , y + size)\n    add_node(bottom , 0)\n\n    open_list = open_list.filter(node => node.x === current_node.x && node.y === current_node.y ? false : true )\n}\n\nconst add_node = (neighbor_node , wall_num) => {\n    if(\n        neighbor_node \n        && !neighbor_node.walls[wall_num] \n        &&!close_list.find(node => node.x === neighbor_node.x && node.y === neighbor_node.y)\n    ){\n        let {x , y} = neighbor_node\n        let node_in_open = open_list.find(n => n.x === x  && n.y === y)\n        \n        if(node_in_open){\n            update_node(node_in_open)\n        }else{\n            let new_node = create_new_node(neighbor_node)\n            open_list = add_to_heap(new_node , open_list , (a,b) => a.distance < b.distance)\n        }\n            \n    }\n}\n\nconst find_path = () => {\n    current_node.color = \"LimeGreen\"\n    if(current_node.x === start_node.x && current_node.y === start_node.y){\n        finish_path = true\n        return\n    }\n    current_node = current_node.prev_node\n    return \n}\n\nconst create_new_node = (node) => {\n    let distance = find_distance(node)\n    return new Block(node.x , node.y , c , size , 'MediumBlue' , current_node , null , null , null , distance)\n}\n\nconst find_distance = (node) => {\n    // find distance from current node to next node \n    let x_1 = current_node.x \n    let y_1 = current_node.y \n\n    let x_2 = node.x \n    let y_2 = node.y\n\n   return ((Math.abs(x_1 - x_2) + Math.abs(y_1 - y_2)) * size ) + current_node.distance\n}\n\nconst update_node = node => {\n    if(current_node.distance + size < node.distance){\n        node.distance = find_distance(node)\n    }\n}\n\nexport {dijkstra , stop_dijkstra}"]},"metadata":{},"sourceType":"module"}