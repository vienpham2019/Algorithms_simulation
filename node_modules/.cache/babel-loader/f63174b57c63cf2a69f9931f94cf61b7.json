{"ast":null,"code":"import { Block } from '../helper_method';\nlet start_node, end_node, nodes, c, canvas, size;\nlet close_list_1, close_list_2, open_list_1, current_node_1, open_list_2, current_node_2, myReq, finish_path, finish_search, current_node;\n\nconst bidirectional_dijkstra = props => {\n  start_node = props.start_node;\n  start_node.distance = 0;\n  end_node = props.end_node;\n  nodes = props.nodes;\n  c = props.c;\n  canvas = props.canvas;\n  size = props.size; // end_node.prev_node = null\n\n  open_list_1 = [start_node];\n  close_list_1 = [];\n  open_list_2 = [end_node];\n  close_list_2 = [];\n  current_node_1 = start_node;\n  current_node_2 = end_node;\n  finish_path = false;\n  finish_search = false;\n  current_node = null;\n  cancelAnimationFrame(myReq);\n  run_solve_maze();\n};\n\nconst stop_bidirectional_dijkstra = () => {\n  cancelAnimationFrame(myReq);\n};\n\nconst run_solve_maze = () => {\n  myReq = requestAnimationFrame(run_solve_maze);\n  c.clearRect(0, 0, canvas.width, canvas.height);\n\n  for (let i = 0; i < nodes.length; i++) {\n    nodes[i].draw();\n  }\n\n  for (let i = 0; i < open_list_1.length; i++) {\n    open_list_1[i].color = 'DeepSkyBlue';\n    open_list_1[i].draw();\n  }\n\n  for (let i = 0; i < open_list_2.length; i++) {\n    open_list_2[i].color = 'green';\n    open_list_2[i].draw();\n  }\n\n  for (let i = 0; i < close_list_1.length; i++) {\n    if (!finish_search) {\n      close_list_1[i].color = 'MidnightBlue';\n    }\n\n    close_list_1[i].draw();\n  }\n\n  for (let i = 0; i < close_list_2.length; i++) {\n    if (!finish_search) {\n      close_list_2[i].color = 'red';\n    }\n\n    close_list_2[i].draw();\n  } // if(current_node_1.x === current_node_2.x && current_node_1.y === current_node_2.y){\n  //     finish_search = true \n  //     current_node = end_node\n  //     // finish_path = true \n  // }\n\n\n  if (open_list_2.length > 0 && !finish_search) {\n    current_node_2 = open_list_2.sort((a, b) => a.distance - b.distance)[0];\n    close_list_2.push(current_node_2);\n    open_list_2 = find_child_node(current_node_2, open_list_2, close_list_2, close_list_1);\n  }\n\n  if (open_list_1.length > 0 && !finish_search) {\n    current_node_1 = open_list_1.sort((a, b) => a.distance - b.distance)[0];\n    close_list_1.push(current_node_1);\n    open_list_1 = find_child_node(current_node_1, open_list_1, close_list_1, close_list_2);\n  }\n\n  if (finish_search) {\n    start_node.draw();\n    end_node.draw();\n\n    if (current_node_1) {\n      current_node_1 = find_path(current_node_1);\n    }\n\n    if (current_node_2) {\n      current_node_2 = find_path(current_node_2);\n    }\n  }\n\n  if (finish_path) {\n    cancelAnimationFrame(myReq);\n  }\n};\n\nconst find_child_node = (c_node, open_list, close_list, next_close_list) => {\n  let {\n    top,\n    right,\n    bottom,\n    left\n  } = get_top_right_bottom_left(c_node, nodes); // Right (x + size , y)\n\n  if (right && !right.walls[3] && !close_list.find(node => node.x === right.x && node.y === right.y)) {\n    let right_in_open = open_list.find(n => n.x === right.x && n.y === right.y);\n\n    if (next_close_list.find(node => node.x === right.x && node.y === right.y)) {\n      finish_search = true;\n    }\n\n    right_in_open ? update_node(right_in_open, c_node) : open_list.push(create_new_node(right, c_node));\n  } // top (x , y - size)\n\n\n  if (top && !top.walls[2] && !close_list.find(node => node.x === top.x && node.y === top.y)) {\n    let top_in_open = open_list.find(n => n.x === top.x && n.y === top.y);\n\n    if (next_close_list.find(node => node.x === top.x && node.y === top.y)) {\n      finish_search = true;\n    }\n\n    top_in_open ? update_node(top_in_open, c_node) : open_list.push(create_new_node(top, c_node));\n  } // left (x - size , y )\n\n\n  if (left && !left.walls[1] && !close_list.find(node => node.x === left.x && node.y === left.y)) {\n    let left_in_open = open_list.find(n => n.x === left.x && n.y === left.y);\n\n    if (next_close_list.find(node => node.x === left.x && node.y === left.y)) {\n      finish_search = true;\n    }\n\n    left_in_open ? update_node(left_in_open, c_node) : open_list.push(create_new_node(left, c_node));\n  } // bottom (x , y + size)\n\n\n  if (bottom && !bottom.walls[0] && !close_list.find(node => node.x === bottom.x && node.y === bottom.y)) {\n    let bottom_in_open = open_list.find(n => n.x === bottom.x && n.y === bottom.y);\n\n    if (next_close_list.find(node => node.x === bottom.x && node.y === bottom.y)) {\n      finish_search = true;\n    }\n\n    bottom_in_open ? update_node(bottom_in_open, c_node) : open_list.push(create_new_node(bottom, c_node));\n  }\n\n  return open_list.filter(node => node.x === c_node.x && node.y === c_node.y ? false : true);\n};\n\nconst find_path = node => {\n  node.color = \"LimeGreen\";\n\n  if (current_node_1.prev_node || current_node_2.prev_node) {\n    node = node.prev_node;\n  } else {\n    finish_path = true;\n  }\n\n  return node;\n};\n\nconst create_new_node = (node, c_node) => {\n  let distance = find_distance(node, c_node);\n  return new Block(node.x, node.y, c, size, 'MidnightBlue', c_node, null, null, null, distance);\n};\n\nconst find_distance = (node, c_node) => {\n  // find distance from current node to next node \n  let x_1 = c_node.x;\n  let y_1 = c_node.y;\n  let x_2 = node.x;\n  let y_2 = node.y;\n  return (Math.abs(x_1 - x_2) + Math.abs(y_1 - y_2)) * size + c_node.distance;\n};\n\nconst update_node = (node, c_node) => {\n  if (c_node.distance + size < node.distance) {\n    node.distance = find_distance(node, c_node);\n  }\n\n  return node;\n};\n\nconst get_top_right_bottom_left = (node, array) => {\n  let {\n    x,\n    y\n  } = node;\n  let top = array.find(n => n.x === x && n.y === y - size);\n  let right = array.find(n => n.x === x + size && n.y === y);\n  let bottom = array.find(n => n.x === x && n.y === y + size);\n  let left = array.find(n => n.x === x - size && n.y === y);\n  return {\n    top,\n    right,\n    bottom,\n    left\n  };\n};\n\nexport { bidirectional_dijkstra, stop_bidirectional_dijkstra };","map":{"version":3,"sources":["/Users/vienpham/Desktop/Algorithms_simulation/algorithms/src/Algorithms/solve_maze/bidirectional_dijkstra.js"],"names":["Block","start_node","end_node","nodes","c","canvas","size","close_list_1","close_list_2","open_list_1","current_node_1","open_list_2","current_node_2","myReq","finish_path","finish_search","current_node","bidirectional_dijkstra","props","distance","cancelAnimationFrame","run_solve_maze","stop_bidirectional_dijkstra","requestAnimationFrame","clearRect","width","height","i","length","draw","color","sort","a","b","push","find_child_node","find_path","c_node","open_list","close_list","next_close_list","top","right","bottom","left","get_top_right_bottom_left","walls","find","node","x","y","right_in_open","n","update_node","create_new_node","top_in_open","left_in_open","bottom_in_open","filter","prev_node","find_distance","x_1","y_1","x_2","y_2","Math","abs","array"],"mappings":"AAAA,SAASA,KAAT,QAAsB,kBAAtB;AAEA,IAAIC,UAAJ,EAAiBC,QAAjB,EAA4BC,KAA5B,EAAoCC,CAApC,EAAwCC,MAAxC,EAAiDC,IAAjD;AAEA,IAAIC,YAAJ,EAAmBC,YAAnB,EAAkCC,WAAlC,EAAgDC,cAAhD,EAAiEC,WAAjE,EAA8EC,cAA9E,EAA+FC,KAA/F,EAAuGC,WAAvG,EAAqHC,aAArH,EAAqIC,YAArI;;AAEA,MAAMC,sBAAsB,GAAGC,KAAK,IAAI;AACpCjB,EAAAA,UAAU,GAAGiB,KAAK,CAACjB,UAAnB;AACAA,EAAAA,UAAU,CAACkB,QAAX,GAAsB,CAAtB;AACAjB,EAAAA,QAAQ,GAAGgB,KAAK,CAAChB,QAAjB;AACAC,EAAAA,KAAK,GAAGe,KAAK,CAACf,KAAd;AACAC,EAAAA,CAAC,GAAGc,KAAK,CAACd,CAAV;AACAC,EAAAA,MAAM,GAAGa,KAAK,CAACb,MAAf;AACAC,EAAAA,IAAI,GAAGY,KAAK,CAACZ,IAAb,CAPoC,CASpC;;AAEAG,EAAAA,WAAW,GAAG,CAACR,UAAD,CAAd;AACAM,EAAAA,YAAY,GAAG,EAAf;AAEAI,EAAAA,WAAW,GAAG,CAACT,QAAD,CAAd;AACAM,EAAAA,YAAY,GAAG,EAAf;AAEAE,EAAAA,cAAc,GAAGT,UAAjB;AACAW,EAAAA,cAAc,GAAGV,QAAjB;AACAY,EAAAA,WAAW,GAAG,KAAd;AACAC,EAAAA,aAAa,GAAG,KAAhB;AACAC,EAAAA,YAAY,GAAG,IAAf;AAEAI,EAAAA,oBAAoB,CAACP,KAAD,CAApB;AACAQ,EAAAA,cAAc;AACjB,CAzBD;;AA2BA,MAAMC,2BAA2B,GAAG,MAAM;AACtCF,EAAAA,oBAAoB,CAACP,KAAD,CAApB;AACH,CAFD;;AAIA,MAAMQ,cAAc,GAAG,MAAM;AACzBR,EAAAA,KAAK,GAAGU,qBAAqB,CAACF,cAAD,CAA7B;AACAjB,EAAAA,CAAC,CAACoB,SAAF,CAAY,CAAZ,EAAc,CAAd,EAAgBnB,MAAM,CAACoB,KAAvB,EAA8BpB,MAAM,CAACqB,MAArC;;AAEA,OAAI,IAAIC,CAAC,GAAG,CAAZ,EAAgBA,CAAC,GAAGxB,KAAK,CAACyB,MAA1B,EAAmCD,CAAC,EAApC,EAAwC;AACpCxB,IAAAA,KAAK,CAACwB,CAAD,CAAL,CAASE,IAAT;AACH;;AAED,OAAI,IAAIF,CAAC,GAAG,CAAZ,EAAgBA,CAAC,GAAGlB,WAAW,CAACmB,MAAhC,EAAyCD,CAAC,EAA1C,EAA8C;AAC1ClB,IAAAA,WAAW,CAACkB,CAAD,CAAX,CAAeG,KAAf,GAAuB,aAAvB;AACArB,IAAAA,WAAW,CAACkB,CAAD,CAAX,CAAeE,IAAf;AACH;;AAED,OAAI,IAAIF,CAAC,GAAG,CAAZ,EAAgBA,CAAC,GAAGhB,WAAW,CAACiB,MAAhC,EAAyCD,CAAC,EAA1C,EAA8C;AAC1ChB,IAAAA,WAAW,CAACgB,CAAD,CAAX,CAAeG,KAAf,GAAuB,OAAvB;AACAnB,IAAAA,WAAW,CAACgB,CAAD,CAAX,CAAeE,IAAf;AACH;;AAED,OAAI,IAAIF,CAAC,GAAG,CAAZ,EAAgBA,CAAC,GAAGpB,YAAY,CAACqB,MAAjC,EAA0CD,CAAC,EAA3C,EAA+C;AAC3C,QAAG,CAACZ,aAAJ,EAAkB;AACdR,MAAAA,YAAY,CAACoB,CAAD,CAAZ,CAAgBG,KAAhB,GAAwB,cAAxB;AACH;;AACDvB,IAAAA,YAAY,CAACoB,CAAD,CAAZ,CAAgBE,IAAhB;AACH;;AAED,OAAI,IAAIF,CAAC,GAAG,CAAZ,EAAgBA,CAAC,GAAGnB,YAAY,CAACoB,MAAjC,EAA0CD,CAAC,EAA3C,EAA+C;AAC3C,QAAG,CAACZ,aAAJ,EAAkB;AACdP,MAAAA,YAAY,CAACmB,CAAD,CAAZ,CAAgBG,KAAhB,GAAwB,KAAxB;AACH;;AACDtB,IAAAA,YAAY,CAACmB,CAAD,CAAZ,CAAgBE,IAAhB;AACH,GA9BwB,CAgCzB;AACA;AACA;AACA;AACA;;;AAEA,MAAGlB,WAAW,CAACiB,MAAZ,GAAqB,CAArB,IAA0B,CAACb,aAA9B,EAA4C;AACxCH,IAAAA,cAAc,GAAGD,WAAW,CAACoB,IAAZ,CAAiB,CAACC,CAAD,EAAGC,CAAH,KAASD,CAAC,CAACb,QAAF,GAAac,CAAC,CAACd,QAAzC,EAAmD,CAAnD,CAAjB;AACAX,IAAAA,YAAY,CAAC0B,IAAb,CAAkBtB,cAAlB;AACAD,IAAAA,WAAW,GAAGwB,eAAe,CAACvB,cAAD,EAAkBD,WAAlB,EAAgCH,YAAhC,EAA+CD,YAA/C,CAA7B;AACH;;AAED,MAAGE,WAAW,CAACmB,MAAZ,GAAqB,CAArB,IAA0B,CAACb,aAA9B,EAA4C;AACxCL,IAAAA,cAAc,GAAGD,WAAW,CAACsB,IAAZ,CAAiB,CAACC,CAAD,EAAGC,CAAH,KAASD,CAAC,CAACb,QAAF,GAAac,CAAC,CAACd,QAAzC,EAAmD,CAAnD,CAAjB;AACAZ,IAAAA,YAAY,CAAC2B,IAAb,CAAkBxB,cAAlB;AACAD,IAAAA,WAAW,GAAG0B,eAAe,CAACzB,cAAD,EAAkBD,WAAlB,EAAgCF,YAAhC,EAA+CC,YAA/C,CAA7B;AACH;;AAED,MAAGO,aAAH,EAAiB;AACbd,IAAAA,UAAU,CAAC4B,IAAX;AACA3B,IAAAA,QAAQ,CAAC2B,IAAT;;AACA,QAAGnB,cAAH,EAAkB;AACdA,MAAAA,cAAc,GAAG0B,SAAS,CAAC1B,cAAD,CAA1B;AACH;;AACD,QAAGE,cAAH,EAAkB;AACdA,MAAAA,cAAc,GAAGwB,SAAS,CAACxB,cAAD,CAA1B;AACH;AACJ;;AAED,MAAGE,WAAH,EAAe;AACXM,IAAAA,oBAAoB,CAACP,KAAD,CAApB;AACH;AACJ,CAhED;;AAkEA,MAAMsB,eAAe,GAAG,CAACE,MAAD,EAAUC,SAAV,EAAsBC,UAAtB,EAAmCC,eAAnC,KAAuD;AAC3E,MAAI;AAACC,IAAAA,GAAD;AAAOC,IAAAA,KAAP;AAAeC,IAAAA,MAAf;AAAwBC,IAAAA;AAAxB,MAAgCC,yBAAyB,CAACR,MAAD,EAAUlC,KAAV,CAA7D,CAD2E,CAG3E;;AACA,MAAGuC,KAAK,IAAI,CAACA,KAAK,CAACI,KAAN,CAAY,CAAZ,CAAV,IAA4B,CAACP,UAAU,CAACQ,IAAX,CAAgBC,IAAI,IAAIA,IAAI,CAACC,CAAL,KAAWP,KAAK,CAACO,CAAjB,IAAuBD,IAAI,CAACE,CAAL,KAAWR,KAAK,CAACQ,CAAhE,CAAhC,EAAmG;AAC/F,QAAIC,aAAa,GAAGb,SAAS,CAACS,IAAV,CAAeK,CAAC,IAAIA,CAAC,CAACH,CAAF,KAAQP,KAAK,CAACO,CAAd,IAAoBG,CAAC,CAACF,CAAF,KAAQR,KAAK,CAACQ,CAAtD,CAApB;;AACA,QAAGV,eAAe,CAACO,IAAhB,CAAqBC,IAAI,IAAIA,IAAI,CAACC,CAAL,KAAWP,KAAK,CAACO,CAAjB,IAAuBD,IAAI,CAACE,CAAL,KAAWR,KAAK,CAACQ,CAArE,CAAH,EAA2E;AACvEnC,MAAAA,aAAa,GAAG,IAAhB;AACH;;AACDoC,IAAAA,aAAa,GAAGE,WAAW,CAACF,aAAD,EAAiBd,MAAjB,CAAd,GAAyCC,SAAS,CAACJ,IAAV,CAAeoB,eAAe,CAACZ,KAAD,EAASL,MAAT,CAA9B,CAAtD;AACH,GAV0E,CAY3E;;;AACA,MAAGI,GAAG,IAAI,CAACA,GAAG,CAACK,KAAJ,CAAU,CAAV,CAAR,IAAwB,CAACP,UAAU,CAACQ,IAAX,CAAgBC,IAAI,IAAIA,IAAI,CAACC,CAAL,KAAWR,GAAG,CAACQ,CAAf,IAAoBD,IAAI,CAACE,CAAL,KAAWT,GAAG,CAACS,CAA3D,CAA5B,EAA0F;AACtF,QAAIK,WAAW,GAAGjB,SAAS,CAACS,IAAV,CAAeK,CAAC,IAAIA,CAAC,CAACH,CAAF,KAAQR,GAAG,CAACQ,CAAZ,IAAkBG,CAAC,CAACF,CAAF,KAAQT,GAAG,CAACS,CAAlD,CAAlB;;AACA,QAAGV,eAAe,CAACO,IAAhB,CAAqBC,IAAI,IAAIA,IAAI,CAACC,CAAL,KAAWR,GAAG,CAACQ,CAAf,IAAqBD,IAAI,CAACE,CAAL,KAAWT,GAAG,CAACS,CAAjE,CAAH,EAAuE;AACnEnC,MAAAA,aAAa,GAAG,IAAhB;AACH;;AACDwC,IAAAA,WAAW,GAAGF,WAAW,CAACE,WAAD,EAAelB,MAAf,CAAd,GAAuCC,SAAS,CAACJ,IAAV,CAAeoB,eAAe,CAACb,GAAD,EAAOJ,MAAP,CAA9B,CAAlD;AACH,GAnB0E,CAqB3E;;;AACA,MAAGO,IAAI,IAAI,CAACA,IAAI,CAACE,KAAL,CAAW,CAAX,CAAT,IAA0B,CAACP,UAAU,CAACQ,IAAX,CAAgBC,IAAI,IAAIA,IAAI,CAACC,CAAL,KAAWL,IAAI,CAACK,CAAhB,IAAqBD,IAAI,CAACE,CAAL,KAAWN,IAAI,CAACM,CAA7D,CAA9B,EAA8F;AAC1F,QAAIM,YAAY,GAAGlB,SAAS,CAACS,IAAV,CAAeK,CAAC,IAAIA,CAAC,CAACH,CAAF,KAAQL,IAAI,CAACK,CAAb,IAAmBG,CAAC,CAACF,CAAF,KAAQN,IAAI,CAACM,CAApD,CAAnB;;AACA,QAAGV,eAAe,CAACO,IAAhB,CAAqBC,IAAI,IAAIA,IAAI,CAACC,CAAL,KAAWL,IAAI,CAACK,CAAhB,IAAsBD,IAAI,CAACE,CAAL,KAAWN,IAAI,CAACM,CAAnE,CAAH,EAAyE;AACrEnC,MAAAA,aAAa,GAAG,IAAhB;AACH;;AACDyC,IAAAA,YAAY,GAAGH,WAAW,CAACG,YAAD,EAAgBnB,MAAhB,CAAd,GAAwCC,SAAS,CAACJ,IAAV,CAAeoB,eAAe,CAACV,IAAD,EAAQP,MAAR,CAA9B,CAApD;AACH,GA5B0E,CA8B3E;;;AACA,MAAGM,MAAM,IAAI,CAACA,MAAM,CAACG,KAAP,CAAa,CAAb,CAAX,IAA6B,CAACP,UAAU,CAACQ,IAAX,CAAgBC,IAAI,IAAIA,IAAI,CAACC,CAAL,KAAWN,MAAM,CAACM,CAAlB,IAAuBD,IAAI,CAACE,CAAL,KAAWP,MAAM,CAACO,CAAjE,CAAjC,EAAqG;AACjG,QAAIO,cAAc,GAAGnB,SAAS,CAACS,IAAV,CAAeK,CAAC,IAAIA,CAAC,CAACH,CAAF,KAAQN,MAAM,CAACM,CAAf,IAAqBG,CAAC,CAACF,CAAF,KAAQP,MAAM,CAACO,CAAxD,CAArB;;AACA,QAAGV,eAAe,CAACO,IAAhB,CAAqBC,IAAI,IAAIA,IAAI,CAACC,CAAL,KAAWN,MAAM,CAACM,CAAlB,IAAwBD,IAAI,CAACE,CAAL,KAAWP,MAAM,CAACO,CAAvE,CAAH,EAA6E;AACzEnC,MAAAA,aAAa,GAAG,IAAhB;AACH;;AACD0C,IAAAA,cAAc,GAAGJ,WAAW,CAACI,cAAD,EAAkBpB,MAAlB,CAAd,GAA0CC,SAAS,CAACJ,IAAV,CAAeoB,eAAe,CAACX,MAAD,EAAUN,MAAV,CAA9B,CAAxD;AACH;;AAED,SAAOC,SAAS,CAACoB,MAAV,CAAiBV,IAAI,IAAIA,IAAI,CAACC,CAAL,KAAWZ,MAAM,CAACY,CAAlB,IAAuBD,IAAI,CAACE,CAAL,KAAWb,MAAM,CAACa,CAAzC,GAA6C,KAA7C,GAAqD,IAA9E,CAAP;AACH,CAxCD;;AA0CA,MAAMd,SAAS,GAAIY,IAAD,IAAU;AACxBA,EAAAA,IAAI,CAAClB,KAAL,GAAa,WAAb;;AACA,MAAGpB,cAAc,CAACiD,SAAf,IAA4B/C,cAAc,CAAC+C,SAA9C,EAAwD;AACpDX,IAAAA,IAAI,GAAGA,IAAI,CAACW,SAAZ;AACH,GAFD,MAEK;AACD7C,IAAAA,WAAW,GAAG,IAAd;AACH;;AACD,SAAOkC,IAAP;AACH,CARD;;AAUA,MAAMM,eAAe,GAAG,CAACN,IAAD,EAAQX,MAAR,KAAmB;AACvC,MAAIlB,QAAQ,GAAGyC,aAAa,CAACZ,IAAD,EAAQX,MAAR,CAA5B;AACA,SAAO,IAAIrC,KAAJ,CAAUgD,IAAI,CAACC,CAAf,EAAmBD,IAAI,CAACE,CAAxB,EAA4B9C,CAA5B,EAAgCE,IAAhC,EAAuC,cAAvC,EAAwD+B,MAAxD,EAAiE,IAAjE,EAAwE,IAAxE,EAA+E,IAA/E,EAAsFlB,QAAtF,CAAP;AACH,CAHD;;AAKA,MAAMyC,aAAa,GAAG,CAACZ,IAAD,EAAQX,MAAR,KAAmB;AACrC;AACA,MAAIwB,GAAG,GAAGxB,MAAM,CAACY,CAAjB;AACA,MAAIa,GAAG,GAAGzB,MAAM,CAACa,CAAjB;AAEA,MAAIa,GAAG,GAAGf,IAAI,CAACC,CAAf;AACA,MAAIe,GAAG,GAAGhB,IAAI,CAACE,CAAf;AAED,SAAQ,CAACe,IAAI,CAACC,GAAL,CAASL,GAAG,GAAGE,GAAf,IAAsBE,IAAI,CAACC,GAAL,CAASJ,GAAG,GAAGE,GAAf,CAAvB,IAA8C1D,IAA/C,GAAwD+B,MAAM,CAAClB,QAAtE;AACF,CATD;;AAWA,MAAMkC,WAAW,GAAG,CAACL,IAAD,EAAQX,MAAR,KAAmB;AACnC,MAAGA,MAAM,CAAClB,QAAP,GAAkBb,IAAlB,GAAyB0C,IAAI,CAAC7B,QAAjC,EAA0C;AACtC6B,IAAAA,IAAI,CAAC7B,QAAL,GAAgByC,aAAa,CAACZ,IAAD,EAAQX,MAAR,CAA7B;AACH;;AACD,SAAOW,IAAP;AACH,CALD;;AAOA,MAAMH,yBAAyB,GAAG,CAACG,IAAD,EAAQmB,KAAR,KAAmB;AACjD,MAAI;AAAClB,IAAAA,CAAD;AAAKC,IAAAA;AAAL,MAAUF,IAAd;AACA,MAAIP,GAAG,GAAG0B,KAAK,CAACpB,IAAN,CAAWK,CAAC,IAAIA,CAAC,CAACH,CAAF,KAAQA,CAAR,IAAaG,CAAC,CAACF,CAAF,KAAQA,CAAC,GAAG5C,IAAzC,CAAV;AACA,MAAIoC,KAAK,GAAGyB,KAAK,CAACpB,IAAN,CAAWK,CAAC,IAAIA,CAAC,CAACH,CAAF,KAAQA,CAAC,GAAG3C,IAAZ,IAAoB8C,CAAC,CAACF,CAAF,KAAQA,CAA5C,CAAZ;AACA,MAAIP,MAAM,GAAGwB,KAAK,CAACpB,IAAN,CAAWK,CAAC,IAAIA,CAAC,CAACH,CAAF,KAAQA,CAAR,IAAaG,CAAC,CAACF,CAAF,KAAQA,CAAC,GAAG5C,IAAzC,CAAb;AACA,MAAIsC,IAAI,GAAGuB,KAAK,CAACpB,IAAN,CAAWK,CAAC,IAAIA,CAAC,CAACH,CAAF,KAAQA,CAAC,GAAG3C,IAAZ,IAAoB8C,CAAC,CAACF,CAAF,KAAQA,CAA5C,CAAX;AAEA,SAAO;AAACT,IAAAA,GAAD;AAAOC,IAAAA,KAAP;AAAeC,IAAAA,MAAf;AAAwBC,IAAAA;AAAxB,GAAP;AACH,CARD;;AAUA,SAAQ3B,sBAAR,EAAiCK,2BAAjC","sourcesContent":["import { Block } from '../helper_method'\n\nlet start_node , end_node , nodes , c , canvas , size \n\nlet close_list_1 , close_list_2 , open_list_1 , current_node_1 , open_list_2, current_node_2 , myReq , finish_path , finish_search , current_node \n\nconst bidirectional_dijkstra = props => {\n    start_node = props.start_node\n    start_node.distance = 0\n    end_node = props.end_node \n    nodes = props.nodes\n    c = props.c \n    canvas = props.canvas \n    size = props.size \n\n    // end_node.prev_node = null\n    \n    open_list_1 = [start_node]\n    close_list_1 = []\n\n    open_list_2 = [end_node]\n    close_list_2 = []\n\n    current_node_1 = start_node\n    current_node_2 = end_node \n    finish_path = false \n    finish_search = false \n    current_node = null \n\n    cancelAnimationFrame(myReq)\n    run_solve_maze()\n}\n\nconst stop_bidirectional_dijkstra = () => {\n    cancelAnimationFrame(myReq)\n}\n\nconst run_solve_maze = () => {\n    myReq = requestAnimationFrame(run_solve_maze)\n    c.clearRect(0,0,canvas.width, canvas.height)\n\n    for(let i = 0 ; i < nodes.length ; i ++){\n        nodes[i].draw()\n    }\n\n    for(let i = 0 ; i < open_list_1.length ; i ++){\n        open_list_1[i].color = 'DeepSkyBlue'\n        open_list_1[i].draw()\n    }\n\n    for(let i = 0 ; i < open_list_2.length ; i ++){\n        open_list_2[i].color = 'green'\n        open_list_2[i].draw()\n    }\n\n    for(let i = 0 ; i < close_list_1.length ; i ++){\n        if(!finish_search){\n            close_list_1[i].color = 'MidnightBlue'\n        }\n        close_list_1[i].draw()\n    }\n\n    for(let i = 0 ; i < close_list_2.length ; i ++){\n        if(!finish_search){\n            close_list_2[i].color = 'red'\n        }\n        close_list_2[i].draw()\n    }\n\n    // if(current_node_1.x === current_node_2.x && current_node_1.y === current_node_2.y){\n    //     finish_search = true \n    //     current_node = end_node\n    //     // finish_path = true \n    // }\n\n    if(open_list_2.length > 0 && !finish_search){\n        current_node_2 = open_list_2.sort((a,b) => a.distance - b.distance)[0] \n        close_list_2.push(current_node_2)\n        open_list_2 = find_child_node(current_node_2 , open_list_2 , close_list_2 , close_list_1)\n    }\n\n    if(open_list_1.length > 0 && !finish_search){\n        current_node_1 = open_list_1.sort((a,b) => a.distance - b.distance)[0] \n        close_list_1.push(current_node_1)\n        open_list_1 = find_child_node(current_node_1 , open_list_1 , close_list_1 , close_list_2)\n    }\n\n    if(finish_search){\n        start_node.draw()\n        end_node.draw()\n        if(current_node_1){\n            current_node_1 = find_path(current_node_1) \n        }\n        if(current_node_2){\n            current_node_2 = find_path(current_node_2) \n        }\n    }\n\n    if(finish_path){\n        cancelAnimationFrame(myReq)\n    }\n}\n\nconst find_child_node = (c_node , open_list , close_list , next_close_list) => {\n    let {top , right , bottom , left} = get_top_right_bottom_left(c_node , nodes )\n\n    // Right (x + size , y)\n    if(right && !right.walls[3] && !close_list.find(node => node.x === right.x  && node.y === right.y)){\n        let right_in_open = open_list.find(n => n.x === right.x  && n.y === right.y)\n        if(next_close_list.find(node => node.x === right.x  && node.y === right.y)){\n            finish_search = true \n        }\n        right_in_open ? update_node(right_in_open , c_node) : open_list.push(create_new_node(right , c_node))\n    }\n\n    // top (x , y - size)\n    if(top && !top.walls[2] && !close_list.find(node => node.x === top.x && node.y === top.y)){\n        let top_in_open = open_list.find(n => n.x === top.x  && n.y === top.y)\n        if(next_close_list.find(node => node.x === top.x  && node.y === top.y)){\n            finish_search = true \n        }\n        top_in_open ? update_node(top_in_open , c_node) : open_list.push(create_new_node(top , c_node))\n    }\n\n    // left (x - size , y )\n    if(left && !left.walls[1] && !close_list.find(node => node.x === left.x && node.y === left.y)){\n        let left_in_open = open_list.find(n => n.x === left.x  && n.y === left.y)\n        if(next_close_list.find(node => node.x === left.x  && node.y === left.y)){\n            finish_search = true \n        }\n        left_in_open ? update_node(left_in_open , c_node) : open_list.push(create_new_node(left , c_node))\n    }\n\n    // bottom (x , y + size)\n    if(bottom && !bottom.walls[0] &&!close_list.find(node => node.x === bottom.x && node.y === bottom.y)){\n        let bottom_in_open = open_list.find(n => n.x === bottom.x  && n.y === bottom.y)\n        if(next_close_list.find(node => node.x === bottom.x  && node.y === bottom.y)){\n            finish_search = true \n        }\n        bottom_in_open ? update_node(bottom_in_open , c_node) : open_list.push(create_new_node(bottom , c_node))\n    }\n\n    return open_list.filter(node => node.x === c_node.x && node.y === c_node.y ? false : true )\n}\n\nconst find_path = (node) => {\n    node.color = \"LimeGreen\"\n    if(current_node_1.prev_node || current_node_2.prev_node){\n        node = node.prev_node\n    }else{\n        finish_path = true \n    }\n    return node \n}\n\nconst create_new_node = (node , c_node) => {\n    let distance = find_distance(node , c_node)\n    return new Block(node.x , node.y , c , size , 'MidnightBlue' , c_node , null , null , null , distance)\n}\n\nconst find_distance = (node , c_node) => {\n    // find distance from current node to next node \n    let x_1 = c_node.x \n    let y_1 = c_node.y\n\n    let x_2 = node.x \n    let y_2 = node.y\n\n   return ((Math.abs(x_1 - x_2) + Math.abs(y_1 - y_2)) * size ) + c_node.distance\n}\n\nconst update_node = (node , c_node) => {\n    if(c_node.distance + size < node.distance){\n        node.distance = find_distance(node , c_node)\n    }\n    return node\n}\n\nconst get_top_right_bottom_left = (node , array ) => {\n    let {x , y} = node\n    let top = array.find(n => n.x === x && n.y === y - size)\n    let right = array.find(n => n.x === x + size && n.y === y)\n    let bottom = array.find(n => n.x === x && n.y === y + size)\n    let left = array.find(n => n.x === x - size && n.y === y)\n\n    return {top , right , bottom , left }\n}\n\nexport {bidirectional_dijkstra , stop_bidirectional_dijkstra}"]},"metadata":{},"sourceType":"module"}