{"ast":null,"code":"import { Block } from '../helper_method';\nimport { get_top_right_bottom_left } from './helper_method/algorithms_helper_method';\nlet start_node, end_node, nodes, c, canvas, size;\nlet open_list, close_list, current_node, myReq, finish_path;\n\nconst greedy_best_first_search = props => {\n  start_node = props.start_node;\n  end_node = props.end_node;\n  nodes = props.nodes;\n  c = props.c;\n  canvas = props.canvas;\n  size = props.size;\n  end_node.prev_node = null;\n  open_list = [start_node];\n  close_list = [];\n  current_node = null;\n  finish_path = false;\n  cancelAnimationFrame(myReq);\n  run_solve_maze();\n};\n\nconst stop_greedy_best_first_search = () => {\n  cancelAnimationFrame(myReq);\n};\n\nconst run_solve_maze = () => {\n  myReq = requestAnimationFrame(run_solve_maze);\n  c.clearRect(0, 0, canvas.width, canvas.height);\n\n  for (let i = 0; i < nodes.length; i++) {\n    nodes[i].draw();\n  }\n\n  for (let i = 0; i < close_list.length; i++) {\n    if (!end_node.prev_node) {\n      close_list[i].color = 'MidnightBlue';\n    }\n\n    close_list[i].draw();\n  }\n\n  for (let i = 0; i < open_list.length; i++) {\n    open_list[i].color = 'DeepSkyBlue';\n    open_list[i].draw();\n  }\n\n  if (current_node && end_node.x === current_node.x && end_node.y === current_node.y) {\n    end_node.prev_node = current_node.prev_node;\n  }\n\n  if (open_list.length > 0 && !end_node.prev_node) {\n    // h is the distance between current node to end node \n    current_node = open_list.sort((a, b) => a.h - b.h)[0];\n    close_list.push(current_node);\n    find_child_node();\n  }\n\n  if (end_node.prev_node) {\n    start_node.draw();\n    end_node.draw();\n    find_path();\n  }\n\n  if (finish_path) {\n    cancelAnimationFrame(myReq);\n  }\n};\n\nconst find_child_node = () => {\n  let {\n    top,\n    right,\n    bottom,\n    left\n  } = get_top_right_bottom_left(current_node, nodes, size); // right (x + size , y)\n\n  add_node(right, 3); // if(right && !right.walls[3] && !close_list.find(node => node.x === right.x  && node.y === right.y)){\n  //     let right_in_open = open_list.find(n => n.x === right.x  && n.y === right.y)\n  //     if(!right_in_open){\n  //         let right_node = set_node(right)\n  //         open_list.push(right_node)\n  //     }\n  // }\n  // top (x , y - size)\n\n  add_node(top, 2); // if(top && !top.walls[2] && !close_list.find(node => node.x === top.x && node.y === top.y)){\n  //     let top_in_open = open_list.find(n => n.x === top.x  && n.y === top.y)\n  //     if(!top_in_open){\n  //         let top_node = set_node(top)\n  //         open_list.push(top_node)\n  //     }\n  // }\n  // left (x - size , y )\n\n  add_node(left, 1); // if(left && !left.walls[1] && !close_list.find(node => node.x === left.x && node.y === left.y)){\n  //     let left_in_open = open_list.find(n => n.x === left.x  && n.y === left.y)\n  //     if(!left_in_open){\n  //         let left_node = set_node(left)\n  //         open_list.push(left_node)\n  //     }\n  // }\n  // bottom (x , y + size)\n\n  add_node(bottom, 0); // if(bottom && !bottom.walls[0] &&!close_list.find(node => node.x === bottom.x && node.y === bottom.y)){\n  //     let bottom_in_open = open_list.find(n => n.x === bottom.x  && n.y === bottom.y)\n  //     if(!bottom_in_open){\n  //         let bottom_node = set_node(bottom)\n  //         open_list.push(bottom_node)\n  //     }\n  // }\n\n  open_list = open_list.filter(node => node.x === current_node.x && node.y === current_node.y ? false : true);\n};\n\nconst add_node = (neighbor_node, wall_num) => {\n  if (neighbor_node && !neighbor_node.walls[wall_num] && !close_list.find(node => node.x === neighbor_node.x && node.y === neighbor_node.y)) {\n    let {\n      x,\n      y\n    } = neighbor_node;\n    let node_in_open = open_list.find(n => n.x === x && n.y === y);\n    if (!node_in_open) open_list.push(set_node(neighbor_node));\n  }\n};\n\nconst find_path = () => {\n  current_node.color = \"LimeGreen\";\n\n  if (current_node.x === start_node.x && current_node.y === start_node.y) {\n    finish_path = true;\n    return;\n  }\n\n  current_node = current_node.prev_node;\n  return;\n};\n\nconst set_node = node => {\n  let color = \"MidnightBlue\";\n  let x_1 = node.x;\n  let y_1 = node.y;\n  let x_2 = end_node.x;\n  let y_2 = end_node.y;\n  let h = (Math.abs(x_1 - x_2) + Math.abs(y_1 - y_2)) * size;\n  let new_node = new Block(x_1, y_1, c, size, color, current_node, null, h);\n  return new_node;\n};\n\nexport { greedy_best_first_search, stop_greedy_best_first_search };","map":{"version":3,"sources":["/Users/vienpham/Desktop/Algorithms_simulation/algorithms/src/Algorithms/solve_maze/greedy_best_first_search.js"],"names":["Block","get_top_right_bottom_left","start_node","end_node","nodes","c","canvas","size","open_list","close_list","current_node","myReq","finish_path","greedy_best_first_search","props","prev_node","cancelAnimationFrame","run_solve_maze","stop_greedy_best_first_search","requestAnimationFrame","clearRect","width","height","i","length","draw","color","x","y","sort","a","b","h","push","find_child_node","find_path","top","right","bottom","left","add_node","filter","node","neighbor_node","wall_num","walls","find","node_in_open","n","set_node","x_1","y_1","x_2","y_2","Math","abs","new_node"],"mappings":"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","sourcesContent":["import { Block } from '../helper_method'\nimport {get_top_right_bottom_left} from './helper_method/algorithms_helper_method'\n\nlet start_node , end_node , nodes , c , canvas , size \n\nlet open_list , close_list , current_node , myReq , finish_path\n\nconst greedy_best_first_search = props => {\n    start_node = props.start_node\n    end_node = props.end_node \n    nodes = props.nodes\n    c = props.c \n    canvas = props.canvas \n    size = props.size \n\n    end_node.prev_node = null\n    \n    open_list = [start_node]\n    close_list = []\n    current_node = null \n    finish_path = false \n\n    cancelAnimationFrame(myReq)\n    run_solve_maze()\n}\n\nconst stop_greedy_best_first_search = () => {\n    cancelAnimationFrame(myReq)\n}\n\nconst run_solve_maze = () => {\n    myReq = requestAnimationFrame(run_solve_maze)\n    c.clearRect(0,0,canvas.width, canvas.height)\n\n    for(let i = 0 ; i < nodes.length ; i ++){\n        nodes[i].draw()\n    }\n\n    for(let i = 0 ; i < close_list.length ; i ++){\n        if(!end_node.prev_node){\n            close_list[i].color = 'MidnightBlue'\n        }\n        close_list[i].draw()\n    }\n\n    for(let i = 0 ; i < open_list.length ; i ++){\n        open_list[i].color = 'DeepSkyBlue'\n        open_list[i].draw()\n    }\n\n    if(current_node && end_node.x === current_node.x && end_node.y === current_node.y){\n        end_node.prev_node = current_node.prev_node\n    }\n\n    if(open_list.length > 0 && !end_node.prev_node){\n        // h is the distance between current node to end node \n        current_node = open_list.sort((a,b) => a.h - b.h)[0] \n        close_list.push(current_node)\n        find_child_node()\n    }\n\n    if(end_node.prev_node){\n        start_node.draw()\n        end_node.draw()\n        find_path() \n    }\n    if(finish_path){\n        cancelAnimationFrame(myReq)\n    }\n}\n\nconst find_child_node = () => {\n\n    let {top , right , bottom , left} = get_top_right_bottom_left(current_node , nodes , size)\n\n    // right (x + size , y)\n    add_node(right , 3)\n    // if(right && !right.walls[3] && !close_list.find(node => node.x === right.x  && node.y === right.y)){\n    //     let right_in_open = open_list.find(n => n.x === right.x  && n.y === right.y)\n    //     if(!right_in_open){\n    //         let right_node = set_node(right)\n    //         open_list.push(right_node)\n    //     }\n    // }\n\n    // top (x , y - size)\n    add_node(top , 2)\n    // if(top && !top.walls[2] && !close_list.find(node => node.x === top.x && node.y === top.y)){\n    //     let top_in_open = open_list.find(n => n.x === top.x  && n.y === top.y)\n    //     if(!top_in_open){\n    //         let top_node = set_node(top)\n    //         open_list.push(top_node)\n    //     }\n    // }\n\n    // left (x - size , y )\n    add_node(left , 1)\n    // if(left && !left.walls[1] && !close_list.find(node => node.x === left.x && node.y === left.y)){\n    //     let left_in_open = open_list.find(n => n.x === left.x  && n.y === left.y)\n    //     if(!left_in_open){\n    //         let left_node = set_node(left)\n    //         open_list.push(left_node)\n    //     }\n    // }\n\n    // bottom (x , y + size)\n    add_node(bottom , 0)\n    // if(bottom && !bottom.walls[0] &&!close_list.find(node => node.x === bottom.x && node.y === bottom.y)){\n    //     let bottom_in_open = open_list.find(n => n.x === bottom.x  && n.y === bottom.y)\n    //     if(!bottom_in_open){\n    //         let bottom_node = set_node(bottom)\n    //         open_list.push(bottom_node)\n    //     }\n    // }\n\n    open_list = open_list.filter(node => node.x === current_node.x && node.y === current_node.y ? false : true )\n}\n\nconst add_node = (neighbor_node , wall_num) => {\n    if(\n        neighbor_node \n        && !neighbor_node.walls[wall_num] \n        &&!close_list.find(node => node.x === neighbor_node.x && node.y === neighbor_node.y)\n    ){\n        let {x , y} = neighbor_node\n        let node_in_open = open_list.find(n => n.x === x  && n.y === y)\n        if(!node_in_open) open_list.push(set_node(neighbor_node))\n    }\n}\n\nconst find_path = () => {\n    current_node.color = \"LimeGreen\"\n    if(current_node.x === start_node.x && current_node.y === start_node.y){\n        finish_path = true\n        return\n    }\n    current_node = current_node.prev_node\n    return \n}\n\nconst set_node = (node) => {\n    let color = \"MidnightBlue\"\n    let x_1 = node.x \n    let y_1 = node.y \n    let x_2 = end_node.x \n    let y_2 = end_node.y    \n    let h = (Math.abs(x_1 - x_2) + Math.abs(y_1 - y_2)) * size\n    let new_node = new Block(x_1 , y_1 , c , size , color , current_node , null , h )\n    return new_node \n}\n\nexport {greedy_best_first_search , stop_greedy_best_first_search}"]},"metadata":{},"sourceType":"module"}