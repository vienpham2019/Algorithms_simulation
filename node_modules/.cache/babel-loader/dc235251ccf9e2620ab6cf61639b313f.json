{"ast":null,"code":"var delay,speed,size,cols,rows,nodes;var recursive_dividion_maze=function recursive_dividion_maze(props){delay=props.delay;speed=props.speed;size=props.size;cols=props.cols;rows=props.rows;nodes=props.nodes;return draw_maze(nodes,cols,rows,0,0,delay,speed,size);};var draw_maze=function draw_maze(nodes_array,x_max,y_max,x_min,y_min){if(x_max-x_min<1||y_max-y_min<1)return;var random_x=getRandom(x_min,x_max);var random_y=getRandom(y_min,y_max);var x_or_y=getRandom(-20,20);delay++;setTimeout(function(){for(var i=0;i<nodes_array.length;i++){if(x_or_y>0){// x\nif(nodes_array[i].x===random_x*size+size/2&&nodes_array[i].y<=y_max*size+size/2&&nodes_array[i].y>=y_min*size+size/2&&nodes_array[i].x!==(cols-1)*size+size/2){if(nodes_array[i].y!==random_y*size+size/2){(function(){nodes_array[i].walls[1]=true;var _nodes_array$i=nodes_array[i],x=_nodes_array$i.x,y=_nodes_array$i.y;var neightbor_node=nodes_array.find(function(node){return node.x===x+size&&node.y===y;});if(neightbor_node){neightbor_node.walls[3]=true;}})();}}}else{if(nodes_array[i].y===random_y*size+size/2&&nodes_array[i].x<=x_max*size+size/2&&nodes_array[i].x>=x_min*size+size/2){if(nodes_array[i].x!==random_x*size+size/2){(function(){nodes_array[i].walls[2]=true;var _nodes_array$i2=nodes_array[i],x=_nodes_array$i2.x,y=_nodes_array$i2.y;var neightbor_node=nodes_array.find(function(node){return node.x===x&&node.y===y+size;});if(neightbor_node){neightbor_node.walls[0]=true;}})();}}}nodes_array[i].draw();}},delay*speed);if(x_or_y>0){draw_maze(nodes_array,random_x,y_max,x_min,y_min);// right \ndraw_maze(nodes_array,x_max,y_max,random_x+1,y_min);// left \n}else{draw_maze(nodes_array,x_max,random_y,x_min,y_min);// top \ndraw_maze(nodes_array,x_max,y_max,x_min,random_y+1);// bottom\n}return delay;};var getRandom=function getRandom(min,max){return Math.floor(Math.random()*(max-min)+min);};export{recursive_dividion_maze};","map":{"version":3,"sources":["/Users/vienpham/Desktop/Algorithms_simulation/algorithms/src/Algorithms/draw_maze/recursive_division_maze_generation.js"],"names":["delay","speed","size","cols","rows","nodes","recursive_dividion_maze","props","draw_maze","nodes_array","x_max","y_max","x_min","y_min","random_x","getRandom","random_y","x_or_y","setTimeout","i","length","x","y","walls","neightbor_node","find","node","draw","min","max","Math","floor","random"],"mappings":"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","sourcesContent":["let delay , speed , size , cols , rows , nodes\n\nconst recursive_dividion_maze = (props) => {\n    delay = props.delay\n    speed = props.speed \n    size = props.size \n    cols = props.cols \n    rows = props.rows\n    nodes = props.nodes\n\n    return draw_maze(nodes , cols , rows , 0, 0 , delay , speed , size)\n}\n\nconst draw_maze = (nodes_array , x_max, y_max, x_min , y_min) => {\n\n    if(x_max - x_min < 1 || y_max - y_min < 1) return\n  \n    let random_x = getRandom(x_min,x_max)\n    let random_y = getRandom(y_min,y_max)\n    let x_or_y = getRandom(-20, 20) \n  \n    delay ++\n  \n    setTimeout(() => {\n      for(let i = 0; i < nodes_array.length; i ++){\n          if(x_or_y > 0) { // x\n              if (\n                  nodes_array[i].x === random_x * size + (size / 2) \n                  && nodes_array[i].y <= y_max * size + (size / 2)\n                  && nodes_array[i].y >= y_min * size + (size / 2)\n                  && nodes_array[i].x !== (cols - 1) * size + (size / 2)\n                  ){\n                  if (nodes_array[i].y !== random_y * size + (size / 2)){\n                      nodes_array[i].walls[1] = true\n                      let {x , y} = nodes_array[i]\n                      let neightbor_node = nodes_array.find(node => node.x === (x + size) && node.y === y) \n                      if(neightbor_node){\n                          neightbor_node.walls[3] = true\n                      } \n                  }\n              }\n          }else{\n              if(\n                  nodes_array[i].y === random_y * size + (size / 2)\n                  && nodes_array[i].x <= x_max * size + (size / 2)\n                  && nodes_array[i].x >= x_min * size + (size / 2)\n                  ){\n                  if(nodes_array[i].x !== random_x * size + (size / 2)){\n                      nodes_array[i].walls[2] = true\n                      let {x , y} = nodes_array[i]\n                      let neightbor_node = nodes_array.find(node => node.x === x && node.y === (y + size)) \n                      if(neightbor_node){\n                        neightbor_node.walls[0] = true\n                      } \n                  }\n              }\n          }\n            nodes_array[i].draw()\n        }\n    }, delay * speed)\n  \n    if(x_or_y > 0){ \n      draw_maze(nodes_array, random_x, y_max, x_min, y_min) // right \n      draw_maze(nodes_array, x_max, y_max, random_x + 1, y_min) // left \n    }else{\n      draw_maze(nodes_array, x_max, random_y, x_min, y_min) // top \n      draw_maze(nodes_array, x_max, y_max, x_min , random_y + 1) // bottom\n    }\n  \n    return delay \n}\n\nconst getRandom = (min,max) => {\n    return Math.floor(Math.random() * (max - min) + min)\n}\n\nexport {recursive_dividion_maze}"]},"metadata":{},"sourceType":"module"}