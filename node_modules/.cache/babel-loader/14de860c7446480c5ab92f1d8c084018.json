{"ast":null,"code":"import { Block } from '../helper_method';\nlet c, canvas, size, visited_nodes, nodes, quere, current_node, start_node, end_node, finish_path, speed, frame_per_second, myReq;\n\nconst breadth_first_search = props => {\n  c = props.c;\n  canvas = props.canvas;\n  size = props.size;\n  visited_nodes = [];\n  nodes = props.nodes;\n  speed = props.speed;\n  frame_per_second = props.frame_per_second;\n  quere = [];\n  finish_path = false;\n  current_node = null;\n  start_node = props.start_node;\n  end_node = props.end_node;\n  quere.push(start_node); // clearInterval(myReq)\n\n  cancelAnimationFrame(myReq);\n  run_solve_maze();\n};\n\nconst run_solve_maze = () => {\n  // myReq = setInterval(() => {\n  //     run_solve_maze()\n  // }, frame_per_second / speed)\n  myReq = requestAnimationFrame(run_solve_maze);\n  c.clearRect(0, 0, canvas.width, canvas.height);\n\n  for (let i = 0; i < nodes.length; i++) {\n    nodes[i].draw();\n  }\n\n  for (let i = 0; i < visited_nodes.length; i++) {\n    visited_nodes[i].draw();\n  }\n\n  start_node.draw();\n  end_node.draw();\n\n  if (end_node.prev_node) {\n    find_path();\n  }\n\n  if (finish_path) {\n    // clearInterval(myReq)\n    cancelAnimationFrame(myReq);\n  }\n\n  if (!end_node.prev_node && !finish_path) {\n    solve_maze();\n  }\n};\n\nconst solve_maze = () => {\n  let quere_nodes = [...quere];\n  quere.shift(); // visited_nodes_for_path.push(current_node)\n\n  if (end_node.prev_node) {\n    return;\n  }\n\n  for (let i = 0; i < quere_nodes.length; i++) {\n    check_neighbor_node(quere_nodes[i]);\n  }\n};\n\nconst check_neighbor_node = node => {\n  let x = node.x;\n  let y = node.y;\n  let color = \"MidnightBlue\";\n  let current_find_node = nodes.find(c_n => c_n.x === node.x && c_n.y === node.y); // top \n\n  let top = nodes.find(n => n.x === x && n.y === y - size);\n\n  if (top && !current_find_node.walls[0] && !visited_nodes.find(n => n.x === top.x && n.y === top.y)) {\n    let top_x = top.x;\n    let top_y = top.y;\n\n    if (top_x === end_node.x && top_y === end_node.y) {\n      end_node.prev_node = node;\n      current_node = node;\n      return;\n    } else {\n      let top_block = new Block(top_x, top_y, c, size, color, node);\n      quere.push(top_block);\n      visited_nodes.push(top_block);\n    }\n  } // right\n\n\n  let right = nodes.find(n => n.x === x + size && n.y === y);\n\n  if (right && !current_find_node.walls[1] && !visited_nodes.find(n => n.x === right.x && n.y === right.y)) {\n    let right_x = right.x;\n    let right_y = right.y;\n\n    if (right_x === end_node.x && right_y === end_node.y) {\n      end_node.prev_node = node;\n      current_node = node;\n      return;\n    } else {\n      let right_block = new Block(right_x, right_y, c, size, color, node);\n      quere.push(right_block);\n      visited_nodes.push(right_block);\n    }\n  } // bottom\n\n\n  let bottom = nodes.find(n => n.x === x && n.y === y + size);\n\n  if (bottom && !current_find_node.walls[2] && !visited_nodes.find(n => n.x === bottom.x && n.y === bottom.y)) {\n    let bottom_x = bottom.x;\n    let bottom_y = bottom.y;\n\n    if (bottom_x === end_node.x && bottom_y === end_node.y) {\n      end_node.prev_node = node;\n      current_node = node;\n      return;\n    } else {\n      let bottom_block = new Block(bottom_x, bottom_y, c, size, color, node);\n      quere.push(bottom_block);\n      visited_nodes.push(bottom_block);\n    }\n  } // left \n\n\n  let left = nodes.find(n => n.x === x - size && n.y === y);\n\n  if (left && !current_find_node.walls[3] && !visited_nodes.find(n => n.x === left.x && n.y === left.y)) {\n    let left_x = left.x;\n    let left_y = left.y;\n\n    if (left_x === end_node.x && left_y === end_node.y) {\n      end_node.prev_node = node;\n      current_node = node;\n      return;\n    } else {\n      let left_block = new Block(left_x, left_y, c, size, color, node);\n      quere.push(left_block);\n      visited_nodes.push(left_block);\n    }\n  }\n};\n\nconst find_path = () => {\n  current_node.color = \"green\";\n\n  if (current_node.x === start_node.x && current_node.y === start_node.y) {\n    finish_path = true;\n    return;\n  }\n\n  current_node = current_node.prev_node;\n};\n\nexport { breadth_first_search };","map":{"version":3,"sources":["/Users/vienpham/Desktop/Algorithms_simulation/algorithms/src/Algorithms/solve_maze/breadth_first_search.js"],"names":["Block","c","canvas","size","visited_nodes","nodes","quere","current_node","start_node","end_node","finish_path","speed","frame_per_second","myReq","breadth_first_search","props","push","cancelAnimationFrame","run_solve_maze","requestAnimationFrame","clearRect","width","height","i","length","draw","prev_node","find_path","solve_maze","quere_nodes","shift","check_neighbor_node","node","x","y","color","current_find_node","find","c_n","top","n","walls","top_x","top_y","top_block","right","right_x","right_y","right_block","bottom","bottom_x","bottom_y","bottom_block","left","left_x","left_y","left_block"],"mappings":"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","sourcesContent":["import {Block} from '../helper_method'\nlet \n    c , \n    canvas , \n    size , \n    visited_nodes , \n    nodes , \n    quere , \n    current_node , \n    start_node , \n    end_node , \n    finish_path , \n    speed, \n    frame_per_second, \n    myReq\n\nconst breadth_first_search = (props) => {\n    c = props.c\n    canvas = props.canvas \n    size = props.size \n    visited_nodes = []\n    nodes = props.nodes \n    speed = props.speed\n    frame_per_second = props.frame_per_second\n\n    quere = []\n    finish_path = false \n    current_node = null  \n    start_node = props.start_node\n    end_node = props.end_node\n\n    quere.push(start_node)\n    // clearInterval(myReq)\n    cancelAnimationFrame(myReq)\n    run_solve_maze()\n}\n\nconst run_solve_maze = () => {\n    // myReq = setInterval(() => {\n    //     run_solve_maze()\n    // }, frame_per_second / speed)\n    myReq = requestAnimationFrame(run_solve_maze)\n    c.clearRect(0,0,canvas.width, canvas.height)\n\n    for(let i = 0; i < nodes.length; i ++){\n        nodes[i].draw()\n    }\n\n    for(let i = 0; i < visited_nodes.length; i ++){\n        visited_nodes[i].draw()\n    }\n\n    start_node.draw()\n    end_node.draw()\n    if(end_node.prev_node){\n        find_path()\n    }\n    if(finish_path){\n        // clearInterval(myReq)\n        cancelAnimationFrame(myReq)\n    }\n    if(!end_node.prev_node && !finish_path){\n        solve_maze()\n    }\n}\n  \nconst solve_maze = () => {\n    let quere_nodes = [...quere]\n    quere.shift()\n    // visited_nodes_for_path.push(current_node)\n    if(end_node.prev_node){\n        return\n    }\n    for(let i = 0; i < quere_nodes.length ; i ++){\n        check_neighbor_node(quere_nodes[i])\n    }\n}\n  \nconst check_neighbor_node = (node) => {\n    let x = node.x\n    let y = node.y\n    let color = \"MidnightBlue\"\n    let current_find_node = nodes.find(c_n => c_n.x === node.x && c_n.y === node.y )\n    // top \n    let top = nodes.find(n => n.x === x && n.y === y - size)\n    if(top && !current_find_node.walls[0] && !visited_nodes.find(n => n.x === top.x && n.y === top.y)){\n        let top_x = top.x\n        let top_y = top.y\n        if(top_x === end_node.x && top_y === end_node.y){\n            end_node.prev_node = node \n            current_node = node \n            return \n        }else{\n            let top_block = new Block(top_x, top_y , c , size , color, node)\n            quere.push(top_block)\n            visited_nodes.push(top_block)\n        }\n    }\n\n    // right\n    let right = nodes.find(n => n.x === x + size && n.y === y )\n    if(right && !current_find_node.walls[1] && !visited_nodes.find(n => n.x === right.x  && n.y === right.y)){\n        let right_x = right.x \n        let right_y = right.y \n        if(right_x === end_node.x && right_y === end_node.y){\n            end_node.prev_node = node \n            current_node = node \n            return \n        }else{\n            let right_block = new Block(right_x, right_y, c , size , color ,node)\n            quere.push(right_block)\n            visited_nodes.push(right_block)\n        }\n    }\n\n    // bottom\n    let bottom = nodes.find(n => n.x === x && n.y === y + size ) \n    if(bottom && !current_find_node.walls[2] && !visited_nodes.find(n => n.x === bottom.x  && n.y === bottom.y )){\n        let bottom_x = bottom.x \n        let bottom_y = bottom.y \n        if(bottom_x === end_node.x && bottom_y === end_node.y){\n            end_node.prev_node = node \n            current_node = node \n            return \n        }else{\n            let bottom_block = new Block(bottom_x, bottom_y, c , size ,color ,node)\n            quere.push(bottom_block)\n            visited_nodes.push(bottom_block)\n        }\n    }\n\n    // left \n    let left = nodes.find(n => n.x === x - size && n.y === y)\n    if(left && !current_find_node.walls[3] && !visited_nodes.find(n => n.x === left.x && n.y === left.y)){\n        let left_x = left.x \n        let left_y = left.y \n        if(left_x === end_node.x && left_y === end_node.y){\n            end_node.prev_node = node \n            current_node = node \n            return \n        }else{\n            let left_block = new Block(left_x,left_y, c, size , color , node)\n            quere.push(left_block)\n            visited_nodes.push(left_block)\n        }\n    }\n}\n  \nconst find_path = () => {\n    current_node.color = \"green\"\n    if(current_node.x === start_node.x && current_node.y === start_node.y){\n        finish_path = true\n        return\n    }\n    current_node = current_node.prev_node\n}\n\nexport { breadth_first_search }\n\n"]},"metadata":{},"sourceType":"module"}