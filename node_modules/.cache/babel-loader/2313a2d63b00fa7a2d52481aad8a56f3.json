{"ast":null,"code":"let size, nodes, cols, rows, canvas, c, frame_per_second, speed;\nlet neighbors_node, visited_neighbors_node, current_neighbor_node, myReqDraw;\n\nconst prims_maze = props => {\n  size = props.size;\n  nodes = props.nodes;\n  cols = props.cols;\n  rows = props.rows;\n  canvas = props.canvas;\n  c = props.c;\n  frame_per_second = props.frame_per_second;\n  speed = props.speed;\n  neighbors_node = [];\n  visited_neighbors_node = [];\n  current_neighbor_node = null; // cancelAnimationFrame(myReqDraw)\n\n  clearInterval(myReqDraw);\n  setup_prims_maze(nodes, cols, rows);\n};\n\nconst setup_prims_maze = (nodes_array, w, h) => {\n  let midd_x = Math.floor(w / 2) * size + size / 2;\n  let midd_y = Math.floor(h / 2) * size + size / 2;\n  let center_node = nodes_array.find(node => node.x === midd_x && node.y === midd_y);\n  neighbors_node.push(center_node);\n  visited_neighbors_node.push(center_node);\n  current_neighbor_node = center_node;\n  draw_prims_maze();\n};\n\nconst draw_prims_maze = () => {\n  myReqDraw = setTimeout(() => {\n    draw_prims_maze();\n  }, frame_per_second / speed);\n  c.clearRect(0, 0, canvas.width, canvas.height);\n\n  for (let i = 0; i < nodes.length; i++) {\n    nodes[i].draw();\n  }\n\n  if (neighbors_node.length === 0) {\n    // cancelAnimationFrame(myReqDraw)\n    clearInterval(myReqDraw);\n  }\n\n  add_neighbor_node();\n};\n\nconst add_neighbor_node = () => {\n  let {\n    x,\n    y\n  } = current_neighbor_node;\n  let {\n    top,\n    right,\n    bottom,\n    left\n  } = get_top_right_bottom_left(current_neighbor_node, nodes);\n\n  if (top && !visited_neighbors_node.find(node => node.x === x && node.y === y - size) && !neighbors_node.find(node => node.x === x && node.y === y - size)) {\n    neighbors_node.push(top);\n    top.prev_node = current_neighbor_node;\n  }\n\n  if (right && !visited_neighbors_node.find(node => node.x === x + size && node.y === y) && !neighbors_node.find(node => node.x === x + size && node.y === y)) {\n    neighbors_node.push(right);\n    right.prev_node = current_neighbor_node;\n  }\n\n  if (bottom && !visited_neighbors_node.find(node => node.x === x && node.y === y + size) && !neighbors_node.find(node => node.x === x && node.y === y + size)) {\n    neighbors_node.push(bottom);\n    bottom.prev_node = current_neighbor_node;\n  }\n\n  if (left && !visited_neighbors_node.find(node => node.x === x - size && node.y === y) && !neighbors_node.find(node => node.x === x - size && node.y === y)) {\n    neighbors_node.push(left);\n    left.prev_node = current_neighbor_node;\n  }\n\n  neighbors_node = neighbors_node.filter(node => node.x === x && node.y === y ? false : true);\n  link_node_with_random_neighbor();\n};\n\nconst link_node_with_random_neighbor = () => {\n  if (neighbors_node.length === 0) return;\n  let random_num = getRandom(0, neighbors_node.length);\n  let random_neighbor = neighbors_node[random_num];\n  let {\n    top,\n    right,\n    bottom,\n    left\n  } = get_top_right_bottom_left(random_neighbor, visited_neighbors_node);\n\n  if (top && top.x === random_neighbor.prev_node.x && top.y === random_neighbor.prev_node.y) {\n    random_neighbor.walls[0] = false;\n    top.walls[2] = false;\n  }\n\n  if (right && right.x === random_neighbor.prev_node.x && right.y === random_neighbor.prev_node.y) {\n    random_neighbor.walls[1] = false;\n    right.walls[3] = false;\n  }\n\n  if (bottom && bottom.x === random_neighbor.prev_node.x && bottom.y === random_neighbor.prev_node.y) {\n    random_neighbor.walls[2] = false;\n    bottom.walls[0] = false;\n  }\n\n  if (left && left.x === random_neighbor.prev_node.x && left.y === random_neighbor.prev_node.y) {\n    random_neighbor.walls[3] = false;\n    left.walls[1] = false;\n  }\n\n  current_neighbor_node = random_neighbor;\n  visited_neighbors_node.push(random_neighbor);\n};\n\nconst get_top_right_bottom_left = (node, array) => {\n  let {\n    x,\n    y\n  } = node;\n  let top = array.find(n => n.x === x && n.y === y - size);\n  let right = array.find(n => n.x === x + size && n.y === y);\n  let bottom = array.find(n => n.x === x && n.y === y + size);\n  let left = array.find(n => n.x === x - size && n.y === y);\n  return {\n    top,\n    right,\n    bottom,\n    left\n  };\n};\n\nconst getRandom = (min, max) => {\n  return Math.floor(Math.random() * (max - min) + min);\n};\n\nexport { prims_maze };","map":{"version":3,"sources":["/Users/vienpham/Desktop/Algorithms_simulation/algorithms/src/Algorithms/draw_maze/prims_maze_generation.js"],"names":["size","nodes","cols","rows","canvas","c","frame_per_second","speed","neighbors_node","visited_neighbors_node","current_neighbor_node","myReqDraw","prims_maze","props","clearInterval","setup_prims_maze","nodes_array","w","h","midd_x","Math","floor","midd_y","center_node","find","node","x","y","push","draw_prims_maze","setTimeout","clearRect","width","height","i","length","draw","add_neighbor_node","top","right","bottom","left","get_top_right_bottom_left","prev_node","filter","link_node_with_random_neighbor","random_num","getRandom","random_neighbor","walls","array","n","min","max","random"],"mappings":"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","sourcesContent":["let size , nodes , cols , rows , canvas , c , frame_per_second , speed \nlet neighbors_node , visited_neighbors_node , current_neighbor_node , myReqDraw \nconst prims_maze = props => {\n    size = props.size\n    nodes = props.nodes \n    cols = props.cols \n    rows = props.rows \n    canvas = props.canvas \n    c = props.c \n\n    frame_per_second = props.frame_per_second\n    speed = props.speed\n\n    neighbors_node = []\n    visited_neighbors_node = []\n    current_neighbor_node = null \n    \n    // cancelAnimationFrame(myReqDraw)\n    clearInterval(myReqDraw)\n    setup_prims_maze(nodes , cols , rows)\n}\n\nconst setup_prims_maze = (nodes_array , w , h) => {\n    let midd_x =  Math.floor(w / 2) * size + (size / 2)\n    let midd_y =  Math.floor(h / 2) * size + (size / 2)\n    let center_node = nodes_array.find(node => node.x === midd_x && node.y === midd_y)\n    neighbors_node.push(center_node)\n    visited_neighbors_node.push(center_node)\n    current_neighbor_node = center_node\n\n    draw_prims_maze()\n}\n\nconst draw_prims_maze = () => {\n    myReqDraw = setTimeout(() => {\n        draw_prims_maze()\n    }, frame_per_second / speed)\n    c.clearRect(0,0,canvas.width, canvas.height)\n\n    for(let i = 0; i < nodes.length; i ++){\n        nodes[i].draw()\n    }\n\n    if(neighbors_node.length === 0){\n        // cancelAnimationFrame(myReqDraw)\n        clearInterval(myReqDraw)\n    }\n\n    add_neighbor_node()\n}\n\nconst add_neighbor_node = () => {\n    let {x , y} = current_neighbor_node\n    \n    let {top , right , bottom , left} = get_top_right_bottom_left(current_neighbor_node , nodes) \n\n    if(\n        top \n        && !visited_neighbors_node.find(node => node.x === x && node.y === y - size)\n        && !neighbors_node.find(node => node.x === x && node.y === y - size)\n    ){\n        neighbors_node.push(top)\n        top.prev_node = current_neighbor_node\n    }\n\n    if(\n        right \n        && !visited_neighbors_node.find(node => node.x === x + size && node.y === y)\n        && !neighbors_node.find(node => node.x === x + size && node.y === y)\n    ){\n        neighbors_node.push(right)\n        right.prev_node = current_neighbor_node\n    }\n\n    if(\n        bottom \n        && !visited_neighbors_node.find(node => node.x === x && node.y === y + size)\n        && !neighbors_node.find(node => node.x === x && node.y === y + size)\n    ){\n        neighbors_node.push(bottom)\n        bottom.prev_node = current_neighbor_node\n    }\n\n    if(\n        left \n        && !visited_neighbors_node.find(node => node.x === x - size && node.y === y)\n        && !neighbors_node.find(node => node.x === x - size && node.y === y)\n    ){\n        neighbors_node.push(left)\n        left.prev_node = current_neighbor_node\n    }\n\n    neighbors_node = neighbors_node.filter(node => node.x === x && node.y === y ? false : true )\n\n    link_node_with_random_neighbor()\n}\n\nconst link_node_with_random_neighbor = () => {\n    if(neighbors_node.length === 0) return\n    let random_num = getRandom(0 , neighbors_node.length)\n    let random_neighbor = neighbors_node[random_num]\n    let {top , right , bottom , left} = get_top_right_bottom_left(random_neighbor,visited_neighbors_node)\n\n    if(top && top.x === random_neighbor.prev_node.x && top.y === random_neighbor.prev_node.y){\n        random_neighbor.walls[0] = false \n        top.walls[2] = false\n    }\n\n    if(right && right.x === random_neighbor.prev_node.x && right.y === random_neighbor.prev_node.y){\n        random_neighbor.walls[1] = false \n        right.walls[3] = false\n    }\n\n    if(bottom && bottom.x === random_neighbor.prev_node.x && bottom.y === random_neighbor.prev_node.y){\n        random_neighbor.walls[2] = false \n        bottom.walls[0] = false\n    }\n\n    if(left && left.x === random_neighbor.prev_node.x && left.y === random_neighbor.prev_node.y){\n        random_neighbor.walls[3] = false \n        left.walls[1] = false\n    }\n\n    current_neighbor_node = random_neighbor\n    visited_neighbors_node.push(random_neighbor)\n}\n\nconst get_top_right_bottom_left = (node , array ) => {\n    let {x , y} = node\n    let top = array.find(n => n.x === x && n.y === y - size)\n    let right = array.find(n => n.x === x + size && n.y === y)\n    let bottom = array.find(n => n.x === x && n.y === y + size)\n    let left = array.find(n => n.x === x - size && n.y === y)\n\n    return {top , right , bottom , left }\n}\n\nconst getRandom = (min,max) => {\n    return Math.floor(Math.random() * (max - min) + min)\n}\n\nexport {prims_maze}\n\n"]},"metadata":{},"sourceType":"module"}