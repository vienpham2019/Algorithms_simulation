{"ast":null,"code":"import { Block } from '../helper_method';\nimport { get_top_right_bottom_left, add_to_heap, remove_from_heap } from './helper_method/algorithms_helper_method';\nlet start_node, end_node, nodes, c, canvas, size;\nlet close_list_1, close_list_2, open_list_1, current_node_1, open_list_2, current_node_2, myReq, finish_path, finish_search;\n\nconst bidirectional_dijkstra = props => {\n  start_node = props.start_node;\n  start_node.distance = 0;\n  end_node = props.end_node;\n  nodes = props.nodes;\n  c = props.c;\n  canvas = props.canvas;\n  size = props.size; // end_node.prev_node = null\n  // open_list_1 = [start_node]\n\n  open_list_1 = add_to_heap(start_node, [], (a, b) => a.distance < b.distance);\n  close_list_1 = []; // open_list_2 = [end_node]\n\n  open_list_2 = add_to_heap(end_node, [], (a, b) => a.distance < b.distance);\n  close_list_2 = [];\n  current_node_1 = start_node;\n  current_node_2 = end_node;\n  finish_path = false;\n  finish_search = false;\n  cancelAnimationFrame(myReq);\n  run_solve_maze();\n};\n\nconst stop_bidirectional_dijkstra = () => {\n  cancelAnimationFrame(myReq);\n};\n\nconst run_solve_maze = () => {\n  myReq = requestAnimationFrame(run_solve_maze);\n  c.clearRect(0, 0, canvas.width, canvas.height);\n\n  for (let i = 0; i < nodes.length; i++) {\n    nodes[i].draw();\n  }\n\n  print_close_and_open_list(close_list_1, open_list_1, 'MediumBlue', 'LightSkyBlue');\n  print_close_and_open_list(close_list_2, open_list_2, 'CadetBlue', 'LightCyan');\n\n  if (open_list_2.length > 0 && !finish_search) {\n    // current_node_2 = open_list_2.sort((a,b) => a.distance - b.distance)[0] \n    current_node_2 = open_list_2[0];\n    close_list_2.push(current_node_2);\n    open_list_2 = find_child_node(current_node_2, open_list_2, close_list_2, close_list_1);\n  }\n\n  if (open_list_1.length > 0 && !finish_search) {\n    // current_node_1 = open_list_1.sort((a,b) => a.distance - b.distance)[0] \n    current_node_1 = open_list_1[0];\n    close_list_1.push(current_node_1);\n    open_list_1 = find_child_node(current_node_1, open_list_1, close_list_1, close_list_2);\n  }\n\n  if (finish_search) {\n    start_node.draw();\n    end_node.draw();\n\n    if (!current_node_1 && !current_node_2) {\n      finish_path = true;\n    }\n\n    find_path();\n  }\n\n  if (finish_path) {\n    cancelAnimationFrame(myReq);\n  }\n};\n\nconst print_close_and_open_list = (close_list, open_list, close_color, open_color) => {\n  if (!finish_search) {\n    for (let i = 0; i < open_list.length; i++) {\n      open_list[i].color = open_color;\n      open_list[i].draw();\n    }\n  }\n\n  for (let i = 0; i < close_list.length; i++) {\n    if (!finish_search) {\n      close_list[i].color = close_color;\n    }\n\n    close_list[i].draw();\n  }\n};\n\nconst check_for_mix_node = (next_close_list, x, y) => {\n  let node = next_close_list.find(node => node.x === x && node.y === y);\n\n  if (node) {\n    finish_search = true;\n\n    if (close_list_1.find(node => node.x === x && node.y === y)) {\n      current_node_1 = node;\n    } else {\n      current_node_2 = node;\n    }\n\n    return true;\n  }\n\n  return false;\n};\n\nconst find_child_node = (c_node, open_list, close_list, next_close_list) => {\n  open_list = remove_from_heap(open_list, (a, b) => a.distance < b.distance);\n  let {\n    top,\n    right,\n    bottom,\n    left\n  } = get_top_right_bottom_left(c_node, nodes, size); // Right (x + size , y)\n\n  open_list = add_node(right, c_node, 3, close_list, open_list, next_close_list); // if(right && !right.walls[3] && !close_list.find(node => node.x === right.x  && node.y === right.y)){\n  //     let right_in_open = open_list.find(n => n.x === right.x  && n.y === right.y)\n  //     if(!check_for_mix_node(next_close_list , right.x , right.y)){\n  //         right_in_open \n  //             ? update_node(right_in_open , c_node) \n  //             :  open_list.push(create_new_node(right , c_node))\n  //     }\n  // }\n  // top (x , y - size)\n\n  open_list = add_node(top, c_node, 2, close_list, open_list, next_close_list); // if(top && !top.walls[2] && !close_list.find(node => node.x === top.x && node.y === top.y)){\n  //     let top_in_open = open_list.find(n => n.x === top.x  && n.y === top.y)\n  //     if(!check_for_mix_node(next_close_list , top.x , top.y)){\n  //         top_in_open \n  //             ? update_node(top_in_open , c_node) \n  //             : open_list.push(create_new_node(top , c_node))\n  //     }\n  // }\n  // left (x - size , y )\n\n  open_list = add_node(left, c_node, 1, close_list, open_list, next_close_list); // if(left && !left.walls[1] && !close_list.find(node => node.x === left.x && node.y === left.y)){\n  //     let left_in_open = open_list.find(n => n.x === left.x  && n.y === left.y)\n  //     if(!check_for_mix_node(next_close_list , left.x , left.y)){\n  //         left_in_open \n  //             ? update_node(left_in_open , c_node) \n  //             : open_list.push(create_new_node(left , c_node))\n  //     }\n  // }\n  // bottom (x , y + size)\n\n  open_list = add_node(bottom, c_node, 0, close_list, open_list, next_close_list); // if(bottom && !bottom.walls[0] &&!close_list.find(node => node.x === bottom.x && node.y === bottom.y)){\n  //     let bottom_in_open = open_list.find(n => n.x === bottom.x  && n.y === bottom.y)\n  //     if(!check_for_mix_node(next_close_list , bottom.x , bottom.y)){\n  //         bottom_in_open \n  //             ? update_node(bottom_in_open , c_node) \n  //             :  open_list.push(create_new_node(bottom , c_node))\n  //     }\n  // }\n\n  return open_list.filter(node => node.x === c_node.x && node.y === c_node.y ? false : true);\n};\n\nconst add_node = (neighbor_node, c_node, wall_num, close_list, open_list, neighbor_close_list) => {\n  if (neighbor_node && !neighbor_node.walls[wall_num] && !close_list.find(node => node.x === neighbor_node.x && node.y === neighbor_node.y)) {\n    let {\n      x,\n      y\n    } = neighbor_node;\n    let node_in_open = open_list.find(n => n.x === x && n.y === y);\n\n    if (!check_for_mix_node(neighbor_close_list, x, y)) {\n      if (node_in_open) {\n        update_node(node_in_open, c_node);\n      } else {\n        let new_node = create_new_node(neighbor_node, c_node);\n        open_list = add_to_heap(new_node, open_list, (a, b) => a.distance < b.distance);\n      }\n    }\n  }\n\n  return open_list;\n};\n\nconst find_path = () => {\n  let color = \"LimeGreen\";\n\n  if (current_node_1) {\n    current_node_1.color = color;\n    current_node_1 = current_node_1.prev_node;\n  }\n\n  if (current_node_2) {\n    current_node_2.color = color;\n    current_node_2 = current_node_2.prev_node;\n  }\n};\n\nconst create_new_node = (node, c_node) => {\n  let distance = find_distance(node, c_node);\n  return new Block(node.x, node.y, c, size, 'MidnightBlue', c_node, null, null, null, distance);\n};\n\nconst find_distance = (node, c_node) => {\n  // find distance from current node to next node \n  let x_1 = c_node.x;\n  let y_1 = c_node.y;\n  let x_2 = node.x;\n  let y_2 = node.y;\n  return (Math.abs(x_1 - x_2) + Math.abs(y_1 - y_2)) * size + c_node.distance;\n};\n\nconst update_node = (node, c_node) => {\n  if (c_node.distance + size < node.distance) {\n    node.distance = find_distance(node, c_node);\n  }\n\n  return node;\n};\n\nexport { bidirectional_dijkstra, stop_bidirectional_dijkstra };","map":{"version":3,"sources":["/Users/vienpham/Desktop/Algorithms_simulation/algorithms/src/Algorithms/solve_maze/bidirectional_dijkstra.js"],"names":["Block","get_top_right_bottom_left","add_to_heap","remove_from_heap","start_node","end_node","nodes","c","canvas","size","close_list_1","close_list_2","open_list_1","current_node_1","open_list_2","current_node_2","myReq","finish_path","finish_search","bidirectional_dijkstra","props","distance","a","b","cancelAnimationFrame","run_solve_maze","stop_bidirectional_dijkstra","requestAnimationFrame","clearRect","width","height","i","length","draw","print_close_and_open_list","push","find_child_node","find_path","close_list","open_list","close_color","open_color","color","check_for_mix_node","next_close_list","x","y","node","find","c_node","top","right","bottom","left","add_node","filter","neighbor_node","wall_num","neighbor_close_list","walls","node_in_open","n","update_node","new_node","create_new_node","prev_node","find_distance","x_1","y_1","x_2","y_2","Math","abs"],"mappings":"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","sourcesContent":["import { Block } from '../helper_method'\nimport {get_top_right_bottom_left , add_to_heap , remove_from_heap} from './helper_method/algorithms_helper_method'\n\nlet start_node , end_node , nodes , c , canvas , size \n\nlet close_list_1 , close_list_2 , open_list_1 , current_node_1 , open_list_2, current_node_2 , myReq , finish_path , finish_search \n\nconst bidirectional_dijkstra = props => {\n    start_node = props.start_node\n    start_node.distance = 0\n    end_node = props.end_node \n    nodes = props.nodes\n    c = props.c \n    canvas = props.canvas \n    size = props.size \n\n    // end_node.prev_node = null\n    \n    // open_list_1 = [start_node]\n    open_list_1 = add_to_heap(start_node , [] , (a,b) => a.distance < b.distance)\n    close_list_1 = []\n\n    // open_list_2 = [end_node]\n    open_list_2 = add_to_heap(end_node , [] , (a,b) => a.distance < b.distance)\n    close_list_2 = []\n\n    current_node_1 = start_node\n    current_node_2 = end_node \n\n    finish_path = false \n    finish_search = false \n\n    cancelAnimationFrame(myReq)\n    run_solve_maze()\n}\n\nconst stop_bidirectional_dijkstra = () => {\n    cancelAnimationFrame(myReq)\n}\n\nconst run_solve_maze = () => {\n    myReq = requestAnimationFrame(run_solve_maze)\n    c.clearRect(0,0,canvas.width, canvas.height)\n\n    for(let i = 0 ; i < nodes.length ; i ++){\n        nodes[i].draw()\n    }\n\n    print_close_and_open_list(close_list_1 , open_list_1 , 'MediumBlue' , 'LightSkyBlue' )\n    print_close_and_open_list(close_list_2 , open_list_2 , 'CadetBlue' , 'LightCyan')\n\n    if(open_list_2.length > 0 && !finish_search){\n        // current_node_2 = open_list_2.sort((a,b) => a.distance - b.distance)[0] \n        current_node_2 = open_list_2[0] \n        close_list_2.push(current_node_2)\n        open_list_2 = find_child_node(current_node_2 , open_list_2 , close_list_2 , close_list_1)\n    }\n\n    if(open_list_1.length > 0 && !finish_search){\n        // current_node_1 = open_list_1.sort((a,b) => a.distance - b.distance)[0] \n        current_node_1 = open_list_1[0] \n        close_list_1.push(current_node_1)\n        open_list_1 = find_child_node(current_node_1 , open_list_1 , close_list_1 , close_list_2)\n    }\n\n    if(finish_search){\n        start_node.draw()\n        end_node.draw()\n\n        if(!current_node_1 && !current_node_2){\n            finish_path = true\n        }\n\n        find_path() \n    }\n\n    if(finish_path){\n        cancelAnimationFrame(myReq)\n    }\n}\n\nconst print_close_and_open_list = (close_list , open_list , close_color , open_color ) => {\n    if(!finish_search){\n        for(let i = 0 ; i < open_list.length ; i ++){\n            open_list[i].color = open_color\n            open_list[i].draw()\n        }\n    }\n\n    for(let i = 0 ; i < close_list.length ; i ++){\n        if(!finish_search){\n            close_list[i].color = close_color \n        }\n        close_list[i].draw()\n    }\n}\n\nconst check_for_mix_node = (next_close_list , x , y) => {\n    let node = next_close_list.find(node => node.x === x && node.y === y)\n    if(node){\n        finish_search = true \n        if(close_list_1.find(node => node.x === x  && node.y === y)){\n            current_node_1 = node\n        }else{\n            current_node_2 = node\n        }\n        return true \n    }\n    return false \n}\n\nconst find_child_node = (c_node , open_list , close_list , next_close_list) => {\n    open_list = remove_from_heap(open_list , (a,b) => a.distance < b.distance)\n    let {top , right , bottom , left} = get_top_right_bottom_left(c_node , nodes , size)\n\n    // Right (x + size , y)\n    open_list = add_node(right , c_node , 3 , close_list , open_list , next_close_list)\n    // if(right && !right.walls[3] && !close_list.find(node => node.x === right.x  && node.y === right.y)){\n    //     let right_in_open = open_list.find(n => n.x === right.x  && n.y === right.y)\n\n    //     if(!check_for_mix_node(next_close_list , right.x , right.y)){\n    //         right_in_open \n    //             ? update_node(right_in_open , c_node) \n    //             :  open_list.push(create_new_node(right , c_node))\n    //     }\n    // }\n\n    // top (x , y - size)\n    open_list = add_node(top , c_node , 2 , close_list , open_list , next_close_list)\n    // if(top && !top.walls[2] && !close_list.find(node => node.x === top.x && node.y === top.y)){\n    //     let top_in_open = open_list.find(n => n.x === top.x  && n.y === top.y)\n        \n    //     if(!check_for_mix_node(next_close_list , top.x , top.y)){\n    //         top_in_open \n    //             ? update_node(top_in_open , c_node) \n    //             : open_list.push(create_new_node(top , c_node))\n    //     }\n    // }\n\n    // left (x - size , y )\n    open_list = add_node(left , c_node , 1 , close_list , open_list , next_close_list)\n    // if(left && !left.walls[1] && !close_list.find(node => node.x === left.x && node.y === left.y)){\n    //     let left_in_open = open_list.find(n => n.x === left.x  && n.y === left.y)\n        \n    //     if(!check_for_mix_node(next_close_list , left.x , left.y)){\n    //         left_in_open \n    //             ? update_node(left_in_open , c_node) \n    //             : open_list.push(create_new_node(left , c_node))\n    //     }\n    // }\n\n    // bottom (x , y + size)\n    open_list = add_node(bottom , c_node , 0 , close_list , open_list , next_close_list)\n    // if(bottom && !bottom.walls[0] &&!close_list.find(node => node.x === bottom.x && node.y === bottom.y)){\n    //     let bottom_in_open = open_list.find(n => n.x === bottom.x  && n.y === bottom.y)\n        \n    //     if(!check_for_mix_node(next_close_list , bottom.x , bottom.y)){\n    //         bottom_in_open \n    //             ? update_node(bottom_in_open , c_node) \n    //             :  open_list.push(create_new_node(bottom , c_node))\n    //     }\n    // }\n\n    return open_list.filter(node => node.x === c_node.x && node.y === c_node.y ? false : true )\n}\n\nconst add_node = (neighbor_node , c_node , wall_num , close_list , open_list , neighbor_close_list) => {\n    if(neighbor_node && !neighbor_node.walls[wall_num] &&!close_list.find(node => node.x === neighbor_node.x && node.y === neighbor_node.y)){\n        let {x , y} = neighbor_node\n        let node_in_open = open_list.find(n => n.x === x  && n.y === y)\n        \n        if(!check_for_mix_node(neighbor_close_list , x , y)){\n            if(node_in_open){\n                update_node(node_in_open , c_node) \n            } else{\n                let new_node = create_new_node(neighbor_node , c_node)\n                open_list = add_to_heap(new_node , open_list , (a,b) => a.distance < b.distance)\n            }\n        }\n    }\n    return open_list\n}\n\nconst find_path = () => {\n    let color = \"LimeGreen\"\n    if(current_node_1){\n        current_node_1.color = color\n        current_node_1 = current_node_1.prev_node\n    }\n    if(current_node_2){\n        current_node_2.color = color\n        current_node_2 = current_node_2.prev_node \n    }\n}\n\nconst create_new_node = (node , c_node) => {\n    let distance = find_distance(node , c_node)\n    return new Block(node.x , node.y , c , size , 'MidnightBlue' , c_node , null , null , null , distance)\n}\n\nconst find_distance = (node , c_node) => {\n    // find distance from current node to next node \n    let x_1 = c_node.x \n    let y_1 = c_node.y\n\n    let x_2 = node.x \n    let y_2 = node.y\n\n   return ((Math.abs(x_1 - x_2) + Math.abs(y_1 - y_2)) * size ) + c_node.distance\n}\n\nconst update_node = (node , c_node) => {\n    if(c_node.distance + size < node.distance){\n        node.distance = find_distance(node , c_node)\n    }\n    return node\n}\n\nexport {bidirectional_dijkstra , stop_bidirectional_dijkstra}"]},"metadata":{},"sourceType":"module"}