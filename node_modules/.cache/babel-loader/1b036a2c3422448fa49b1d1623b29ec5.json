{"ast":null,"code":"const Block = function (x, y, color = \"red\", prev_node = null) {\n  this.x = x;\n  this.y = y;\n  this.dx = size;\n  this.dy = size;\n  this.prev_node = prev_node;\n  this.color = color;\n\n  this.draw = () => {\n    c.beginPath();\n    c.rect(this.x + size / 8, this.y + size / 8, size * (3 / 4), size * (3 / 4));\n    c.fillStyle = this.color;\n    c.fill();\n  };\n\n  this.move = () => {\n    let current_node = stack[0];\n    let neighbor_nodes = [];\n    let x = current_node.x;\n    let y = current_node.y; // top\n\n    if (y - size > 0 && !visited_nodes.find(n => n.x === x && n.y === y - size)) {\n      let top = nodes.find(n => n.x === x && n.y === y - size);\n      neighbor_nodes.push(top);\n    } // right \n\n\n    if (x + size < width && !visited_nodes.find(n => n.x === x + size && n.y === y)) {\n      let right = nodes.find(n => n.x === x + size && n.y === y);\n      neighbor_nodes.push(right);\n    } // bottom\n\n\n    if (y + size < height && !visited_nodes.find(n => n.x === x && n.y === y + size)) {\n      let bottom = nodes.find(n => n.x === x && n.y === y + size);\n      neighbor_nodes.push(bottom);\n    } // left\n\n\n    if (x - size > 0 && !visited_nodes.find(n => n.x === x - size && n.y === y)) {\n      let left = nodes.find(n => n.x === x - size && n.y === y);\n      neighbor_nodes.push(left);\n    }\n\n    if (neighbor_nodes.length > 0) {\n      let next_node = neighbor_nodes[Math.floor(Math.random() * neighbor_nodes.length)];\n      stack.unshift(next_node);\n      visited_nodes.push(next_node);\n      this.dx = next_node.x - current_node.x;\n      this.dy = next_node.y - current_node.y;\n      this.x += this.dx;\n      this.y += this.dy;\n\n      if (this.dx > 0) {\n        // right \n        current_node.walls[1] = false;\n        next_node.walls[3] = false;\n      } else if (this.dx < 0) {\n        // left\n        current_node.walls[3] = false;\n        next_node.walls[1] = false;\n      }\n\n      if (this.dy > 0) {\n        // down\n        current_node.walls[2] = false;\n        next_node.walls[0] = false;\n      } else if (this.dy < 0) {\n        // up\n        current_node.walls[0] = false;\n        next_node.walls[2] = false;\n      }\n    } else {\n      let dx = current_node.x - (this.x + size / 2);\n      let dy = current_node.y - (this.y + size / 2);\n      this.x += dx;\n      this.y += dy;\n      stack.shift();\n    }\n\n    this.draw();\n  };\n};\n\nconst Node = function (x, y, neighbor_node = [], prev_node = null) {\n  this.x = x;\n  this.y = y;\n  this.neighbor_node = neighbor_node;\n  this.prev_node = prev_node;\n  this.walls = [true, true, true, true]; // [top, right , bottom , left ]\n\n  this.draw = (color = \"white\") => {\n    let x = this.x - size / 2;\n    let y = this.y - size / 2; // Top \n\n    if (this.walls[0]) {\n      c.beginPath();\n      c.moveTo(x, y);\n      c.lineTo(x + size, y);\n      c.lineWidth = 4;\n      c.lineCap = \"round\";\n      c.strokeStyle = color;\n      c.stroke();\n    } // right\n\n\n    if (this.walls[1]) {\n      c.beginPath();\n      c.moveTo(x + size, y);\n      c.lineTo(x + size, y + size);\n      c.lineWidth = 4;\n      c.lineCap = \"round\";\n      c.strokeStyle = color;\n      c.stroke();\n    } // bottom\n\n\n    if (this.walls[2]) {\n      c.beginPath();\n      c.moveTo(x + size, y + size);\n      c.lineTo(x, y + size);\n      c.lineWidth = 4;\n      c.lineCap = \"round\";\n      c.strokeStyle = color;\n      c.stroke();\n    } // left \n\n\n    if (this.walls[3]) {\n      c.beginPath();\n      c.moveTo(x, y + size);\n      c.lineTo(x, y);\n      c.lineWidth = 4;\n      c.lineCap = \"round\";\n      c.strokeStyle = color;\n      c.stroke();\n    }\n  };\n};\n\nexport { Block, Node };","map":{"version":3,"sources":["/Users/vienpham/Desktop/Algorithms_simulation/algorithms/src/Algorithms/helper_method.js"],"names":["Block","x","y","color","prev_node","dx","size","dy","draw","c","beginPath","rect","fillStyle","fill","move","current_node","stack","neighbor_nodes","visited_nodes","find","n","top","nodes","push","width","right","height","bottom","left","length","next_node","Math","floor","random","unshift","walls","shift","Node","neighbor_node","moveTo","lineTo","lineWidth","lineCap","strokeStyle","stroke"],"mappings":"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","sourcesContent":["const Block = function(x , y , color = \"red\", prev_node = null){\n    this.x = x \n    this.y = y \n    this.dx = size\n    this.dy = size\n    this.prev_node  = prev_node\n    this.color = color\n\n    this.draw = () => {\n        c.beginPath()\n        c.rect(this.x + size / 8 , this.y + size / 8, size * (3 / 4), size * (3 /4))\n        c.fillStyle = this.color\n        c.fill()\n    }\n\n    this.move = () => {\n        let current_node = stack[0]\n        let neighbor_nodes = []\n        let x = current_node.x\n        let y = current_node.y\n\n        // top\n        if(y - size > 0 && !visited_nodes.find(n => n.x === x && n.y === y - size)){\n            let top = nodes.find(n => n.x === x && n.y === y - size)\n            neighbor_nodes.push(top)\n        }\n\n        // right \n        if(x + size < width && !visited_nodes.find(n => n.x === x + size && n.y === y)){\n            let right = nodes.find(n => n.x === x + size && n.y === y)\n            neighbor_nodes.push(right)\n        }\n\n        // bottom\n        if(y + size < height && !visited_nodes.find(n => n.x === x && n.y === y + size)){\n            let bottom = nodes.find(n => n.x === x && n.y === y + size)\n            neighbor_nodes.push(bottom)\n        }\n\n        // left\n        if(x - size > 0 && !visited_nodes.find(n => n.x === x - size && n.y === y)){\n            let left = nodes.find(n => n.x === x - size && n.y === y)\n            neighbor_nodes.push(left)\n        }\n\n        if(neighbor_nodes.length > 0){\n            let next_node = neighbor_nodes[Math.floor(Math.random() * neighbor_nodes.length)]\n            stack.unshift(next_node)\n            visited_nodes.push(next_node)\n            this.dx = next_node.x - current_node.x\n            this.dy = next_node.y - current_node.y\n\n            this.x += this.dx \n            this.y += this.dy\n\n            if(this.dx > 0) { // right \n                current_node.walls[1] = false \n                next_node.walls[3] = false \n            }else if(this.dx < 0){ // left\n                current_node.walls[3] = false \n                next_node.walls[1] = false \n            } \n\n            if(this.dy > 0) { // down\n                current_node.walls[2] = false \n                next_node.walls[0] = false \n            }else if(this.dy < 0){ // up\n                current_node.walls[0] = false \n                next_node.walls[2] = false \n            }\n        }else{\n            let dx = current_node.x  - (this.x + (size / 2))\n            let dy = current_node.y  - (this.y + (size / 2))\n            this.x += dx \n            this.y += dy\n            stack.shift()\n        }\n        this.draw()\n    }\n}\n\nconst Node = function(x , y , neighbor_node = [], prev_node = null){\n    this.x = x\n    this.y = y\n    this.neighbor_node = neighbor_node\n    this.prev_node = prev_node \n    this.walls = [true,true,true,true] // [top, right , bottom , left ]\n\n    this.draw = (color = \"white\") => {\n        let x = this.x - (size / 2)\n        let y = this.y - (size / 2)\n\n        // Top \n        if(this.walls[0]){\n            c.beginPath()\n            c.moveTo(x, y)\n            c.lineTo(x + size , y)\n            c.lineWidth = 4\n            c.lineCap = \"round\"\n            c.strokeStyle = color\n            c.stroke()\n        }\n\n        // right\n        if(this.walls[1]){\n            c.beginPath()\n            c.moveTo(x + size, y)\n            c.lineTo(x + size , y +size)\n            c.lineWidth = 4\n            c.lineCap = \"round\"\n            c.strokeStyle = color\n            c.stroke()\n        }\n\n        // bottom\n        if(this.walls[2]){\n            c.beginPath()\n            c.moveTo(x + size, y + size)\n            c.lineTo(x, y +size)\n            c.lineWidth = 4\n            c.lineCap = \"round\"\n            c.strokeStyle = color\n            c.stroke()\n        }\n\n        // left \n        if(this.walls[3]){\n            c.beginPath()\n            c.moveTo(x, y + size)\n            c.lineTo(x, y)\n            c.lineWidth = 4\n            c.lineCap = \"round\"\n            c.strokeStyle = color\n            c.stroke()\n        }\n    }\n}\n\nexport {Block , Node }"]},"metadata":{},"sourceType":"module"}