{"ast":null,"code":"let delay, speed, size, cols;\n\nconst prims_maze_generation = props => {\n  delay = props.delay;\n  speed = props.speed;\n  size = props.size;\n  cols = props.cols;\n  let {\n    nodes,\n    x_max,\n    y_max,\n    x_min,\n    y_min\n  } = props;\n  return draw_maze(nodes, x_max, y_max, x_min, y_min);\n};\n\nconst draw_maze = (nodes_array, x_max, y_max, x_min, y_min) => {\n  if (x_max - x_min < 1 || y_max - y_min < 1) return;\n  let random_x = getRandom(x_min, x_max);\n  let random_y = getRandom(y_min, y_max);\n  let x_or_y = getRandom(-20, 20);\n  delay++;\n  setTimeout(() => {\n    for (let i = 0; i < nodes_array.length; i++) {\n      if (x_or_y > 0) {\n        // x\n        if (nodes_array[i].x === random_x * size + size / 2 && nodes_array[i].y <= y_max * size + size / 2 && nodes_array[i].y >= y_min * size + size / 2 && nodes_array[i].x !== (cols - 1) * size + size / 2) {\n          if (nodes_array[i].y !== random_y * size + size / 2) {\n            nodes_array[i].walls[1] = true;\n            let {\n              x,\n              y\n            } = nodes_array[i];\n            let neightbor_node = nodes_array.find(node => node.x === x + size && node.y === y);\n\n            if (neightbor_node) {\n              neightbor_node.walls[3] = true;\n            }\n          }\n        }\n      } else {\n        if (nodes_array[i].y === random_y * size + size / 2 && nodes_array[i].x <= x_max * size + size / 2 && nodes_array[i].x >= x_min * size + size / 2) {\n          if (nodes_array[i].x !== random_x * size + size / 2) {\n            nodes_array[i].walls[2] = true;\n            let {\n              x,\n              y\n            } = nodes_array[i];\n            let neightbor_node = nodes_array.find(node => node.x === x && node.y === y + size);\n\n            if (neightbor_node) {\n              neightbor_node.walls[0] = true;\n            }\n          }\n        }\n      }\n\n      nodes_array[i].draw();\n    }\n  }, delay * speed);\n\n  if (x_or_y > 0) {\n    draw_maze(nodes_array, random_x, y_max, x_min, y_min); // right \n\n    draw_maze(nodes_array, x_max, y_max, random_x + 1, y_min); // left \n  } else {\n    draw_maze(nodes_array, x_max, random_y, x_min, y_min); // top \n\n    draw_maze(nodes_array, x_max, y_max, x_min, random_y + 1); // bottom\n  }\n\n  return delay;\n};\n\nconst getRandom = (min, max) => {\n  return Math.floor(Math.random() * (max - min) + min);\n};\n\nexport { prims_maze_generation };","map":{"version":3,"sources":["/Users/vienpham/Desktop/Algorithms_simulation/algorithms/src/Algorithms/draw_maze/prims_maze_generation.js"],"names":["delay","speed","size","cols","prims_maze_generation","props","nodes","x_max","y_max","x_min","y_min","draw_maze","nodes_array","random_x","getRandom","random_y","x_or_y","setTimeout","i","length","x","y","walls","neightbor_node","find","node","draw","min","max","Math","floor","random"],"mappings":"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","sourcesContent":["let delay , speed , size , cols  \n\nconst prims_maze_generation = (props) => {\n    delay = props.delay\n    speed = props.speed \n    size = props.size \n    cols = props.cols \n\n    let {nodes , x_max , y_max , x_min , y_min} = props\n    return draw_maze(nodes , x_max , y_max , x_min , y_min)\n}\n\nconst draw_maze = (nodes_array , x_max, y_max, x_min , y_min) => {\n\n    if(x_max - x_min < 1 || y_max - y_min < 1) return\n  \n    let random_x = getRandom(x_min,x_max)\n    let random_y = getRandom(y_min,y_max)\n    let x_or_y = getRandom(-20, 20) \n  \n    delay ++\n  \n    setTimeout(() => {\n      for(let i = 0; i < nodes_array.length; i ++){\n          if(x_or_y > 0) { // x\n              if (\n                  nodes_array[i].x === random_x * size + (size / 2) \n                  && nodes_array[i].y <= y_max * size + (size / 2)\n                  && nodes_array[i].y >= y_min * size + (size / 2)\n                  && nodes_array[i].x !== (cols - 1) * size + (size / 2)\n                  ){\n                  if (nodes_array[i].y !== random_y * size + (size / 2)){\n                      nodes_array[i].walls[1] = true\n                      let {x , y} = nodes_array[i]\n                      let neightbor_node = nodes_array.find(node => node.x === x + size && node.y === y) \n                      if(neightbor_node){\n                          neightbor_node.walls[3] = true\n                      } \n                  }\n              }\n          }else{\n              if(\n                  nodes_array[i].y === random_y * size + (size / 2)\n                  && nodes_array[i].x <= x_max * size + (size / 2)\n                  && nodes_array[i].x >= x_min * size + (size / 2)\n                  ){\n                  if(nodes_array[i].x !== random_x * size + (size / 2)){\n                      nodes_array[i].walls[2] = true\n                      let {x , y} = nodes_array[i]\n                      let neightbor_node = nodes_array.find(node => node.x === x && node.y === y + size) \n                      if(neightbor_node){\n                        neightbor_node.walls[0] = true\n                      } \n                  }\n              }\n          }\n            nodes_array[i].draw()\n        }\n    }, delay * speed)\n  \n    if(x_or_y > 0){ \n      draw_maze(nodes_array, random_x, y_max, x_min, y_min) // right \n      draw_maze(nodes_array, x_max, y_max, random_x + 1, y_min) // left \n    }else{\n      draw_maze(nodes_array, x_max, random_y, x_min, y_min) // top \n      draw_maze(nodes_array, x_max, y_max, x_min , random_y + 1) // bottom\n    }\n  \n    return delay \n}\n\nconst getRandom = (min,max) => {\n    return Math.floor(Math.random() * (max - min) + min)\n}\n\nexport {prims_maze_generation}"]},"metadata":{},"sourceType":"module"}