{"ast":null,"code":"import { Node } from './helper_method';\nlet size, width, height, cols, rows;\nlet canvas, c;\nlet nodes, block;\nlet visited_nodes, stack;\nlet quere, finish_path, nodes_path, path, current_node;\nlet start_node, end_node;\nlet myReq, myReqDraw;\n\nconst setUp = props => {\n  c = props.c;\n  canvas = props.canvas;\n  canvas.width = width;\n  canvas.height = height;\n  nodes = [];\n  visited_nodes = [];\n  stack = [];\n  quere = [];\n  nodes_path = [];\n  path = [];\n  finish_path = false;\n  cols = props.cols;\n  rows = props.rows;\n  size = props.size;\n  width = size * cols;\n  height = size * rows;\n  draw_frims_maze();\n};\n\nconst draw_frims_maze = () => {\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      let x = j * size + size / 2;\n      let y = i * size + size / 2;\n      let node = new Node(x, y, c, size);\n\n      if (i === 0 && j === 0) {\n        node.walls[3] = false;\n      }\n\n      if (j === cols - 1 && i === rows - 1) {\n        node.walls[1] = false;\n      }\n\n      if (i === 0 && j === 0) {\n        stack.push(node);\n        visited_nodes.push(node);\n      }\n\n      nodes.push(node);\n    }\n  }\n\n  start_node = new Block(size / 2, size / 2, c, size, \"blue\");\n  quere.push(start_node);\n  end_node = new Block((cols - 1) * size + size / 2, (rows - 1) * size + size / 2, c, size, \"green\");\n  setup_prims_maze(nodes, cols, rows);\n};\n\nlet neighbors_node = [];\nlet visited_neighbors_node = [];\nlet current_neighbor_node;\n\nconst setup_prims_maze = (nodes_array, w, h) => {\n  let midd_x = Math.floor(w / 2) * size + size / 2;\n  let midd_y = Math.floor(h / 2) * size + size / 2;\n  let center_node = nodes_array.find(node => node.x === midd_x && node.y === midd_y);\n  neighbors_node.push(center_node);\n  visited_neighbors_node.push(center_node);\n  current_neighbor_node = center_node;\n  draw_prims_maze();\n};\n\nconst draw_prims_maze = () => {\n  myReqDraw = requestAnimationFrame(draw_prims_maze);\n  c.clearRect(0, 0, canvas.width, canvas.height);\n\n  for (let i = 0; i < nodes.length; i++) {\n    nodes[i].draw();\n  }\n\n  if (neighbors_node.length === 0) {\n    cancelAnimationFrame(myReqDraw);\n  }\n\n  add_neighbor_node();\n};\n\nconst add_neighbor_node = () => {\n  let {\n    x,\n    y\n  } = current_neighbor_node;\n  let {\n    top,\n    right,\n    bottom,\n    left\n  } = get_top_right_bottom_left(current_neighbor_node, nodes);\n\n  if (top && !visited_neighbors_node.find(node => node.x === x && node.y === y - size) && !neighbors_node.find(node => node.x === x && node.y === y - size)) {\n    neighbors_node.push(top);\n    top.prev_node = current_neighbor_node;\n  }\n\n  if (right && !visited_neighbors_node.find(node => node.x === x + size && node.y === y) && !neighbors_node.find(node => node.x === x + size && node.y === y)) {\n    neighbors_node.push(right);\n    right.prev_node = current_neighbor_node;\n  }\n\n  if (bottom && !visited_neighbors_node.find(node => node.x === x && node.y === y + size) && !neighbors_node.find(node => node.x === x && node.y === y + size)) {\n    neighbors_node.push(bottom);\n    bottom.prev_node = current_neighbor_node;\n  }\n\n  if (left && !visited_neighbors_node.find(node => node.x === x - size && node.y === y) && !neighbors_node.find(node => node.x === x - size && node.y === y)) {\n    neighbors_node.push(left);\n    left.prev_node = current_neighbor_node;\n  }\n\n  neighbors_node = neighbors_node.filter(node => node.x === x && node.y === y ? false : true);\n  link_node_with_random_neighbor();\n};\n\nconst link_node_with_random_neighbor = () => {\n  if (neighbors_node.length === 0) return;\n  let random_num = getRandom(0, neighbors_node.length);\n  let random_neighbor = neighbors_node[random_num];\n  let {\n    top,\n    right,\n    bottom,\n    left\n  } = get_top_right_bottom_left(random_neighbor, visited_neighbors_node);\n\n  if (top && top.x === random_neighbor.prev_node.x && top.y === random_neighbor.prev_node.y) {\n    random_neighbor.walls[0] = false;\n    top.walls[2] = false;\n  }\n\n  if (right && right.x === random_neighbor.prev_node.x && right.y === random_neighbor.prev_node.y) {\n    random_neighbor.walls[1] = false;\n    right.walls[3] = false;\n  }\n\n  if (bottom && bottom.x === random_neighbor.prev_node.x && bottom.y === random_neighbor.prev_node.y) {\n    random_neighbor.walls[2] = false;\n    bottom.walls[0] = false;\n  }\n\n  if (left && left.x === random_neighbor.prev_node.x && left.y === random_neighbor.prev_node.y) {\n    random_neighbor.walls[3] = false;\n    left.walls[1] = false;\n  }\n\n  current_neighbor_node = random_neighbor;\n  visited_neighbors_node.push(random_neighbor);\n};\n\nconst get_top_right_bottom_left = (node, array) => {\n  let {\n    x,\n    y\n  } = node;\n  let top = array.find(n => n.x === x && n.y === y - size);\n  let right = array.find(n => n.x === x + size && n.y === y);\n  let bottom = array.find(n => n.x === x && n.y === y + size);\n  let left = array.find(n => n.x === x - size && n.y === y);\n  return {\n    top,\n    right,\n    bottom,\n    left\n  };\n};\n\nconst getRandom = (min, max) => {\n  return Math.floor(Math.random() * (max - min) + min);\n};\n\nconst run_solve_maze = () => {\n  myReq = requestAnimationFrame(run_solve_maze);\n  c.clearRect(0, 0, canvas.width, canvas.height);\n\n  for (let i = 0; i < nodes.length; i++) {\n    nodes[i].draw();\n  }\n\n  for (let i = 0; i < nodes_path.length; i++) {\n    nodes_path[i].draw();\n  }\n\n  start_node.draw();\n  end_node.draw();\n\n  if (end_node.prev_node) {\n    find_path();\n  }\n\n  if (finish_path) {\n    cancelAnimationFrame(myReq);\n  }\n\n  if (!end_node.prev_node && !finish_path) {\n    solve_maze();\n  }\n};\n\nconst solve_maze = () => {\n  let quere_nodes = [...quere];\n  quere.shift(); // visited_nodes_for_path.push(current_node)\n\n  if (end_node.prev_node) {\n    return;\n  }\n\n  for (let i = 0; i < quere_nodes.length; i++) {\n    check_neighbor_node(quere_nodes[i]);\n  }\n};\n\nconst check_neighbor_node = node => {\n  let x = node.x;\n  let y = node.y;\n  let color = \"MidnightBlue\";\n  let current_find_node = nodes.find(c_n => c_n.x === node.x && c_n.y === node.y); // top \n\n  let top = nodes.find(n => n.x === x && n.y === y - size);\n\n  if (top && !current_find_node.walls[0] && !nodes_path.find(n => n.x === top.x && n.y === top.y)) {\n    let top_x = top.x;\n    let top_y = top.y;\n\n    if (top_x === end_node.x && top_y === end_node.y) {\n      end_node.prev_node = node;\n      current_node = node;\n      return;\n    } else {\n      let top_block = new Block(top_x, top_y, color, node);\n      quere.push(top_block);\n      nodes_path.push(top_block);\n    }\n  } // right\n\n\n  let right = nodes.find(n => n.x === x + size && n.y === y);\n\n  if (right && !current_find_node.walls[1] && !nodes_path.find(n => n.x === right.x && n.y === right.y)) {\n    let right_x = right.x;\n    let right_y = right.y;\n\n    if (right_x === end_node.x && right_y === end_node.y) {\n      end_node.prev_node = node;\n      current_node = node;\n      return;\n    } else {\n      let right_block = new Block(right_x, right_y, color, node);\n      quere.push(right_block);\n      nodes_path.push(right_block);\n    }\n  } // bottom\n\n\n  let bottom = nodes.find(n => n.x === x && n.y === y + size);\n\n  if (bottom && !current_find_node.walls[2] && !nodes_path.find(n => n.x === bottom.x && n.y === bottom.y)) {\n    let bottom_x = bottom.x;\n    let bottom_y = bottom.y;\n\n    if (bottom_x === end_node.x && bottom_y === end_node.y) {\n      end_node.prev_node = node;\n      current_node = node;\n      return;\n    } else {\n      let bottom_block = new Block(bottom_x, bottom_y, color, node);\n      quere.push(bottom_block);\n      nodes_path.push(bottom_block);\n    }\n  } // left \n\n\n  let left = nodes.find(n => n.x === x - size && n.y === y);\n\n  if (left && !current_find_node.walls[3] && !nodes_path.find(n => n.x === left.x && n.y === left.y)) {\n    let left_x = left.x;\n    let left_y = left.y;\n\n    if (left_x === end_node.x && left_y === end_node.y) {\n      end_node.prev_node = node;\n      current_node = node;\n      return;\n    } else {\n      let left_block = new Block(left_x, left_y, color, node);\n      quere.push(left_block);\n      nodes_path.push(left_block);\n    }\n  }\n};\n\nconst find_path = () => {\n  current_node.color = \"green\";\n\n  if (current_node.x === start_node.x && current_node.y === start_node.y) {\n    finish_path = true;\n    return;\n  }\n\n  current_node = current_node.prev_node;\n};\n\nexport { setUp, run_solve_maze };","map":{"version":3,"sources":["/Users/vienpham/Desktop/Algorithms_simulation/algorithms/src/Algorithms/depth_first_search_maze.js"],"names":["Node","size","width","height","cols","rows","canvas","c","nodes","block","visited_nodes","stack","quere","finish_path","nodes_path","path","current_node","start_node","end_node","myReq","myReqDraw","setUp","props","draw_frims_maze","i","j","x","y","node","walls","push","Block","setup_prims_maze","neighbors_node","visited_neighbors_node","current_neighbor_node","nodes_array","w","h","midd_x","Math","floor","midd_y","center_node","find","draw_prims_maze","requestAnimationFrame","clearRect","length","draw","cancelAnimationFrame","add_neighbor_node","top","right","bottom","left","get_top_right_bottom_left","prev_node","filter","link_node_with_random_neighbor","random_num","getRandom","random_neighbor","array","n","min","max","random","run_solve_maze","find_path","solve_maze","quere_nodes","shift","check_neighbor_node","color","current_find_node","c_n","top_x","top_y","top_block","right_x","right_y","right_block","bottom_x","bottom_y","bottom_block","left_x","left_y","left_block"],"mappings":"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","sourcesContent":["import {Node} from './helper_method'\n\nlet size , width , height , cols , rows \n\nlet canvas , c \n\nlet nodes , block \n\nlet visited_nodes , stack \n\nlet quere , finish_path , nodes_path , path , current_node\n \nlet start_node, end_node \n\nlet myReq , myReqDraw\n\nconst setUp = (props) => {\n  c = props.c\n  canvas = props.canvas \n  canvas.width = width\n  canvas.height = height\n  nodes = []\n  visited_nodes = []\n  stack = []\n  quere = []\n  nodes_path = []\n  path = []\n  finish_path = false \n\n  cols = props.cols \n  rows = props.rows \n  size = props.size \n  width = size * cols \n  height = size * rows\n\n  draw_frims_maze()\n}\n\nconst draw_frims_maze = () => {\n  for(let i = 0; i < rows ; i ++){\n      for(let j = 0; j < cols ; j ++){\n          let x = j * size + (size / 2)\n          let y = i * size + (size / 2)\n          let node = new Node(x, y, c , size )\n\n          if(i === 0 && j === 0) {\n              node.walls[3] = false\n          }\n\n          if(j === cols - 1 && i === rows - 1){\n              node.walls[1] = false\n          }\n\n          if(i === 0 && j === 0){\n              stack.push(node)\n              visited_nodes.push(node)\n          }\n\n          nodes.push(node)\n      }\n  }\n\n  start_node = new Block(size / 2,size / 2, c , size, \"blue\")\n  quere.push(start_node)\n  end_node = new Block((cols - 1) * size + (size / 2),( rows - 1 ) * size + (size / 2) , c , size, \"green\")\n\n  setup_prims_maze(nodes, cols , rows)\n}\n\nlet neighbors_node = []\nlet visited_neighbors_node = []\nlet current_neighbor_node\n\nconst setup_prims_maze = (nodes_array , w , h) => {\n  let midd_x =  Math.floor(w / 2) * size + (size / 2)\n  let midd_y =  Math.floor(h / 2) * size + (size / 2)\n  let center_node = nodes_array.find(node => node.x === midd_x && node.y === midd_y)\n  neighbors_node.push(center_node)\n  visited_neighbors_node.push(center_node)\n  current_neighbor_node = center_node\n\n  draw_prims_maze()\n}\n\nconst draw_prims_maze = () => {\n  myReqDraw = requestAnimationFrame(draw_prims_maze)\n  c.clearRect(0,0,canvas.width, canvas.height)\n\n  for(let i = 0; i < nodes.length; i ++){\n      nodes[i].draw()\n  }\n\n  if(neighbors_node.length === 0){\n      cancelAnimationFrame(myReqDraw)\n  }\n\n  add_neighbor_node()\n}\n\nconst add_neighbor_node = () => {\n  let {x , y} = current_neighbor_node\n  \n  let {top , right , bottom , left} = get_top_right_bottom_left(current_neighbor_node , nodes) \n\n  if(\n      top \n      && !visited_neighbors_node.find(node => node.x === x && node.y === y - size)\n      && !neighbors_node.find(node => node.x === x && node.y === y - size)\n  ){\n      neighbors_node.push(top)\n      top.prev_node = current_neighbor_node\n  }\n\n  if(\n      right \n      && !visited_neighbors_node.find(node => node.x === x + size && node.y === y)\n      && !neighbors_node.find(node => node.x === x + size && node.y === y)\n  ){\n      neighbors_node.push(right)\n      right.prev_node = current_neighbor_node\n  }\n\n  if(\n      bottom \n      && !visited_neighbors_node.find(node => node.x === x && node.y === y + size)\n      && !neighbors_node.find(node => node.x === x && node.y === y + size)\n  ){\n      neighbors_node.push(bottom)\n      bottom.prev_node = current_neighbor_node\n  }\n\n  if(\n      left \n      && !visited_neighbors_node.find(node => node.x === x - size && node.y === y)\n      && !neighbors_node.find(node => node.x === x - size && node.y === y)\n  ){\n      neighbors_node.push(left)\n      left.prev_node = current_neighbor_node\n  }\n\n  neighbors_node = neighbors_node.filter(node => node.x === x && node.y === y ? false : true )\n\n  link_node_with_random_neighbor()\n}\n\nconst link_node_with_random_neighbor = () => {\n  if(neighbors_node.length === 0) return\n  let random_num = getRandom(0 , neighbors_node.length)\n  let random_neighbor = neighbors_node[random_num]\n  let {top , right , bottom , left} = get_top_right_bottom_left(random_neighbor,visited_neighbors_node)\n\n  if(top && top.x === random_neighbor.prev_node.x && top.y === random_neighbor.prev_node.y){\n      random_neighbor.walls[0] = false \n      top.walls[2] = false\n  }\n\n  if(right && right.x === random_neighbor.prev_node.x && right.y === random_neighbor.prev_node.y){\n      random_neighbor.walls[1] = false \n      right.walls[3] = false\n  }\n\n  if(bottom && bottom.x === random_neighbor.prev_node.x && bottom.y === random_neighbor.prev_node.y){\n      random_neighbor.walls[2] = false \n      bottom.walls[0] = false\n  }\n\n  if(left && left.x === random_neighbor.prev_node.x && left.y === random_neighbor.prev_node.y){\n      random_neighbor.walls[3] = false \n      left.walls[1] = false\n  }\n\n  current_neighbor_node = random_neighbor\n  visited_neighbors_node.push(random_neighbor)\n}\n\nconst get_top_right_bottom_left = (node , array ) => {\n  let {x , y} = node\n  let top = array.find(n => n.x === x && n.y === y - size)\n  let right = array.find(n => n.x === x + size && n.y === y)\n  let bottom = array.find(n => n.x === x && n.y === y + size)\n  let left = array.find(n => n.x === x - size && n.y === y)\n\n  return {top , right , bottom , left }\n}\n\nconst getRandom = (min,max) => {\n  return Math.floor(Math.random() * (max - min) + min)\n}\n\nconst run_solve_maze = () => {\n  myReq = requestAnimationFrame(run_solve_maze)\n  c.clearRect(0,0,canvas.width, canvas.height)\n\n  for(let i = 0; i < nodes.length; i ++){\n      nodes[i].draw()\n  }\n\n  for(let i = 0; i < nodes_path.length; i ++){\n      nodes_path[i].draw()\n  }\n\n  start_node.draw()\n  end_node.draw()\n  if(end_node.prev_node){\n      find_path()\n  }\n  if(finish_path){\n      cancelAnimationFrame(myReq)\n  }\n  if(!end_node.prev_node && !finish_path){\n      solve_maze()\n  }\n}\n\nconst solve_maze = () => {\n  let quere_nodes = [...quere]\n  quere.shift()\n  // visited_nodes_for_path.push(current_node)\n  if(end_node.prev_node){\n      return\n  }\n  for(let i = 0; i < quere_nodes.length ; i ++){\n      check_neighbor_node(quere_nodes[i])\n  }\n}\n\nconst check_neighbor_node = (node) => {\n  let x = node.x\n  let y = node.y\n  let color = \"MidnightBlue\"\n  let current_find_node = nodes.find(c_n => c_n.x === node.x && c_n.y === node.y )\n  // top \n  let top = nodes.find(n => n.x === x && n.y === y - size)\n  if(top && !current_find_node.walls[0] && !nodes_path.find(n => n.x === top.x && n.y === top.y)){\n      let top_x = top.x\n      let top_y = top.y\n      if(top_x === end_node.x && top_y === end_node.y){\n          end_node.prev_node = node \n          current_node = node \n          return \n      }else{\n          let top_block = new Block(top_x, top_y, color, node)\n          quere.push(top_block)\n          nodes_path.push(top_block)\n      }\n  }\n\n  // right\n  let right = nodes.find(n => n.x === x + size && n.y === y )\n  if(right && !current_find_node.walls[1] && !nodes_path.find(n => n.x === right.x  && n.y === right.y)){\n      let right_x = right.x \n      let right_y = right.y \n      if(right_x === end_node.x && right_y === end_node.y){\n          end_node.prev_node = node \n          current_node = node \n          return \n      }else{\n          let right_block = new Block(right_x, right_y, color ,node)\n          quere.push(right_block)\n          nodes_path.push(right_block)\n      }\n  }\n\n  // bottom\n  let bottom = nodes.find(n => n.x === x && n.y === y + size ) \n  if(bottom && !current_find_node.walls[2] && !nodes_path.find(n => n.x === bottom.x  && n.y === bottom.y )){\n      let bottom_x = bottom.x \n      let bottom_y = bottom.y \n      if(bottom_x === end_node.x && bottom_y === end_node.y){\n          end_node.prev_node = node \n          current_node = node \n          return \n      }else{\n          let bottom_block = new Block(bottom_x, bottom_y, color ,node)\n          quere.push(bottom_block)\n          nodes_path.push(bottom_block)\n      }\n  }\n\n  // left \n  let left = nodes.find(n => n.x === x - size && n.y === y)\n  if(left && !current_find_node.walls[3] && !nodes_path.find(n => n.x === left.x && n.y === left.y)){\n      let left_x = left.x \n      let left_y = left.y \n      if(left_x === end_node.x && left_y === end_node.y){\n          end_node.prev_node = node \n          current_node = node \n          return \n      }else{\n          let left_block = new Block(left_x,left_y, color , node)\n          quere.push(left_block)\n          nodes_path.push(left_block)\n      }\n  }\n\n}\n\nconst find_path = () => {\n  current_node.color = \"green\"\n  if(current_node.x === start_node.x && current_node.y === start_node.y){\n      finish_path = true\n      return\n  }\n  current_node = current_node.prev_node\n}\n\nexport {setUp , run_solve_maze}\n"]},"metadata":{},"sourceType":"module"}