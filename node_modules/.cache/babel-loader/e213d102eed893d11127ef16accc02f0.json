{"ast":null,"code":"import { Block } from '../helper_method';\nlet c, canvas, size, nodes, start_node, end_node;\nlet visited_nodes, quere, current_node, finish_path, myReq;\n\nconst breadth_first_search = props => {\n  c = props.c;\n  canvas = props.canvas;\n  size = props.size;\n  visited_nodes = [];\n  nodes = props.nodes;\n  quere = [];\n  finish_path = false;\n  current_node = null;\n  start_node = props.start_node;\n  end_node = props.end_node;\n  end_node.prev_node = null;\n  quere.push(start_node);\n  cancelAnimationFrame(myReq);\n  run_solve_maze();\n};\n\nconst stop_breadth_first_search = () => {\n  cancelAnimationFrame(myReq);\n};\n\nconst run_solve_maze = () => {\n  myReq = requestAnimationFrame(run_solve_maze);\n  c.clearRect(0, 0, canvas.width, canvas.height);\n\n  for (let i = 0; i < nodes.length; i++) {\n    nodes[i].draw();\n  }\n\n  for (let i = 0; i < visited_nodes.length; i++) {\n    visited_nodes[i].draw();\n  }\n\n  start_node.draw();\n  end_node.draw();\n\n  if (end_node.prev_node) {\n    find_path();\n  }\n\n  if (finish_path) {\n    cancelAnimationFrame(myReq);\n  }\n\n  if (!end_node.prev_node && !finish_path) {\n    solve_maze();\n  }\n};\n\nconst solve_maze = () => {\n  let quere_nodes = [...quere];\n  quere.shift(); // visited_nodes_for_path.push(current_node)\n\n  if (end_node.prev_node) {\n    return;\n  }\n\n  for (let i = 0; i < quere_nodes.length; i++) {\n    check_neighbor_node(quere_nodes[i]);\n  }\n};\n\nconst check_neighbor_node = node => {\n  let x = node.x;\n  let y = node.y;\n  let color = \"MidnightBlue\";\n  let current_find_node = nodes.find(c_n => c_n.x === node.x && c_n.y === node.y); // top \n\n  let top = nodes.find(n => n.x === x && n.y === y - size);\n  add_node(top, node, 0, current_find_node); // if(top && !current_find_node.walls[0] && !visited_nodes.find(n => n.x === top.x && n.y === top.y)){\n  //     let top_x = top.x\n  //     let top_y = top.y\n  //     if(top_x === end_node.x && top_y === end_node.y){\n  //         end_node.prev_node = node \n  //         current_node = node \n  //         return \n  //     }else{\n  //         let top_block = new Block(top_x, top_y , c , size , color, node)\n  //         quere.push(top_block)\n  //         visited_nodes.push(top_block)\n  //     }\n  // }\n  // right\n\n  let right = nodes.find(n => n.x === x + size && n.y === y);\n  add_node(right, node, 1, current_find_node); // if(right && !current_find_node.walls[1] && !visited_nodes.find(n => n.x === right.x  && n.y === right.y)){\n  //     let right_x = right.x \n  //     let right_y = right.y \n  //     if(right_x === end_node.x && right_y === end_node.y){\n  //         end_node.prev_node = node \n  //         current_node = node \n  //         return \n  //     }else{\n  //         let right_block = new Block(right_x, right_y, c , size , color ,node)\n  //         quere.push(right_block)\n  //         visited_nodes.push(right_block)\n  //     }\n  // }\n  // bottom\n\n  let bottom = nodes.find(n => n.x === x && n.y === y + size);\n  add_node(bottom, node, 2, current_find_node); // if(bottom && !current_find_node.walls[2] && !visited_nodes.find(n => n.x === bottom.x  && n.y === bottom.y )){\n  //     let bottom_x = bottom.x \n  //     let bottom_y = bottom.y \n  //     if(bottom_x === end_node.x && bottom_y === end_node.y){\n  //         end_node.prev_node = node \n  //         current_node = node \n  //         return \n  //     }else{\n  //         let bottom_block = new Block(bottom_x, bottom_y, c , size ,color ,node)\n  //         quere.push(bottom_block)\n  //         visited_nodes.push(bottom_block)\n  //     }\n  // }\n  // left \n\n  let left = nodes.find(n => n.x === x - size && n.y === y);\n  add_node(left, node, 3, current_find_node); // if(left && !current_find_node.walls[3] && !visited_nodes.find(n => n.x === left.x && n.y === left.y)){\n  //     let left_x = left.x \n  //     let left_y = left.y \n  //     if(left_x === end_node.x && left_y === end_node.y){\n  //         end_node.prev_node = node \n  //         current_node = node \n  //         return \n  //     }else{\n  //         let left_block = new Block(left_x,left_y, c, size , color , node)\n  //         quere.push(left_block)\n  //         visited_nodes.push(left_block)\n  //     }\n  // }\n};\n\nconst add_node = (neighbor_node, node, wall_num, current_find_node) => {\n  let color = \"MidnightBlue\";\n  let {\n    x,\n    y\n  } = neighbor_node;\n\n  if (neighbor_node && !current_find_node.walls[wall_num] && !visited_nodes.find(n => n.x === x && n.y === y)) {\n    if (x === end_node.x && y === end_node.y) {\n      end_node.prev_node = node;\n      current_node = node;\n    } else {\n      let new_block = new Block(x, y, c, size, color, node);\n      quere.push(new_block);\n      visited_nodes.push(new_block);\n    }\n  }\n\n  return;\n};\n\nconst find_path = () => {\n  current_node.color = \"green\";\n\n  if (current_node.x === start_node.x && current_node.y === start_node.y) {\n    finish_path = true;\n    return;\n  }\n\n  current_node = current_node.prev_node;\n};\n\nexport { breadth_first_search, stop_breadth_first_search };","map":{"version":3,"sources":["/Users/vienpham/Desktop/Algorithms_simulation/algorithms/src/Algorithms/solve_maze/breadth_first_search.js"],"names":["Block","c","canvas","size","nodes","start_node","end_node","visited_nodes","quere","current_node","finish_path","myReq","breadth_first_search","props","prev_node","push","cancelAnimationFrame","run_solve_maze","stop_breadth_first_search","requestAnimationFrame","clearRect","width","height","i","length","draw","find_path","solve_maze","quere_nodes","shift","check_neighbor_node","node","x","y","color","current_find_node","find","c_n","top","n","add_node","right","bottom","left","neighbor_node","wall_num","walls","new_block"],"mappings":"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","sourcesContent":["import {Block} from '../helper_method'\nlet c , canvas , size , nodes , start_node , end_node \n    \nlet visited_nodes ,  quere , current_node , finish_path , myReq\n\nconst breadth_first_search = (props) => {\n    c = props.c\n    canvas = props.canvas \n    size = props.size \n    visited_nodes = []\n    nodes = props.nodes \n\n    quere = []\n    finish_path = false \n    current_node = null  \n    start_node = props.start_node\n    end_node = props.end_node\n\n    end_node.prev_node = null\n\n    quere.push(start_node)\n    cancelAnimationFrame(myReq)\n    run_solve_maze()\n}\n\nconst stop_breadth_first_search = () => {\n    cancelAnimationFrame(myReq)\n}\n\nconst run_solve_maze = () => {\n    myReq = requestAnimationFrame(run_solve_maze)\n    c.clearRect(0,0,canvas.width, canvas.height)\n\n    for(let i = 0; i < nodes.length; i ++){\n        nodes[i].draw()\n    }\n\n    for(let i = 0; i < visited_nodes.length; i ++){\n        visited_nodes[i].draw()\n    }\n\n    start_node.draw()\n    end_node.draw()\n    if(end_node.prev_node){\n        find_path()\n    }\n    if(finish_path){\n        cancelAnimationFrame(myReq)\n    }\n    if(!end_node.prev_node && !finish_path){\n        solve_maze()\n    }\n}\n  \nconst solve_maze = () => {\n    let quere_nodes = [...quere]\n    quere.shift()\n    // visited_nodes_for_path.push(current_node)\n    if(end_node.prev_node){\n        return\n    }\n    for(let i = 0; i < quere_nodes.length ; i ++){\n        check_neighbor_node(quere_nodes[i])\n    }\n}\n  \nconst check_neighbor_node = (node) => {\n    let x = node.x\n    let y = node.y\n    let color = \"MidnightBlue\"\n    let current_find_node = nodes.find(c_n => c_n.x === node.x && c_n.y === node.y )\n    // top \n    let top = nodes.find(n => n.x === x && n.y === y - size)\n    add_node(top , node , 0 , current_find_node)\n    // if(top && !current_find_node.walls[0] && !visited_nodes.find(n => n.x === top.x && n.y === top.y)){\n    //     let top_x = top.x\n    //     let top_y = top.y\n    //     if(top_x === end_node.x && top_y === end_node.y){\n    //         end_node.prev_node = node \n    //         current_node = node \n    //         return \n    //     }else{\n    //         let top_block = new Block(top_x, top_y , c , size , color, node)\n    //         quere.push(top_block)\n    //         visited_nodes.push(top_block)\n    //     }\n    // }\n\n    // right\n    let right = nodes.find(n => n.x === x + size && n.y === y )\n    add_node(right , node , 1 , current_find_node)\n    // if(right && !current_find_node.walls[1] && !visited_nodes.find(n => n.x === right.x  && n.y === right.y)){\n    //     let right_x = right.x \n    //     let right_y = right.y \n    //     if(right_x === end_node.x && right_y === end_node.y){\n    //         end_node.prev_node = node \n    //         current_node = node \n    //         return \n    //     }else{\n    //         let right_block = new Block(right_x, right_y, c , size , color ,node)\n    //         quere.push(right_block)\n    //         visited_nodes.push(right_block)\n    //     }\n    // }\n\n    // bottom\n    let bottom = nodes.find(n => n.x === x && n.y === y + size ) \n    add_node(bottom , node , 2 , current_find_node)\n    // if(bottom && !current_find_node.walls[2] && !visited_nodes.find(n => n.x === bottom.x  && n.y === bottom.y )){\n    //     let bottom_x = bottom.x \n    //     let bottom_y = bottom.y \n    //     if(bottom_x === end_node.x && bottom_y === end_node.y){\n    //         end_node.prev_node = node \n    //         current_node = node \n    //         return \n    //     }else{\n    //         let bottom_block = new Block(bottom_x, bottom_y, c , size ,color ,node)\n    //         quere.push(bottom_block)\n    //         visited_nodes.push(bottom_block)\n    //     }\n    // }\n\n    // left \n    let left = nodes.find(n => n.x === x - size && n.y === y)\n    add_node(left , node , 3 , current_find_node)\n    // if(left && !current_find_node.walls[3] && !visited_nodes.find(n => n.x === left.x && n.y === left.y)){\n    //     let left_x = left.x \n    //     let left_y = left.y \n    //     if(left_x === end_node.x && left_y === end_node.y){\n    //         end_node.prev_node = node \n    //         current_node = node \n    //         return \n    //     }else{\n    //         let left_block = new Block(left_x,left_y, c, size , color , node)\n    //         quere.push(left_block)\n    //         visited_nodes.push(left_block)\n    //     }\n    // }\n}\n\nconst add_node = (neighbor_node , node , wall_num , current_find_node) => {\n    let color = \"MidnightBlue\"\n    let {x , y} = neighbor_node\n    if(neighbor_node && !current_find_node.walls[wall_num] && !visited_nodes.find(n => n.x === x && n.y === y)){\n        if(x === end_node.x && y === end_node.y){\n            end_node.prev_node = node \n            current_node = node \n        }else{\n            let new_block = new Block(x, y , c , size , color, node)\n            quere.push(new_block)\n            visited_nodes.push(new_block)\n        }\n    }\n    return \n}\n  \nconst find_path = () => {\n    current_node.color = \"green\"\n    if(current_node.x === start_node.x && current_node.y === start_node.y){\n        finish_path = true\n        return\n    }\n    current_node = current_node.prev_node\n}\n\nexport { breadth_first_search ,  stop_breadth_first_search}\n\n"]},"metadata":{},"sourceType":"module"}