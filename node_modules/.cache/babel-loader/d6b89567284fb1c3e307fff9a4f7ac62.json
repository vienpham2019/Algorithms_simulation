{"ast":null,"code":"import { Node, Block } from './helper_method';\nimport { breadth_first_search, stop_breadth_first_search } from './solve_maze/breadth_first_search';\nimport { depth_first_search, stop_depth_first_search } from './solve_maze/depth_first_search';\nimport { a_star, stop_a_star } from './solve_maze/a_star';\nimport { greedy_best_first_search, stop_greedy_best_first_search } from './solve_maze/greedy_best_first_search';\nimport { dijkstra, stop_dijkstra } from './solve_maze/dijkstra';\nimport { bidirectional_dijkstra, stop_bidirectional_dijkstra } from './solve_maze/bidirectional_dijkstra';\nimport { bidirectional_a_star, stop_bidirectional_a_star } from './solve_maze/bidirectional_a_star';\nimport { recursive_dividion_maze } from './draw_maze/recursive_division_maze_generation';\nimport { prims_maze, stop_prims_draw_maze } from './draw_maze/prims_maze_generation';\nimport { depth_first_search_maze, stop_depth_first_search_draw_maze } from './draw_maze/depth_first_search_maze_generation';\nimport { grid, stop_grid } from './draw_maze/grid';\nlet size, width, height, cols, rows, draw_maze, select_draw_algorithims, speed;\nlet delay, canvas, c, start_node, end_node, nodes, stack, frame_per_second, maze_speed, myTimeOut, start_location, end_location;\n\nconst setUp = props => {\n  stop_breadth_first_search();\n  stop_depth_first_search();\n  stop_a_star();\n  stop_dijkstra();\n  stop_bidirectional_dijkstra();\n  stop_greedy_best_first_search();\n  stop_bidirectional_a_star();\n  stop_depth_first_search_draw_maze();\n  stop_prims_draw_maze();\n  stop_grid();\n  c = props.c;\n  canvas = props.canvas;\n  stack = [];\n  cols = props.cols;\n  rows = props.rows;\n  size = props.size;\n  draw_maze = props.draw_maze;\n  width = props.width;\n  height = props.height;\n  select_draw_algorithims = props.select_draw_algorithims;\n  start_location = {\n    x: size / 2,\n    y: size / 2\n  };\n  end_location = {\n    x: (cols - 1) * size + size / 2,\n    y: (rows - 1) * size + size / 2\n  };\n  size = Math.floor(width / cols);\n  delay = 0;\n  speed = props.speed;\n  maze_speed = 700;\n  frame_per_second = 1000;\n  canvas.width = width;\n  canvas.height = height;\n  nodes = [];\n  draw_divide_maze(props);\n  clearTimeout(myTimeOut);\n  return nodes;\n};\n\nconst draw_divide_maze = props => {\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      let walls = select_draw_algorithims === \"Recursive Division\" ? [false, false, false, false] : [true, true, true, true];\n      let x = j * size + size / 2;\n      let y = i * size + size / 2;\n      let node = new Node(x, y, c, size, walls);\n\n      if (draw_maze) {\n        if (i === 0) {\n          node.walls[0] = true;\n        } else if (i === rows - 1) {\n          node.walls[2] = true;\n        }\n\n        if (j === 0) {\n          node.walls[3] = true;\n        } else if (j === cols - 1) {\n          node.walls[1] = true;\n        }\n\n        if (i === 0 && j === 0) {\n          node.walls[0] = false;\n        }\n\n        if (j === cols - 1 && i === rows - 1) {\n          node.walls[1] = false;\n        }\n      }\n\n      if (i === 0 && j === 0) {\n        stack.push(node);\n      }\n\n      nodes.push(node);\n    }\n  }\n\n  console.log(start_location.x, start_location.y);\n  start_node = new Block(size / 2, size / 2, c, size, \"blue\");\n  end_node = new Block((cols - 1) * size + size / 2, (rows - 1) * size + size / 2, c, size, \"green\");\n\n  switch (select_draw_algorithims) {\n    case \"Depth first search\":\n      depth_first_search_maze({\n        nodes,\n        canvas,\n        c,\n        stack,\n        size,\n        cols,\n        rows,\n        frame_per_second,\n        speed\n      });\n      break;\n\n    case \"Prim's\":\n      prims_maze({\n        size,\n        nodes,\n        cols,\n        rows,\n        canvas,\n        c,\n        frame_per_second,\n        speed\n      });\n      break;\n\n    case \"Recursive Division\":\n      let draw_delay = recursive_dividion_maze({\n        delay,\n        speed,\n        size,\n        cols,\n        rows,\n        nodes\n      });\n\n      if (draw_delay) {\n        setTimeout(() => {\n          props.check_recursive_delay(true);\n        }, draw_delay * speed);\n      }\n\n      break;\n\n    default:\n      grid({\n        size,\n        nodes,\n        cols,\n        rows,\n        canvas,\n        c\n      });\n      break;\n  }\n};\n\nconst run_solve_maze = algorithms => {\n  stop_greedy_best_first_search();\n  stop_a_star();\n  stop_dijkstra();\n  stop_breadth_first_search();\n  stop_depth_first_search();\n  stop_bidirectional_dijkstra();\n  stop_bidirectional_a_star(); // stop_grid()\n\n  switch (algorithms) {\n    case \"A star\":\n      a_star({\n        start_node,\n        end_node,\n        nodes,\n        c,\n        canvas,\n        size\n      });\n      break;\n\n    case \"Depth first search\":\n      depth_first_search({\n        nodes,\n        start_node,\n        end_node,\n        c,\n        canvas,\n        size\n      });\n      break;\n\n    case \"Breadth first search\":\n      breadth_first_search({\n        c,\n        canvas,\n        size,\n        nodes,\n        start_node,\n        end_node\n      });\n      break;\n\n    case \"Dijkstra's\":\n      dijkstra({\n        start_node,\n        end_node,\n        nodes,\n        c,\n        canvas,\n        size\n      });\n      break;\n\n    case \"Greedy best first search\":\n      greedy_best_first_search({\n        start_node,\n        end_node,\n        nodes,\n        c,\n        canvas,\n        size\n      });\n      break;\n\n    case \"Bidirectional a star\":\n      bidirectional_a_star({\n        start_node,\n        end_node,\n        nodes,\n        c,\n        canvas,\n        size\n      });\n      break;\n\n    case \"Bidirectional dijkstra's\":\n      bidirectional_dijkstra({\n        start_node,\n        end_node,\n        nodes,\n        c,\n        canvas,\n        size\n      });\n      break;\n  }\n};\n\nconst update_info = props => {\n  start_location = props.start_location;\n  end_location = props.end_location;\n};\n\nexport { setUp, run_solve_maze, update_info };","map":{"version":3,"sources":["/Users/vienpham/Desktop/Algorithms_simulation/algorithms/src/Algorithms/mazeController.js"],"names":["Node","Block","breadth_first_search","stop_breadth_first_search","depth_first_search","stop_depth_first_search","a_star","stop_a_star","greedy_best_first_search","stop_greedy_best_first_search","dijkstra","stop_dijkstra","bidirectional_dijkstra","stop_bidirectional_dijkstra","bidirectional_a_star","stop_bidirectional_a_star","recursive_dividion_maze","prims_maze","stop_prims_draw_maze","depth_first_search_maze","stop_depth_first_search_draw_maze","grid","stop_grid","size","width","height","cols","rows","draw_maze","select_draw_algorithims","speed","delay","canvas","c","start_node","end_node","nodes","stack","frame_per_second","maze_speed","myTimeOut","start_location","end_location","setUp","props","x","y","Math","floor","draw_divide_maze","clearTimeout","i","j","walls","node","push","console","log","draw_delay","setTimeout","check_recursive_delay","run_solve_maze","algorithms","update_info"],"mappings":"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","sourcesContent":["import { Node , Block } from './helper_method'\nimport { breadth_first_search , stop_breadth_first_search }from './solve_maze/breadth_first_search'\nimport { depth_first_search , stop_depth_first_search }from './solve_maze/depth_first_search'\nimport { a_star , stop_a_star }from './solve_maze/a_star'\nimport { greedy_best_first_search , stop_greedy_best_first_search }from './solve_maze/greedy_best_first_search'\nimport { dijkstra , stop_dijkstra }from './solve_maze/dijkstra'\nimport { bidirectional_dijkstra , stop_bidirectional_dijkstra }from './solve_maze/bidirectional_dijkstra'\nimport { bidirectional_a_star , stop_bidirectional_a_star }from './solve_maze/bidirectional_a_star'\n\nimport { recursive_dividion_maze } from './draw_maze/recursive_division_maze_generation'\nimport { prims_maze , stop_prims_draw_maze} from './draw_maze/prims_maze_generation'\nimport { depth_first_search_maze , stop_depth_first_search_draw_maze } from './draw_maze/depth_first_search_maze_generation'\nimport { grid , stop_grid} from './draw_maze/grid'\n\nlet size , width , height , cols , rows , draw_maze , select_draw_algorithims , speed \n\nlet delay, canvas , c , start_node, end_node , nodes , stack , frame_per_second , maze_speed , myTimeOut , start_location , end_location \n\nconst setUp = (props) => {\n  stop_breadth_first_search()\n  stop_depth_first_search()\n  stop_a_star()\n  stop_dijkstra()\n  stop_bidirectional_dijkstra()\n  stop_greedy_best_first_search()\n  stop_bidirectional_a_star()\n\n  stop_depth_first_search_draw_maze()\n  stop_prims_draw_maze()\n  stop_grid()\n\n  c = props.c\n  canvas = props.canvas \n  stack = []\n\n  cols = props.cols \n  rows = props.rows \n  size = props.size \n  draw_maze = props.draw_maze\n  width = props.width\n  height = props.height\n  select_draw_algorithims = props.select_draw_algorithims\n\n  start_location = {x: size / 2 , y: size / 2}\n  end_location = {x: (cols - 1) * size + (size / 2) , y: (rows - 1) * size + (size / 2)}\n\n  size = Math.floor(width / cols)\n\n  delay = 0 \n  speed = props.speed\n  maze_speed = 700\n\n  frame_per_second = 1000\n\n  canvas.width = width\n  canvas.height = height\n\n  nodes = []\n  draw_divide_maze(props)\n  clearTimeout(myTimeOut)\n  return nodes\n}\n\nconst draw_divide_maze = (props) => {\n  for(let i = 0; i < rows ; i ++){\n    for(let j = 0; j < cols ; j ++){\n      let walls = select_draw_algorithims === \"Recursive Division\"\n        ? [false , false , false ,false] \n        : [true , true , true , true]\n\n      let x = j * size + (size / 2)\n      let y = i * size + (size / 2)\n      let node = new Node(x, y , c , size , walls)\n      if(draw_maze){\n        if(i === 0){\n          node.walls[0] = true\n        }else if(i === rows - 1){\n          node.walls[2] = true\n        }\n\n        if(j === 0){\n          node.walls[3] = true\n        }else if(j === cols - 1){\n          node.walls[1] = true\n        }\n\n        if(i === 0 && j === 0) {\n            node.walls[0] = false \n        }\n        if(j === cols - 1 && i === rows - 1){\n          node.walls[1] = false\n        }\n      }\n\n      if(i === 0 && j === 0){\n          stack.push(node)\n      }\n      nodes.push(node)\n    }\n  }\n\n  console.log(start_location.x , start_location.y)\n\n  start_node = new Block((size / 2) ,(size / 2) , c , size , \"blue\")\n  end_node = new Block((cols - 1) * size + (size / 2) ,( rows - 1 ) * size + (size / 2) , c , size , \"green\" )\n\n  switch (select_draw_algorithims) {\n    case \"Depth first search\":\n      depth_first_search_maze({nodes , canvas , c , stack , size , cols , rows , frame_per_second , speed })\n      break\n    case \"Prim's\": \n      prims_maze({size , nodes , cols , rows , canvas , c , frame_per_second , speed})\n      break \n    case \"Recursive Division\": \n      let draw_delay = recursive_dividion_maze({delay , speed , size , cols , rows , nodes})\n      if(draw_delay){\n        setTimeout(() => {\n            props.check_recursive_delay(true)\n          }, draw_delay * speed);\n        }\n      break \n    default:\n      grid({size , nodes , cols , rows , canvas , c})\n      break \n  }\n}\n\nconst run_solve_maze = (algorithms) => {\n  stop_greedy_best_first_search()\n  stop_a_star()\n  stop_dijkstra()\n  stop_breadth_first_search()\n  stop_depth_first_search()\n  stop_bidirectional_dijkstra()\n  stop_bidirectional_a_star()\n\n  // stop_grid()\n\n  switch (algorithms) {\n    case \"A star\":\n      a_star({start_node , end_node , nodes , c , canvas , size})\n      break\n    case \"Depth first search\": \n      depth_first_search({nodes , start_node , end_node , c , canvas , size})\n      break\n    case \"Breadth first search\": \n      breadth_first_search({c , canvas , size , nodes , start_node , end_node })\n      break \n    case \"Dijkstra's\": \n      dijkstra({start_node , end_node , nodes , c , canvas , size})\n      break \n    case \"Greedy best first search\": \n      greedy_best_first_search({start_node , end_node , nodes , c , canvas , size})\n      break \n    case \"Bidirectional a star\": \n      bidirectional_a_star({start_node , end_node , nodes , c , canvas , size})\n      break \n    case \"Bidirectional dijkstra's\": \n      bidirectional_dijkstra({start_node , end_node , nodes , c , canvas , size})\n      break \n  }\n}\n\nconst update_info = props => {\n  start_location = props.start_location\n  end_location = props.end_location\n}\n\nexport {setUp , run_solve_maze , update_info}\n"]},"metadata":{},"sourceType":"module"}