{"ast":null,"code":"let path = [];\n\nfunction merge_sort(array) {\n  if (array.length === 1) return array;\n  const midd = Math.floor(array.length / 2);\n  const left_arr = array.slice(0, midd);\n  const right_arr = array.slice(midd, array.length);\n  return merge(merge_sort(left_arr), merge_sort(right_arr));\n}\n\nconst merge = (left_array, right_array) => {\n  let sort_array = [];\n\n  while (left_array.length && right_array.length) {\n    if (left_array[0].height < right_array[0].height) {\n      let left_node = left_array[0];\n      let {\n        min_index,\n        min_left_node,\n        min_right_node\n      } = find_min_node(left_array);\n\n      if (left_node.index !== min_index) {\n        if (min_left_node) {\n          min_left_node.index = left_node.index;\n        } else {\n          min_right_node.index = left_node.index;\n        }\n\n        left_node.index = min_index;\n      }\n\n      path.push(left_node);\n      sort_array.push(left_array.shift());\n    } else {\n      let right_node = right_array[0];\n      let {\n        min_index,\n        min_left_node,\n        min_right_node\n      } = find_min_node(right_array);\n\n      if (right_node.index !== min_index) {\n        if (min_left_node) {\n          min_left_node.index = right_node.index;\n        } else {\n          min_right_node.index = right_node.index;\n        }\n\n        right_node.index = min_index;\n      }\n\n      path.push(right_node);\n      sort_array.push(right_array.shift());\n    }\n  }\n\n  while (left_array.length) {\n    let left_n = left_array[0];\n    let {\n      min_index,\n      min_left_node,\n      min_right_node\n    } = find_min_node(left_array);\n\n    if (left_n.index !== min_index) {\n      if (min_left_node) {\n        min_left_node.index = left_n.index;\n      } else {\n        min_right_node.index = left_n.index;\n      }\n\n      left_n.index = min_index;\n    }\n\n    path.push(left_n);\n    sort_array.push(left_array.shift());\n  }\n\n  while (right_array.length) {\n    let right_n = right_array[0];\n    let {\n      min_index,\n      min_right_node,\n      min_left_node\n    } = find_min_node(right_array);\n\n    if (right_n.index !== min_index) {\n      if (min_left_node) {\n        min_left_node.index = right_n.index;\n      } else {\n        min_right_node.index = right_n.index;\n      }\n\n      right_n.index = min_index;\n    }\n\n    path.push(right_n);\n    sort_array.push(right_array.shift());\n  }\n\n  return sort_array;\n};\n\nconst find_min_node = (left_array, right_array = []) => {\n  let com_arr = [...left_array, ...right_array];\n  let min_index = Math.min(...com_arr.map(element => element.index));\n  let min_left_node = left_array.find(element => element.index === min_index);\n  let min_right_node = right_array.find(element => element.index === min_index);\n  return {\n    min_index,\n    min_left_node,\n    min_right_node\n  };\n};\n\nconst solve_array = array => {\n  let answer = merge_sort(array);\n  if (answer) return path;\n};\n\nexport default solve_array;","map":{"version":3,"sources":["/Users/vienpham/Desktop/Algorithms_simulation/algorithms/src/Algorithms/mergeSort.js"],"names":["path","merge_sort","array","length","midd","Math","floor","left_arr","slice","right_arr","merge","left_array","right_array","sort_array","height","left_node","min_index","min_left_node","min_right_node","find_min_node","index","push","shift","right_node","left_n","right_n","com_arr","min","map","element","find","solve_array","answer"],"mappings":"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","sourcesContent":["let path = []\n\nfunction merge_sort(array){\n  if(array.length === 1) return array \n\n  const midd = Math.floor(array.length / 2)\n  const left_arr = array.slice(0,midd)\n  const right_arr = array.slice(midd, array.length)\n\n  return merge(merge_sort(left_arr), merge_sort(right_arr))\n}\n\nconst merge = (left_array, right_array) => {\n  let sort_array = []\n\n  while(left_array.length && right_array.length){\n    if(left_array[0].height < right_array[0].height){\n        let left_node = left_array[0]\n        let {min_index, min_left_node , min_right_node} = find_min_node(left_array)\n      if(left_node.index !== min_index){\n        if(min_left_node){\n          min_left_node.index = left_node.index\n        }else{\n          min_right_node.index = left_node.index\n        }\n        left_node.index = min_index\n      }\n      path.push(left_node)\n      sort_array.push(left_array.shift())\n    }else{\n      let right_node = right_array[0]\n      let {min_index, min_left_node , min_right_node} = find_min_node(right_array)\n      if(right_node.index !== min_index){\n        if(min_left_node){\n          min_left_node.index = right_node.index\n        }else{\n          min_right_node.index = right_node.index\n        }\n        right_node.index = min_index\n      }\n      path.push(right_node)\n      sort_array.push(right_array.shift())\n    }\n  }\n\n  while(left_array.length) {\n    let left_n = left_array[0]\n    let {min_index, min_left_node , min_right_node} = find_min_node(left_array)\n    if(left_n.index !== min_index){\n      if(min_left_node){\n        min_left_node.index = left_n.index\n      }else{\n        min_right_node.index = left_n.index\n      }\n      left_n.index = min_index\n    }\n    path.push(left_n)\n    sort_array.push(left_array.shift())\n  }\n  while(right_array.length) {\n    let right_n = right_array[0]\n    let {min_index, min_right_node , min_left_node } = find_min_node(right_array)\n    if(right_n.index !== min_index){\n      if(min_left_node){\n        min_left_node.index = right_n.index\n      }else{\n        min_right_node.index = right_n.index\n      }\n      right_n.index = min_index\n    }\n    path.push(right_n)\n    sort_array.push(right_array.shift())\n  }\n  return sort_array\n}\n\nconst find_min_node = (left_array,right_array = []) => {\n  let com_arr = [...left_array,...right_array]\n  let min_index =  Math.min(...com_arr.map(element => element.index))\n\n  let min_left_node = left_array.find(element => element.index === min_index)\n\n  let min_right_node = right_array.find(element => element.index === min_index)\n\n  return {min_index, min_left_node , min_right_node}\n}\n\nconst solve_array = array => {\n  let answer = merge_sort(array)\n  if(answer) return path\n}\n\nexport default solve_array"]},"metadata":{},"sourceType":"module"}