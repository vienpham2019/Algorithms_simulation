{"ast":null,"code":"let delay, speed, size, cols, rows, nodes;\n\nconst recursive_dividion_maze = props => {\n  delay = props.delay;\n  speed = props.speed;\n  size = props.size;\n  cols = props.cols;\n  rows = props.rows;\n  nodes = props.nodes;\n  return draw_maze(nodes, cols, rows, 0, 0, delay, speed, size);\n};\n\nconst draw_maze = (nodes_array, x_max, y_max, x_min, y_min) => {\n  if (x_max - x_min < 1 || y_max - y_min < 1) return;\n  let random_x = getRandom(x_min, x_max);\n  let random_y = getRandom(y_min, y_max);\n  let x_or_y = getRandom(-20, 20);\n  delay++;\n  setTimeout(() => {\n    for (let i = 0; i < nodes_array.length; i++) {\n      if (x_or_y > 0) {\n        // x\n        if (nodes_array[i].x === random_x * size + size / 2 && nodes_array[i].y <= y_max * size + size / 2 && nodes_array[i].y >= y_min * size + size / 2 && nodes_array[i].x !== (cols - 1) * size + size / 2) {\n          if (nodes_array[i].y !== random_y * size + size / 2) {\n            nodes_array[i].walls[1] = true;\n            let {\n              x,\n              y\n            } = nodes_array[i];\n            let neightbor_node = nodes_array.find(node => node.x === x + size && node.y === y);\n\n            if (neightbor_node) {\n              neightbor_node.walls[3] = true;\n            }\n          }\n        }\n      } else {\n        if (nodes_array[i].y === random_y * size + size / 2 && nodes_array[i].x <= x_max * size + size / 2 && nodes_array[i].x >= x_min * size + size / 2) {\n          if (nodes_array[i].x !== random_x * size + size / 2) {\n            nodes_array[i].walls[2] = true;\n            let {\n              x,\n              y\n            } = nodes_array[i];\n            let neightbor_node = nodes_array.find(node => node.x === x && node.y === y + size);\n\n            if (neightbor_node) {\n              neightbor_node.walls[0] = true;\n            }\n          }\n        }\n      }\n\n      nodes_array[i].draw();\n    }\n  }, delay * speed);\n\n  if (x_or_y > 0) {\n    draw_maze(nodes_array, random_x, y_max, x_min, y_min); // right \n\n    draw_maze(nodes_array, x_max, y_max, random_x + 1, y_min); // left \n  } else {\n    draw_maze(nodes_array, x_max, random_y, x_min, y_min); // top \n\n    draw_maze(nodes_array, x_max, y_max, x_min, random_y + 1); // bottom\n  }\n\n  return delay;\n};\n\nconst getRandom = (min, max) => {\n  return Math.floor(Math.random() * (max - min) + min);\n};\n\nexport { recursive_dividion_maze };","map":{"version":3,"sources":["/Users/vienpham/Desktop/Algorithms_simulation/algorithms/src/Algorithms/draw_maze/recursive_division_maze_generation.js"],"names":["delay","speed","size","cols","rows","nodes","recursive_dividion_maze","props","draw_maze","nodes_array","x_max","y_max","x_min","y_min","random_x","getRandom","random_y","x_or_y","setTimeout","i","length","x","y","walls","neightbor_node","find","node","draw","min","max","Math","floor","random"],"mappings":"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","sourcesContent":["let delay , speed , size , cols , rows , nodes\n\nconst recursive_dividion_maze = (props) => {\n    delay = props.delay\n    speed = props.speed \n    size = props.size \n    cols = props.cols \n    rows = props.rows\n    nodes = props.nodes\n\n    return draw_maze(nodes , cols , rows , 0, 0 , delay , speed , size)\n}\n\nconst draw_maze = (nodes_array , x_max, y_max, x_min , y_min) => {\n\n    if(x_max - x_min < 1 || y_max - y_min < 1) return\n  \n    let random_x = getRandom(x_min,x_max)\n    let random_y = getRandom(y_min,y_max)\n    let x_or_y = getRandom(-20, 20) \n  \n    delay ++\n  \n    setTimeout(() => {\n      for(let i = 0; i < nodes_array.length; i ++){\n          if(x_or_y > 0) { // x\n              if (\n                  nodes_array[i].x === random_x * size + (size / 2) \n                  && nodes_array[i].y <= y_max * size + (size / 2)\n                  && nodes_array[i].y >= y_min * size + (size / 2)\n                  && nodes_array[i].x !== (cols - 1) * size + (size / 2)\n                  ){\n                  if (nodes_array[i].y !== random_y * size + (size / 2)){\n                      nodes_array[i].walls[1] = true\n                      let {x , y} = nodes_array[i]\n                      let neightbor_node = nodes_array.find(node => node.x === (x + size) && node.y === y) \n                      if(neightbor_node){\n                          neightbor_node.walls[3] = true\n                      } \n                  }\n              }\n          }else{\n              if(\n                  nodes_array[i].y === random_y * size + (size / 2)\n                  && nodes_array[i].x <= x_max * size + (size / 2)\n                  && nodes_array[i].x >= x_min * size + (size / 2)\n                  ){\n                  if(nodes_array[i].x !== random_x * size + (size / 2)){\n                      nodes_array[i].walls[2] = true\n                      let {x , y} = nodes_array[i]\n                      let neightbor_node = nodes_array.find(node => node.x === x && node.y === (y + size)) \n                      if(neightbor_node){\n                        neightbor_node.walls[0] = true\n                      } \n                  }\n              }\n          }\n            nodes_array[i].draw()\n        }\n    }, delay * speed)\n  \n    if(x_or_y > 0){ \n      draw_maze(nodes_array, random_x, y_max, x_min, y_min) // right \n      draw_maze(nodes_array, x_max, y_max, random_x + 1, y_min) // left \n    }else{\n      draw_maze(nodes_array, x_max, random_y, x_min, y_min) // top \n      draw_maze(nodes_array, x_max, y_max, x_min , random_y + 1) // bottom\n    }\n  \n    return delay \n}\n\nconst getRandom = (min,max) => {\n    return Math.floor(Math.random() * (max - min) + min)\n}\n\nexport {recursive_dividion_maze}"]},"metadata":{},"sourceType":"module"}