{"ast":null,"code":"import { Block } from '../helper_method';\nlet start_node, end_node, nodes, c, canvas, size;\nlet open_list, close_list, current_node, myReg, finish_path;\n\nconst a_star = props => {\n  start_node = props.start_node;\n  end_node = props.end_node;\n  nodes = props.nodes;\n  c = props.c;\n  canvas = props.canvas;\n  size = props.size;\n  open_list = [start_node];\n  close_list = [];\n  current_node = null;\n  finish_path = false;\n  cancelAnimationFrame(myReg);\n  run_solve_maze();\n};\n\nconst stop_a_star = () => {\n  cancelAnimationFrame(myReg);\n};\n\nconst run_solve_maze = () => {\n  myReq = requestAnimationFrame(run_solve_maze);\n  c.clearRect(0, 0, canvas.width, canvas.height);\n\n  for (let i = 0; i < nodes.length; i++) {\n    nodes[i].draw();\n  }\n\n  if (open_list.length > 0 && !end_node.prev_node) {\n    current_node = open_list.sort((a, b) => a.f - b.f)[0];\n    find_child_node();\n  }\n\n  if (end_node.prev_node) {\n    start_node.draw();\n    end_node.draw();\n    find_path();\n  }\n\n  if (finish_path) {\n    cancelAnimationFrame(myReq);\n  }\n};\n\nconst find_child_node = () => {\n  let {\n    top,\n    right,\n    bottom,\n    left\n  } = get_top_right_bottom_left(current_node, nodes); // Right (x + size , y)\n\n  if (right && !close_list.find(node => node.x === right.x && node.y === right.y)) {\n    let right_in_open = open_list.find(n => n.x === right.x && n.y === right.y);\n    let r_g = current_node.g + 10;\n\n    if (right_in_open && r_g < right_in_open.g) {\n      update_node(right_in_open, r_g, current_node);\n    } else {\n      let right_node = set_node(right, r_g, current_node);\n      open_list.push(right_node);\n    }\n  } // top (x , y - size)\n\n\n  if (top && !close_list.find(node => node.x === top.x && node.y === top.y)) {\n    let top_in_open = open_list.find(n => n.x === top.x && n.y === top.y);\n    let t_g = current_node.g + 10;\n\n    if (top_in_open && r_g < top_in_open.g) {\n      update_node(top_in_open, t_g, current_node);\n    } else {\n      let top_node = set_node(top, r_g, current_node);\n      open_list.push(top_node);\n    }\n  } // left (x - size , y )\n\n\n  if (left && !close_list.find(node => node.x === left.x && node.y === left.y)) {\n    let left_in_open = open_list.find(n => n.x === left.x && n.y === left.y);\n    let l_g = current_node.g + 10;\n\n    if (left_in_open && l_g < left_in_open.g) {\n      update_node(left_in_open, l_g, current_node);\n    } else {\n      let left_node = set_node(left, l_g, current_node);\n      open_list.push(left_node);\n    }\n  } // bottom (x , y + size)\n\n\n  if (bottom && !close_list.find(node => node.x === bottom.x && node.y === bottom.y)) {\n    let bottom_in_open = open_list.find(n => n.x === bottom.x && n.y === bottom.y);\n    let b_g = current_node.g + 10;\n\n    if (bottom_in_open && b_g < bottom_in_open.g) {\n      update_node(bottom_in_open, b_g, current_node);\n    } else {\n      let bottom_node = set_node(bottom, b_g, current_node);\n      open_list.push(bottom_node);\n    }\n  }\n\n  open_list = open_list.filter(node => node.x !== current_node.x && node.y !== current_node.y);\n};\n\nconst find_path = () => {\n  current_node.color = \"LimeGreen\";\n\n  if (current_node.x === start_node.x && current_node.y === start_node.y) {\n    finish_path = true;\n    return;\n  }\n\n  current_node = current_node.prev_node;\n};\n\nconst set_node = (node, g, prev_node = null) => {\n  let color = \"MidnightBlue\";\n  let x_1 = node.x;\n  let y_1 = node.y;\n  let x_2 = end_node.x;\n  let y_2 = end_node.y;\n  let h = (Math.abs(x_1 - x_2) + Math.abs(y_1 - y_2)) * 10;\n  let f = h + g;\n  let new_node = new Block(x_1, y_1, c, size, color, current_node, g, h, f);\n  return new_node;\n};\n\nconst update_node = (node, g, parent) => {\n  node.g = g;\n  node.f = g + node.h;\n  node.parent = parent;\n};\n\nconst get_top_right_bottom_left = (node, array) => {\n  let {\n    x,\n    y\n  } = node;\n  let top = array.find(n => n.x === x && n.y === y - size);\n  let right = array.find(n => n.x === x + size && n.y === y);\n  let bottom = array.find(n => n.x === x && n.y === y + size);\n  let left = array.find(n => n.x === x - size && n.y === y);\n  return {\n    top,\n    right,\n    bottom,\n    left\n  };\n};\n\nexport { a_star, stop_a_star };","map":{"version":3,"sources":["/Users/vienpham/Desktop/Algorithms_simulation/algorithms/src/Algorithms/solve_maze/a_star.js"],"names":["Block","start_node","end_node","nodes","c","canvas","size","open_list","close_list","current_node","myReg","finish_path","a_star","props","cancelAnimationFrame","run_solve_maze","stop_a_star","myReq","requestAnimationFrame","clearRect","width","height","i","length","draw","prev_node","sort","a","b","f","find_child_node","find_path","top","right","bottom","left","get_top_right_bottom_left","find","node","x","y","right_in_open","n","r_g","g","update_node","right_node","set_node","push","top_in_open","t_g","top_node","left_in_open","l_g","left_node","bottom_in_open","b_g","bottom_node","filter","color","x_1","y_1","x_2","y_2","h","Math","abs","new_node","parent","array"],"mappings":"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","sourcesContent":["import { Block } from '../helper_method'\n\nlet start_node , end_node , nodes , c , canvas , size \n\nlet open_list , close_list , current_node , myReg , finish_path\n\nconst a_star = props => {\n    start_node = props.start_node\n    end_node = props.end_node \n    nodes = props.nodes\n    c = props.c \n    canvas = props.canvas \n    size = props.size \n\n    open_list = [start_node]\n    close_list = []\n    current_node = null \n    finish_path = false \n\n    cancelAnimationFrame(myReg)\n    run_solve_maze()\n}\n\nconst stop_a_star = () => {\n    cancelAnimationFrame(myReg)\n}\n\nconst run_solve_maze = () => {\n    myReq = requestAnimationFrame(run_solve_maze)\n    c.clearRect(0,0,canvas.width, canvas.height)\n\n    for(let i = 0 ; i < nodes.length ; i ++){\n        nodes[i].draw()\n    }\n\n    if(open_list.length > 0 && !end_node.prev_node){\n        current_node = open_list.sort((a,b) => a.f - b.f)[0]\n        find_child_node()\n    }\n\n    if(end_node.prev_node){\n        start_node.draw()\n        end_node.draw()\n        find_path() \n    }\n\n    if(finish_path){\n        cancelAnimationFrame(myReq)\n    }\n}\n\nconst find_child_node = () => {\n\n    let {top , right , bottom , left} = get_top_right_bottom_left(current_node , nodes )\n\n    // Right (x + size , y)\n    if(right && !close_list.find(node => node.x === right.x  && node.y === right.y)){\n        let right_in_open = open_list.find(n => n.x === right.x  && n.y === right.y)\n        let r_g = current_node.g + 10\n        if(right_in_open && r_g < right_in_open.g){\n            update_node(right_in_open, r_g , current_node )\n        }else{\n            let right_node = set_node(right, r_g , current_node)\n            open_list.push(right_node)\n        }\n    }\n\n    // top (x , y - size)\n    if(top && !close_list.find(node => node.x === top.x && node.y === top.y)){\n        let top_in_open = open_list.find(n => n.x === top.x  && n.y === top.y)\n        let t_g = current_node.g + 10\n        if(top_in_open && r_g < top_in_open.g){\n            update_node(top_in_open, t_g , current_node )\n        }else{\n            let top_node = set_node(top, r_g , current_node)\n            open_list.push(top_node)\n        }\n    }\n\n    // left (x - size , y )\n    if(left && !close_list.find(node => node.x === left.x && node.y === left.y)){\n        let left_in_open = open_list.find(n => n.x === left.x  && n.y === left.y)\n        let l_g = current_node.g + 10\n        if(left_in_open && l_g < left_in_open.g){\n            update_node(left_in_open, l_g , current_node )\n        }else{\n            let left_node = set_node(left, l_g , current_node)\n            open_list.push(left_node)\n        }\n    }\n\n    // bottom (x , y + size)\n    if(bottom && !close_list.find(node => node.x === bottom.x && node.y === bottom.y)){\n        let bottom_in_open = open_list.find(n => n.x === bottom.x  && n.y === bottom.y)\n        let b_g = current_node.g + 10\n        if(bottom_in_open && b_g < bottom_in_open.g){\n            update_node(bottom_in_open, b_g , current_node )\n        }else{\n            let bottom_node = set_node(bottom, b_g , current_node)\n            open_list.push(bottom_node)\n        }\n    }\n\n    open_list = open_list.filter(node => node.x !== current_node.x && node.y !== current_node.y)\n}\n\nconst find_path = () => {\n    current_node.color = \"LimeGreen\"\n    if(current_node.x === start_node.x && current_node.y === start_node.y){\n        finish_path = true\n        return\n    }\n    current_node = current_node.prev_node\n}\n\nconst set_node = (node, g , prev_node = null) => {\n    let color = \"MidnightBlue\"\n    let x_1 = node.x \n    let y_1 = node.y \n    let x_2 = end_node.x \n    let y_2 = end_node.y    \n    let h = (Math.abs(x_1 - x_2) + Math.abs(y_1 - y_2)) * 10\n    let f = h + g \n    let new_node = new Block(x_1 , y_1 , c , size , color , current_node , g , h , f)\n    return new_node \n}\n\nconst update_node = (node , g , parent) => {\n    node.g = g \n    node.f = g + node.h \n    node.parent = parent \n}\n\nconst get_top_right_bottom_left = (node , array ) => {\n    let {x , y} = node\n    let top = array.find(n => n.x === x && n.y === y - size)\n    let right = array.find(n => n.x === x + size && n.y === y)\n    let bottom = array.find(n => n.x === x && n.y === y + size)\n    let left = array.find(n => n.x === x - size && n.y === y)\n\n    return {top , right , bottom , left }\n}\n\nexport {a_star , stop_a_star}"]},"metadata":{},"sourceType":"module"}