{"ast":null,"code":"import { Node, Block } from './helper_method';\nimport breadth_first_search from './solve_maze/breadth_first_search';\nlet size, width, height, cols, rows;\nlet delay, speed, canvas, c, start_node, end_node, nodes, stack;\n\nconst setUp = props => {\n  c = props.c;\n  canvas = props.canvas;\n  nodes = [];\n  stack = [];\n  cols = props.cols;\n  rows = props.rows;\n  size = props.size;\n  width = size * cols;\n  height = size * rows;\n  delay = 0;\n  speed = 100;\n  canvas.width = width;\n  canvas.height = height;\n  draw_divide_maze();\n};\n\nconst draw_divide_maze = () => {\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      let x = j * size + size / 2;\n      let y = i * size + size / 2;\n      let node = new Node(x, y, c, size);\n\n      if (i === 0 && j !== 0) {\n        node.walls[0] = true;\n      } else if (i === rows - 1) {\n        node.walls[2] = true;\n      }\n\n      if (j === 0) {\n        node.walls[3] = true;\n      } else if (j === cols - 1 && i !== rows - 1) {\n        node.walls[1] = true;\n      }\n\n      if (i === 0 && j === 0) {\n        stack.push(node);\n      }\n\n      nodes.push(node);\n    }\n  }\n\n  start_node = new Block(size / 2, size / 2, c, size, \"blue\");\n  end_node = new Block((cols - 1) * size + size / 2, (rows - 1) * size + size / 2, c, size, \"green\");\n  let draw_delay = draw_maze(nodes, cols, rows, 0, 0);\n\n  if (draw_delay) {\n    setTimeout(() => {\n      breadth_first_search({\n        stack,\n        nodes,\n        start_node,\n        end_node\n      });\n    }, draw_delay * speed);\n  }\n};\n\nconst draw_maze = (nodes_array, x_max, y_max, x_min, y_min) => {\n  if (x_max - x_min < 1 || y_max - y_min < 1) return;\n  let random_x = getRandom(x_min, x_max);\n  let random_y = getRandom(y_min, y_max);\n  let x_or_y = getRandom(-20, 20);\n  delay++;\n  setTimeout(() => {\n    for (let i = 0; i < nodes_array.length; i++) {\n      if (x_or_y > 0) {\n        // x\n        if (nodes_array[i].x === random_x * size + size / 2 && nodes_array[i].y <= y_max * size + size / 2 && nodes_array[i].y >= y_min * size + size / 2 && nodes_array[i].x !== (cols - 1) * size + size / 2) {\n          if (nodes_array[i].y !== random_y * size + size / 2) {\n            nodes_array[i].walls[1] = true;\n            let {\n              x,\n              y\n            } = nodes_array[i];\n            let neightbor_node = nodes_array.find(node => node.x === x + size && node.y === y);\n\n            if (neightbor_node) {\n              neightbor_node.walls[3] = true;\n            }\n          }\n        }\n      } else {\n        if (nodes_array[i].y === random_y * size + size / 2 && nodes_array[i].x <= x_max * size + size / 2 && nodes_array[i].x >= x_min * size + size / 2) {\n          if (nodes_array[i].x !== random_x * size + size / 2) {\n            nodes_array[i].walls[2] = true;\n            let {\n              x,\n              y\n            } = nodes_array[i];\n            let neightbor_node = nodes_array.find(node => node.x === x && node.y === y + size);\n\n            if (neightbor_node) {\n              neightbor_node.walls[0] = true;\n            }\n          }\n        }\n      }\n\n      nodes_array[i].draw();\n    }\n  }, delay * speed);\n\n  if (x_or_y > 0) {\n    draw_maze(nodes_array, random_x, y_max, x_min, y_min); // right \n\n    draw_maze(nodes_array, x_max, y_max, random_x + 1, y_min); // left \n  } else {\n    draw_maze(nodes_array, x_max, random_y, x_min, y_min); // top \n\n    draw_maze(nodes_array, x_max, y_max, x_min, random_y + 1); // bottom\n  }\n\n  return delay;\n};\n\nconst getRandom = (min, max) => {\n  return Math.floor(Math.random() * (max - min) + min);\n};\n\nexport { setUp };","map":{"version":3,"sources":["/Users/vienpham/Desktop/Algorithms_simulation/algorithms/src/Algorithms/depth_first_search_maze.js"],"names":["Node","Block","breadth_first_search","size","width","height","cols","rows","delay","speed","canvas","c","start_node","end_node","nodes","stack","setUp","props","draw_divide_maze","i","j","x","y","node","walls","push","draw_delay","draw_maze","setTimeout","nodes_array","x_max","y_max","x_min","y_min","random_x","getRandom","random_y","x_or_y","length","neightbor_node","find","draw","min","max","Math","floor","random"],"mappings":"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","sourcesContent":["import {Node , Block} from './helper_method'\nimport breadth_first_search from './solve_maze/breadth_first_search'\n\nlet size , width , height , cols , rows \n\nlet delay , speed , canvas , c , start_node, end_node , nodes , stack \n\nconst setUp = (props) => {\n  c = props.c\n  canvas = props.canvas \n  nodes = []\n  stack = []\n\n  cols = props.cols \n  rows = props.rows \n  size = props.size \n  width = size * cols \n  height = size * rows\n\n  delay = 0 \n  speed = 100\n\n  canvas.width = width\n  canvas.height = height\n\n  draw_divide_maze()\n}\n\nconst draw_divide_maze = () => {\n  for(let i = 0; i < rows ; i ++){\n    for(let j = 0; j < cols ; j ++){\n        let x = j * size + (size / 2)\n        let y = i * size + (size / 2)\n        let node = new Node(x, y , c , size )\n        if(i === 0 && j !== 0) {\n            node.walls[0] = true\n        }else if(i === rows - 1){\n            node.walls[2] = true\n        }\n\n        if(j === 0){\n            node.walls[3] = true \n        }else if(j === cols - 1 && i !== rows - 1){\n            node.walls[1] = true\n        }\n\n        if(i === 0 && j === 0){\n            stack.push(node)\n        }\n        nodes.push(node)\n    }\n  }\n\n  start_node = new Block(size / 2,size / 2 , c , size , \"blue\")\n  end_node = new Block((cols - 1) * size + (size / 2),( rows - 1 ) * size + (size / 2) , c , size , \"green\" )\n  let draw_delay = draw_maze(nodes , cols, rows, 0, 0)\n  if(draw_delay){\n    setTimeout(() => {\n      breadth_first_search({stack , nodes , start_node , end_node})\n    }, draw_delay * speed);\n  }\n}\n\n\nconst draw_maze = (nodes_array , x_max, y_max, x_min , y_min) => {\n\n  if(x_max - x_min < 1 || y_max - y_min < 1) return\n\n  let random_x = getRandom(x_min,x_max)\n  let random_y = getRandom(y_min,y_max)\n  let x_or_y = getRandom(-20, 20) \n\n  delay ++\n\n  setTimeout(() => {\n    for(let i = 0; i < nodes_array.length; i ++){\n        if(x_or_y > 0) { // x\n            if (\n                nodes_array[i].x === random_x * size + (size / 2) \n                && nodes_array[i].y <= y_max * size + (size / 2)\n                && nodes_array[i].y >= y_min * size + (size / 2)\n                && nodes_array[i].x !== (cols - 1) * size + (size / 2)\n                ){\n                if (nodes_array[i].y !== random_y * size + (size / 2)){\n                    nodes_array[i].walls[1] = true\n                    let {x , y} = nodes_array[i]\n                    let neightbor_node = nodes_array.find(node => node.x === x + size && node.y === y) \n                    if(neightbor_node){\n                        neightbor_node.walls[3] = true\n                    } \n                }\n            }\n        }else{\n            if(\n                nodes_array[i].y === random_y * size + (size / 2)\n                && nodes_array[i].x <= x_max * size + (size / 2)\n                && nodes_array[i].x >= x_min * size + (size / 2)\n                ){\n                if(nodes_array[i].x !== random_x * size + (size / 2)){\n                    nodes_array[i].walls[2] = true\n                    let {x , y} = nodes_array[i]\n                    let neightbor_node = nodes_array.find(node => node.x === x && node.y === y + size) \n                    if(neightbor_node){\n                        neightbor_node.walls[0] = true\n                    } \n                }\n            }\n        }\n          nodes_array[i].draw()\n      }\n  }, delay * speed)\n\n  if(x_or_y > 0){ \n    draw_maze(nodes_array, random_x, y_max, x_min, y_min) // right \n    draw_maze(nodes_array, x_max, y_max, random_x + 1, y_min) // left \n  }else{\n    draw_maze(nodes_array, x_max, random_y, x_min, y_min) // top \n    draw_maze(nodes_array, x_max, y_max, x_min , random_y + 1) // bottom\n  }\n\n  return delay \n}\n\nconst getRandom = (min,max) => {\n  return Math.floor(Math.random() * (max - min) + min)\n}\n\nexport {setUp}\n"]},"metadata":{},"sourceType":"module"}