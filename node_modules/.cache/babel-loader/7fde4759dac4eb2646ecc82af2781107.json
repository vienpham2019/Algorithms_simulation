{"ast":null,"code":"const Node = function (x, y, c, size, walls, neighbor_node = [], prev_node = null) {\n  this.x = x;\n  this.y = y;\n  this.neighbor_node = neighbor_node;\n  this.prev_node = prev_node;\n  this.walls = walls; // [top, right , bottom , left ]\n\n  this.grid = false;\n\n  this.draw = (color = \"black\") => {\n    let x = this.x - size / 2;\n    let y = this.y - size / 2; // Top \n\n    if (this.walls[0]) {\n      c.beginPath();\n      c.moveTo(x, y);\n      c.lineTo(x + size, y);\n      c.lineWidth = 4;\n      c.lineCap = \"round\";\n      c.strokeStyle = color;\n      c.stroke();\n    } // right\n\n\n    if (this.walls[1]) {\n      c.beginPath();\n      c.moveTo(x + size, y);\n      c.lineTo(x + size, y + size);\n      c.lineWidth = 4;\n      c.lineCap = \"round\";\n      c.strokeStyle = color;\n      c.stroke();\n    } // bottom\n\n\n    if (this.walls[2]) {\n      c.beginPath();\n      c.moveTo(x + size, y + size);\n      c.lineTo(x, y + size);\n      c.lineWidth = 4;\n      c.lineCap = \"round\";\n      c.strokeStyle = color;\n      c.stroke();\n    } // left \n\n\n    if (this.walls[3]) {\n      c.beginPath();\n      c.moveTo(x, y + size);\n      c.lineTo(x, y);\n      c.lineWidth = 4;\n      c.lineCap = \"round\";\n      c.strokeStyle = color;\n      c.stroke();\n    }\n\n    if (this.walls.every(e => e === true) && this.grid) {\n      c.beginPath();\n      c.rect(x, y, size, size);\n      c.fillStyle = 'black';\n      c.fill();\n    }\n  };\n};\n\nconst Block = function (x, y, c, size, color = \"red\", prev_node = null, g = null, h = null, f = null, distance = Infinity) {\n  this.x = x;\n  this.y = y;\n  this.prev_node = prev_node;\n  this.color = color;\n  this.g = g;\n  this.h = h;\n  this.f = f;\n  this.distance = distance;\n\n  this.draw = () => {\n    c.beginPath();\n    c.rect(this.x - size / 3, this.y - size / 3, size * 2 / 3, size * 2 / 3);\n    c.fillStyle = this.color;\n    c.fill();\n  };\n};\n\nexport { Node, Block };","map":{"version":3,"sources":["/Users/vienpham/Desktop/Algorithms_simulation/src/Algorithms/helper_method.js"],"names":["Node","x","y","c","size","walls","neighbor_node","prev_node","grid","draw","color","beginPath","moveTo","lineTo","lineWidth","lineCap","strokeStyle","stroke","every","e","rect","fillStyle","fill","Block","g","h","f","distance","Infinity"],"mappings":"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","sourcesContent":["\n\nconst Node = function(x , y , c , size , walls , neighbor_node = [], prev_node = null){\n    this.x = x\n    this.y = y\n    this.neighbor_node = neighbor_node\n    this.prev_node = prev_node \n    this.walls = walls// [top, right , bottom , left ]\n    this.grid = false \n\n    this.draw = (color = \"black\") => {\n        let x = this.x - (size / 2)\n        let y = this.y - (size / 2)\n        // Top \n        if(this.walls[0]){\n            c.beginPath()\n            c.moveTo(x, y)\n            c.lineTo(x + size , y)\n            c.lineWidth = 4\n            c.lineCap = \"round\"\n            c.strokeStyle = color\n            c.stroke()\n        }\n\n        // right\n        if(this.walls[1]){\n            c.beginPath()\n            c.moveTo(x + size, y)\n            c.lineTo(x + size , y +size)\n            c.lineWidth = 4\n            c.lineCap = \"round\"\n            c.strokeStyle = color\n            c.stroke()\n        }\n\n        // bottom\n        if(this.walls[2]){\n            c.beginPath()\n            c.moveTo(x + size, y + size)\n            c.lineTo(x, y +size)\n            c.lineWidth = 4\n            c.lineCap = \"round\"\n            c.strokeStyle = color\n            c.stroke()\n        }\n\n        // left \n        if(this.walls[3]){\n            c.beginPath()\n            c.moveTo(x, y + size)\n            c.lineTo(x, y)\n            c.lineWidth = 4\n            c.lineCap = \"round\"\n            c.strokeStyle = color\n            c.stroke()\n        }\n\n        if(this.walls.every( e => e === true) && this.grid){\n            c.beginPath()\n            c.rect(x, y, size, size)\n            c.fillStyle = 'black'\n            c.fill()\n        }\n    }\n}\n\nconst Block = function(x , y , c , size, color = \"red\", prev_node = null , g = null , h = null , f = null , distance = Infinity){\n    this.x = x \n    this.y = y \n    this.prev_node = prev_node\n    this.color = color\n    this.g = g \n    this.h = h \n    this.f = f\n    this.distance = distance\n  \n    this.draw = () => {\n        c.beginPath()\n        c.rect(this.x - (size / 3), this.y - (size / 3), size * 2/3, size * 2/3)\n        c.fillStyle = this.color\n        c.fill()\n    }\n}\n\nexport {Node , Block}"]},"metadata":{},"sourceType":"module"}