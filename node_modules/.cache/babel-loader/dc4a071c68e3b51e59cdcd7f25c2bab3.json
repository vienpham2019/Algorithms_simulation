{"ast":null,"code":"import { Block, Node, setup_block_and_node } from './helper_method';\nlet size, width, height, cols, rows;\nlet canvas, c;\nlet nodes, block;\nlet visited_nodes, stack;\nlet quere, finish_path, nodes_path, path, current_node;\nlet start_node, end_node;\nlet myReq;\n\nconst setUp = props => {\n  c = props.c;\n  canvas = props.canvas;\n  canvas.width = width;\n  canvas.height = height;\n  nodes = [];\n  visited_nodes = [];\n  stack = [];\n  quere = [];\n  nodes_path = [];\n  path = [];\n  finish_path = false;\n  cols = props.cols;\n  rows = props.rows;\n  size = props.size;\n  width = size * cols;\n  height = size * rows;\n  setup_block_and_node(c);\n  draw_first_search_maze();\n};\n\nconst draw_first_search_maze = () => {\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      let x = j * size + size / 2;\n      let y = i * size + size / 2;\n      let node = new Node(x, y);\n\n      if (i === 0 && j === 0) {\n        stack.push(node);\n        visited_nodes.push(node);\n      }\n\n      nodes.push(node);\n    }\n  }\n\n  block = new Block(0, 0);\n  start_node = new Block(0, 0, \"blue\");\n  quere.push(start_node);\n  end_node = new Block(width - size, height - size, \"green\");\n  draw_maze();\n};\n\nconst draw_maze = () => {\n  myReq = requestAnimationFrame(draw_maze);\n  c.clearRect(0, 0, canvas.width, canvas.height);\n\n  for (let i = 0; i < nodes.length; i++) {\n    nodes[i].draw();\n  }\n\n  for (let i = 0; i < nodes_path.length; i++) {\n    nodes_path[i].draw();\n  }\n\n  if (stack.length === 0) {\n    start_node.draw();\n    end_node.draw();\n\n    if (end_node.prev_node) {\n      find_path();\n    } else if (finish_path) {\n      cancelAnimationFrame(myReq);\n    } else {\n      solve_maze();\n    }\n  } else {\n    block.move();\n  }\n};\n\nconst solve_maze = () => {\n  let quere_nodes = [...quere];\n  quere.shift(); // visited_nodes_for_path.push(current_node)\n\n  if (end_node.prev_node) {\n    return;\n  }\n\n  for (let i = 0; i < quere_nodes.length; i++) {\n    check_neighbor_node(quere_nodes[i]);\n  }\n};\n\nconst check_neighbor_node = node => {\n  let x = node.x;\n  let y = node.y;\n  let color = \"purple\"; // top \n\n  let top = nodes.find(n => n.x === x + size / 2 && n.y === y - size / 2);\n\n  if (top && !top.walls[2] && !nodes_path.find(n => n.x === top.x - size / 2 && n.y === top.y - size / 2)) {\n    let top_x = top.x - size / 2;\n    let top_y = top.y - size / 2;\n\n    if (top_x === end_node.x && top_y === end_node.y) {\n      end_node.prev_node = node;\n      current_node = node;\n      return;\n    } else {\n      let top_block = new Block(top_x, top_y, color, node);\n      quere.push(top_block);\n      nodes_path.push(top_block);\n    }\n  } // right\n\n\n  let right = nodes.find(n => n.x === x + size * 3 / 2 && n.y === y + size / 2);\n\n  if (right && !right.walls[3] && !nodes_path.find(n => n.x === right.x - size / 2 && n.y === right.y - size / 2)) {\n    let right_x = right.x - size / 2;\n    let right_y = right.y - size / 2;\n\n    if (right_x === end_node.x && right_y === end_node.y) {\n      end_node.prev_node = node;\n      current_node = node;\n      return;\n    } else {\n      let right_block = new Block(right_x, right_y, color, node);\n      quere.push(right_block);\n      nodes_path.push(right_block);\n    }\n  } // bottom\n\n\n  let bottom = nodes.find(n => n.x === x + size / 2 && n.y === y + size * 3 / 2);\n\n  if (bottom && !bottom.walls[0] && !nodes_path.find(n => n.x === bottom.x - size / 2 && n.y === bottom.y - size / 2)) {\n    let bottom_x = bottom.x - size / 2;\n    let bottom_y = bottom.y - size / 2;\n\n    if (bottom_x === end_node.x && bottom_y === end_node.y) {\n      end_node.prev_node = node;\n      current_node = node;\n      return;\n    } else {\n      let bottom_block = new Block(bottom_x, bottom_y, color, node);\n      quere.push(bottom_block);\n      nodes_path.push(bottom_block);\n    }\n  } // left \n\n\n  let left = nodes.find(n => n.x === x - size / 2 && n.y === y + size / 2);\n\n  if (left && !left.walls[1] && !nodes_path.find(n => n.x === left.x - size / 2 && n.y === left.y - size / 2)) {\n    let left_x = left.x - size / 2;\n    let left_y = left.y - size / 2;\n\n    if (left_x === end_node.x && left_y === end_node.y) {\n      end_node.prev_node = node;\n      current_node = node;\n      return;\n    } else {\n      let left_block = new Block(left_x, left_y, color, node);\n      quere.push(left_block);\n      nodes_path.push(left_block);\n    }\n  }\n};\n\nconst find_path = () => {\n  current_node.color = \"green\";\n\n  if (current_node.x === 0 && current_node.y === 0) {\n    finish_path = true;\n    return;\n  }\n\n  current_node = current_node.prev_node;\n};\n\nexport { setUp };","map":{"version":3,"sources":["/Users/vienpham/Desktop/Algorithms_simulation/algorithms/src/Algorithms/depth_first_search_maze.js"],"names":["Block","Node","setup_block_and_node","size","width","height","cols","rows","canvas","c","nodes","block","visited_nodes","stack","quere","finish_path","nodes_path","path","current_node","start_node","end_node","myReq","setUp","props","draw_first_search_maze","i","j","x","y","node","push","draw_maze","requestAnimationFrame","clearRect","length","draw","prev_node","find_path","cancelAnimationFrame","solve_maze","move","quere_nodes","shift","check_neighbor_node","color","top","find","n","walls","top_x","top_y","top_block","right","right_x","right_y","right_block","bottom","bottom_x","bottom_y","bottom_block","left","left_x","left_y","left_block"],"mappings":"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","sourcesContent":["import {Block , Node , setup_block_and_node} from './helper_method'\n\nlet size , width , height , cols , rows \n\nlet canvas , c \n\nlet nodes , block \n\nlet visited_nodes , stack \n\nlet quere , finish_path , nodes_path , path , current_node\n \nlet start_node, end_node \n\nlet myReq\n\nconst setUp = (props) => {\n    c = props.c\n    canvas = props.canvas \n    canvas.width = width\n    canvas.height = height\n    nodes = []\n    visited_nodes = []\n    stack = []\n    quere = []\n    nodes_path = []\n    path = []\n    finish_path = false \n\n    cols = props.cols \n    rows = props.rows \n    size = props.size \n    width = size * cols \n    height = size * rows\n\n    setup_block_and_node(c)\n\n    draw_first_search_maze()\n}\n\nconst draw_first_search_maze = () => {\n  for(let i = 0; i < rows ; i ++){\n    for(let j = 0; j < cols ; j ++){\n        let x = j * size + (size / 2)\n        let y = i * size + (size / 2)\n        let node = new Node(x, y)\n        if(i === 0 && j === 0){\n            stack.push(node)\n            visited_nodes.push(node)\n        }\n        nodes.push(node)\n    }\n  }\n\n  block = new Block(0 , 0)\n  start_node = new Block(0 , 0 , \"blue\")\n  quere.push(start_node)\n  end_node = new Block(width - size,height - size , \"green\")\n  draw_maze() \n}\n\n\nconst draw_maze = () => {\n    myReq = requestAnimationFrame(draw_maze)\n    c.clearRect(0,0,canvas.width, canvas.height)\n\n    for(let i = 0; i < nodes.length; i ++){\n        nodes[i].draw()\n    }\n\n    for(let i = 0; i < nodes_path.length; i ++){\n        nodes_path[i].draw()\n    }\n\n    if(stack.length === 0){\n        start_node.draw()\n        end_node.draw()\n        if(end_node.prev_node){\n            find_path()\n        }else if(finish_path){\n            cancelAnimationFrame(myReq)\n        }else{\n            solve_maze()\n        }\n    }else{ \n        block.move()  \n    }\n}\n\nconst solve_maze = () => {\n    let quere_nodes = [...quere]\n    quere.shift()\n    // visited_nodes_for_path.push(current_node)\n    if(end_node.prev_node){\n        return\n    }\n    for(let i = 0; i < quere_nodes.length ; i ++){\n        check_neighbor_node(quere_nodes[i])\n    }\n}\n\nconst check_neighbor_node = (node) => {\n    let x = node.x\n    let y = node.y\n    let color = \"purple\"\n    // top \n    let top = nodes.find(n => n.x === x + (size / 2) && n.y === y - (size / 2))\n    if(top && !top.walls[2] && !nodes_path.find(n => n.x === top.x  - (size / 2) && n.y === top.y - (size / 2))){\n        let top_x = top.x  - (size / 2)\n        let top_y = top.y  - (size / 2)\n        if(top_x === end_node.x && top_y === end_node.y){\n            end_node.prev_node = node \n            current_node = node \n            return \n        }else{\n            let top_block = new Block(top_x, top_y, color, node)\n            quere.push(top_block)\n            nodes_path.push(top_block)\n        }\n    }\n\n    // right\n    let right = nodes.find(n => n.x === x + (size * 3 / 2) && n.y === y + (size / 2))\n    if(right && !right.walls[3] && !nodes_path.find(n => n.x === right.x - (size / 2) && n.y === right.y - (size / 2))){\n        let right_x = right.x - (size / 2)\n        let right_y = right.y - (size / 2)\n        if(right_x === end_node.x && right_y === end_node.y){\n            end_node.prev_node = node \n            current_node = node \n            return \n        }else{\n            let right_block = new Block(right_x, right_y, color ,node)\n            quere.push(right_block)\n            nodes_path.push(right_block)\n        }\n    }\n\n    // bottom\n    let bottom = nodes.find(n => n.x === x + (size / 2) && n.y === y + (size * 3 / 2) ) \n    if(bottom && !bottom.walls[0] && !nodes_path.find(n => n.x === bottom.x - (size / 2) && n.y === bottom.y  - (size / 2))){\n        let bottom_x = bottom.x - (size / 2)\n        let bottom_y = bottom.y - (size / 2)\n        if(bottom_x === end_node.x && bottom_y === end_node.y){\n            end_node.prev_node = node \n            current_node = node \n            return \n        }else{\n            let bottom_block = new Block(bottom_x, bottom_y, color ,node)\n            quere.push(bottom_block)\n            nodes_path.push(bottom_block)\n        }\n    }\n\n    // left \n    let left = nodes.find(n => n.x === x - (size / 2) && n.y === y + (size / 2))\n    if(left && !left.walls[1] && !nodes_path.find(n => n.x === left.x  - (size / 2) && n.y === left.y - (size / 2))){\n        let left_x = left.x - (size / 2)\n        let left_y = left.y - (size / 2)\n        if(left_x === end_node.x && left_y === end_node.y){\n            end_node.prev_node = node \n            current_node = node \n            return \n        }else{\n            let left_block = new Block(left_x,left_y, color , node)\n            quere.push(left_block)\n            nodes_path.push(left_block)\n        }\n    }\n\n}\n\nconst find_path = () => {\n    current_node.color = \"green\"\n    if(current_node.x === 0 && current_node.y === 0){\n        finish_path = true\n        return\n    }\n    current_node = current_node.prev_node\n}\n\nexport {setUp}\n"]},"metadata":{},"sourceType":"module"}