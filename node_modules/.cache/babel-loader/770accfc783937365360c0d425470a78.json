{"ast":null,"code":"import { Block } from '../helper_method';\nimport { get_top_right_bottom_left } from './helper_method/algorithms_helper_method';\nlet c, canvas, size, nodes, start_node, end_node;\nlet visited_nodes, stack, current_node, finish_path, myReq;\n\nconst depth_first_search = props => {\n  c = props.c;\n  canvas = props.canvas;\n  size = props.size;\n  nodes = props.nodes;\n  finish_path = false;\n  start_node = props.start_node;\n  end_node = props.end_node;\n  end_node.prev_node = null;\n  stack = [start_node];\n  visited_nodes = [start_node];\n  current_node = start_node;\n  stack.push(start_node);\n  cancelAnimationFrame(myReq);\n  run_solve_maze();\n};\n\nconst stop_depth_first_search = () => {\n  cancelAnimationFrame(myReq);\n};\n\nconst run_solve_maze = () => {\n  myReq = requestAnimationFrame(run_solve_maze);\n  c.clearRect(0, 0, canvas.width, canvas.height);\n\n  for (let i = 0; i < nodes.length; i++) {\n    nodes[i].draw();\n  }\n\n  for (let i = 0; i < visited_nodes.length; i++) {\n    if (!end_node.prev_node) {\n      visited_nodes[i].color = 'MediumBlue';\n    }\n\n    visited_nodes[i].draw();\n  }\n\n  if (!end_node.prev_node) {\n    for (let i = 0; i < stack.length; i++) {\n      stack[i].color = 'LightSkyBlue';\n      stack[i].draw();\n    }\n  }\n\n  if (stack.length > 0 && !end_node.prev_node) {\n    current_node = stack[0];\n\n    if (!check_neighbor_node()) {\n      stack.shift();\n    }\n  }\n\n  if (end_node.prev_node) {\n    start_node.draw();\n    end_node.draw();\n    find_path();\n  }\n\n  if (finish_path) {\n    cancelAnimationFrame(myReq);\n  }\n};\n\nconst find_path = () => {\n  current_node.color = \"LimeGreen\";\n\n  if (current_node.x === start_node.x && current_node.y === start_node.y) {\n    finish_path = true;\n    return;\n  }\n\n  current_node = current_node.prev_node;\n};\n\nconst check_neighbor_node = () => {\n  let {\n    x,\n    y\n  } = current_node; // block \n  // let color = \"MidnightBlue\"\n\n  let current_find_node = nodes.find(c_n => c_n.x === x && c_n.y === y);\n  let {\n    top,\n    right,\n    bottom,\n    left\n  } = get_top_right_bottom_left(current_node, nodes, size); // bottom\n\n  if (add_node(bottom, current_find_node, 2)) return true; // right\n\n  if (add_node(right, current_find_node, 1)) return true; // top \n\n  if (add_node(top, current_find_node, 0)) return true; // left \n\n  if (add_node(left, current_find_node, 3)) return true;\n  return false;\n};\n\nconst add_node = (neighbor_node, current_find_node, wall_num) => {\n  let color = 'MediumBlue';\n\n  if (neighbor_node && !current_find_node.walls[wall_num] && !visited_nodes.find(n => n.x === neighbor_node.x && n.y === neighbor_node.y)) {\n    let {\n      x,\n      y\n    } = neighbor_node;\n\n    if (x === end_node.x && y === end_node.y) {\n      end_node.prev_node = current_node;\n    } else {\n      let new_block = new Block(x, y, c, size, color, current_node);\n      stack = [new_block, ...stack];\n      visited_nodes.push(new_block);\n    }\n\n    return true;\n  }\n\n  return false;\n};\n\nexport { depth_first_search, stop_depth_first_search };","map":{"version":3,"sources":["/Users/vienpham/Desktop/Algorithms_simulation/algorithms/src/Algorithms/solve_maze/depth_first_search.js"],"names":["Block","get_top_right_bottom_left","c","canvas","size","nodes","start_node","end_node","visited_nodes","stack","current_node","finish_path","myReq","depth_first_search","props","prev_node","push","cancelAnimationFrame","run_solve_maze","stop_depth_first_search","requestAnimationFrame","clearRect","width","height","i","length","draw","color","check_neighbor_node","shift","find_path","x","y","current_find_node","find","c_n","top","right","bottom","left","add_node","neighbor_node","wall_num","walls","n","new_block"],"mappings":"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","sourcesContent":["import {Block} from '../helper_method'\nimport {get_top_right_bottom_left} from './helper_method/algorithms_helper_method'\n\nlet c , canvas , size ,  nodes , start_node , end_node \n    \nlet visited_nodes , stack , current_node ,  finish_path , myReq\n\nconst depth_first_search = (props) => {\n    c = props.c\n    canvas = props.canvas \n    size = props.size \n    nodes = props.nodes \n\n    finish_path = false  \n    start_node = props.start_node\n    end_node = props.end_node\n\n    end_node.prev_node = null\n\n    stack = [start_node]\n    visited_nodes = [start_node]\n    current_node = start_node \n\n    stack.push(start_node)\n    cancelAnimationFrame(myReq)\n    run_solve_maze()\n}\n\nconst stop_depth_first_search = () => {\n    cancelAnimationFrame(myReq)\n}\n\nconst run_solve_maze = () => {\n    myReq = requestAnimationFrame(run_solve_maze)\n    c.clearRect(0,0,canvas.width, canvas.height)\n\n    for(let i = 0; i < nodes.length; i ++){\n        nodes[i].draw()\n    }\n\n    for(let i = 0 ; i < visited_nodes.length; i ++){\n        if(!end_node.prev_node){\n            visited_nodes[i].color = 'MediumBlue' \n        }\n        visited_nodes[i].draw()\n    }\n\n    if(!end_node.prev_node){\n        for(let i = 0 ; i < stack.length ; i ++){\n            stack[i].color = 'LightSkyBlue' \n            stack[i].draw()\n        }\n    }\n\n    if(stack.length > 0 && !end_node.prev_node){\n        current_node = stack[0]\n        if(!check_neighbor_node()){\n            stack.shift()\n        }\n    }\n\n    if(end_node.prev_node){\n        start_node.draw()\n        end_node.draw()\n        find_path() \n    }\n\n    if(finish_path){\n        cancelAnimationFrame(myReq)\n    }\n}\n\nconst find_path = () => {\n    current_node.color = \"LimeGreen\"\n    if(current_node.x === start_node.x && current_node.y === start_node.y){\n        finish_path = true\n        return\n    }\n    current_node = current_node.prev_node\n}\n\nconst check_neighbor_node = () => {\n    let {x , y} = current_node // block \n    // let color = \"MidnightBlue\"\n    let current_find_node = nodes.find(c_n => c_n.x === x && c_n.y === y )\n    let {top , right , bottom , left } = get_top_right_bottom_left(current_node , nodes , size)\n\n    // bottom\n    if(add_node(bottom , current_find_node , 2)) return true \n\n    // right\n    if(add_node(right , current_find_node , 1)) return true \n\n    // top \n    if(add_node(top , current_find_node , 0)) return true \n\n    // left \n    if(add_node(left , current_find_node , 3)) return true \n\n    return false \n}\n\nconst add_node = (neighbor_node , current_find_node , wall_num) => {\n    let color = 'MediumBlue'\n    if(\n        neighbor_node \n        && !current_find_node.walls[wall_num] \n        && !visited_nodes.find(n => n.x === neighbor_node.x  && n.y === neighbor_node.y)\n    ){\n        let {x , y} = neighbor_node\n        if(x === end_node.x && y === end_node.y){\n            end_node.prev_node = current_node\n        }else{\n            let new_block = new Block(x, y, c , size ,color , current_node)\n            stack = [new_block,...stack]\n            visited_nodes.push(new_block)\n        }\n        return true \n    }\n    return false \n}\n\nexport { depth_first_search ,  stop_depth_first_search}"]},"metadata":{},"sourceType":"module"}