{"ast":null,"code":"import { Block } from '../helper_method';\nimport { get_top_right_bottom_left } from './helper_method/algorithms_helper_method';\nlet start_node, end_node, nodes, c, canvas, size;\nlet open_list, close_list, current_node, myReq, finish_path;\n\nconst dijkstra = props => {\n  start_node = props.start_node;\n  start_node.distance = 0;\n  end_node = props.end_node;\n  nodes = props.nodes;\n  c = props.c;\n  canvas = props.canvas;\n  size = props.size;\n  end_node.prev_node = null;\n  open_list = [start_node];\n  close_list = [];\n  current_node = null;\n  finish_path = false;\n  cancelAnimationFrame(myReq);\n  run_solve_maze();\n};\n\nconst stop_dijkstra = () => {\n  cancelAnimationFrame(myReq);\n};\n\nconst run_solve_maze = () => {\n  myReq = requestAnimationFrame(run_solve_maze);\n  c.clearRect(0, 0, canvas.width, canvas.height);\n\n  for (let i = 0; i < nodes.length; i++) {\n    nodes[i].draw();\n  }\n\n  for (let i = 0; i < close_list.length; i++) {\n    if (!end_node.prev_node) {\n      close_list[i].color = 'MidnightBlue';\n    }\n\n    close_list[i].draw();\n  }\n\n  for (let i = 0; i < open_list.length; i++) {\n    open_list[i].color = 'DeepSkyBlue';\n    open_list[i].draw();\n  }\n\n  if (current_node && end_node.x === current_node.x && end_node.y === current_node.y) {\n    end_node.prev_node = current_node.prev_node;\n  }\n\n  if (open_list.length > 0 && !end_node.prev_node) {\n    current_node = open_list.sort((a, b) => a.distance - b.distance)[0];\n    close_list.push(current_node);\n    find_child_node();\n  }\n\n  if (end_node.prev_node) {\n    start_node.draw();\n    end_node.draw();\n    find_path();\n  }\n\n  if (finish_path) {\n    cancelAnimationFrame(myReq);\n  }\n};\n\nconst find_child_node = () => {\n  let {\n    top,\n    right,\n    bottom,\n    left\n  } = get_top_right_bottom_left(current_node, nodes, size); // Right (x + size , y)\n\n  if (right && !right.walls[3] && !close_list.find(node => node.x === right.x && node.y === right.y)) {\n    let right_in_open = open_list.find(n => n.x === right.x && n.y === right.y);\n    right_in_open ? update_node(right_in_open) : open_list.push(create_new_node(right));\n  } // top (x , y - size)\n\n\n  if (top && !top.walls[2] && !close_list.find(node => node.x === top.x && node.y === top.y)) {\n    let top_in_open = open_list.find(n => n.x === top.x && n.y === top.y);\n    top_in_open ? update_node(top_in_open) : open_list.push(create_new_node(top));\n  } // left (x - size , y )\n\n\n  if (left && !left.walls[1] && !close_list.find(node => node.x === left.x && node.y === left.y)) {\n    let left_in_open = open_list.find(n => n.x === left.x && n.y === left.y);\n    left_in_open ? update_node(left_in_open) : open_list.push(create_new_node(left));\n  } // bottom (x , y + size)\n\n\n  if (bottom && !bottom.walls[0] && !close_list.find(node => node.x === bottom.x && node.y === bottom.y)) {\n    let bottom_in_open = open_list.find(n => n.x === bottom.x && n.y === bottom.y);\n    bottom_in_open ? update_node(bottom_in_open) : open_list.push(create_new_node(bottom));\n  }\n\n  open_list = open_list.filter(node => node.x === current_node.x && node.y === current_node.y ? false : true);\n};\n\nconst find_path = () => {\n  current_node.color = \"LimeGreen\";\n\n  if (current_node.x === start_node.x && current_node.y === start_node.y) {\n    finish_path = true;\n    return;\n  }\n\n  current_node = current_node.prev_node;\n  return;\n};\n\nconst create_new_node = node => {\n  let distance = find_distance(node);\n  return new Block(node.x, node.y, c, size, 'MidnightBlue', current_node, null, null, null, distance);\n};\n\nconst find_distance = node => {\n  // find distance from current node to next node \n  let x_1 = current_node.x;\n  let y_1 = current_node.y;\n  let x_2 = node.x;\n  let y_2 = node.y;\n  return (Math.abs(x_1 - x_2) + Math.abs(y_1 - y_2)) * size + current_node.distance;\n};\n\nconst update_node = node => {\n  if (current_node.distance + size < node.distance) {\n    node.distance = find_distance(node);\n  }\n};\n\nexport { dijkstra, stop_dijkstra };","map":{"version":3,"sources":["/Users/vienpham/Desktop/Algorithms_simulation/algorithms/src/Algorithms/solve_maze/dijkstra.js"],"names":["Block","get_top_right_bottom_left","start_node","end_node","nodes","c","canvas","size","open_list","close_list","current_node","myReq","finish_path","dijkstra","props","distance","prev_node","cancelAnimationFrame","run_solve_maze","stop_dijkstra","requestAnimationFrame","clearRect","width","height","i","length","draw","color","x","y","sort","a","b","push","find_child_node","find_path","top","right","bottom","left","walls","find","node","right_in_open","n","update_node","create_new_node","top_in_open","left_in_open","bottom_in_open","filter","find_distance","x_1","y_1","x_2","y_2","Math","abs"],"mappings":"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","sourcesContent":["import { Block } from '../helper_method'\n\nimport {get_top_right_bottom_left} from './helper_method/algorithms_helper_method'\n\nlet start_node , end_node , nodes , c , canvas , size \n\nlet open_list , close_list , current_node , myReq , finish_path\n\nconst dijkstra = props => {\n    start_node = props.start_node\n    start_node.distance = 0\n    end_node = props.end_node \n    nodes = props.nodes\n    c = props.c \n    canvas = props.canvas \n    size = props.size \n\n    end_node.prev_node = null\n    \n    open_list = [start_node]\n    close_list = []\n    current_node = null \n    finish_path = false \n\n    cancelAnimationFrame(myReq)\n    run_solve_maze()\n}\n\nconst stop_dijkstra = () => {\n    cancelAnimationFrame(myReq)\n}\n\nconst run_solve_maze = () => {\n    myReq = requestAnimationFrame(run_solve_maze)\n    c.clearRect(0,0,canvas.width, canvas.height)\n\n    for(let i = 0 ; i < nodes.length ; i ++){\n        nodes[i].draw()\n    }\n\n    for(let i = 0 ; i < close_list.length ; i ++){\n        if(!end_node.prev_node){\n            close_list[i].color = 'MidnightBlue'\n        }\n        close_list[i].draw()\n    }\n\n    for(let i = 0 ; i < open_list.length ; i ++){\n        open_list[i].color = 'DeepSkyBlue'\n        open_list[i].draw()\n    }\n\n    if(current_node && end_node.x === current_node.x && end_node.y === current_node.y){\n        end_node.prev_node = current_node.prev_node\n    }\n\n    if(open_list.length > 0 && !end_node.prev_node){\n        current_node = open_list.sort((a,b) => a.distance - b.distance)[0] \n        close_list.push(current_node)\n        find_child_node()\n    }\n\n    if(end_node.prev_node){\n        start_node.draw()\n        end_node.draw()\n        find_path() \n    }\n    if(finish_path){\n        cancelAnimationFrame(myReq)\n    }\n}\n\nconst find_child_node = () => {\n\n    let {top , right , bottom , left} = get_top_right_bottom_left(current_node , nodes , size)\n\n    // Right (x + size , y)\n    if(right && !right.walls[3] && !close_list.find(node => node.x === right.x  && node.y === right.y)){\n        let right_in_open = open_list.find(n => n.x === right.x  && n.y === right.y)\n\n        right_in_open ? update_node(right_in_open) : open_list.push(create_new_node(right))\n    }\n\n    // top (x , y - size)\n    if(top && !top.walls[2] && !close_list.find(node => node.x === top.x && node.y === top.y)){\n        let top_in_open = open_list.find(n => n.x === top.x  && n.y === top.y)\n\n        top_in_open ? update_node(top_in_open) : open_list.push(create_new_node(top))\n    }\n\n    // left (x - size , y )\n    if(left && !left.walls[1] && !close_list.find(node => node.x === left.x && node.y === left.y)){\n        let left_in_open = open_list.find(n => n.x === left.x  && n.y === left.y)\n        \n        left_in_open ? update_node(left_in_open) : open_list.push(create_new_node(left))\n    }\n\n    // bottom (x , y + size)\n    if(bottom && !bottom.walls[0] &&!close_list.find(node => node.x === bottom.x && node.y === bottom.y)){\n        let bottom_in_open = open_list.find(n => n.x === bottom.x  && n.y === bottom.y)\n        \n        bottom_in_open ? update_node(bottom_in_open) : open_list.push(create_new_node(bottom))\n    }\n\n    open_list = open_list.filter(node => node.x === current_node.x && node.y === current_node.y ? false : true )\n}\n\nconst find_path = () => {\n    current_node.color = \"LimeGreen\"\n    if(current_node.x === start_node.x && current_node.y === start_node.y){\n        finish_path = true\n        return\n    }\n    current_node = current_node.prev_node\n    return \n}\n\nconst create_new_node = (node) => {\n    let distance = find_distance(node)\n    return new Block(node.x , node.y , c , size , 'MidnightBlue' , current_node , null , null , null , distance)\n}\n\nconst find_distance = (node) => {\n    // find distance from current node to next node \n    let x_1 = current_node.x \n    let y_1 = current_node.y \n\n    let x_2 = node.x \n    let y_2 = node.y\n\n   return ((Math.abs(x_1 - x_2) + Math.abs(y_1 - y_2)) * size ) + current_node.distance\n}\n\nconst update_node = node => {\n    if(current_node.distance + size < node.distance){\n        node.distance = find_distance(node)\n    }\n}\n\nexport {dijkstra , stop_dijkstra}"]},"metadata":{},"sourceType":"module"}