{"ast":null,"code":"const get_top_right_bottom_left = (node, array, size) => {\n  let {\n    x,\n    y\n  } = node;\n  let top = array.find(n => n.x === x && n.y === y - size);\n  let right = array.find(n => n.x === x + size && n.y === y);\n  let bottom = array.find(n => n.x === x && n.y === y + size);\n  let left = array.find(n => n.x === x - size && n.y === y);\n  return {\n    top,\n    right,\n    bottom,\n    left\n  };\n};\n\nconst add_to_heap = (node, array, method) => {\n  array.push(node);\n  let i = array.length;\n\n  while (array[Math.floor(i / 2) - 1] && method(array[i - 1], array[Math.floor(i / 2) - 1])) {\n    let current_node = array[i - 1];\n    array[i - 1] = array[Math.floor(i / 2) - 1];\n    array[Math.floor(i / 2) - 1] = current_node;\n    i = Math.floor(i / 2);\n  }\n\n  return array;\n};\n\nconst remove_from_heap = (array, method) => {\n  let i = 1;\n  array[0] = array[array.length - 1];\n  array.pop();\n  let current_node = array[0];\n  let stop = false;\n\n  while (!stop) {\n    let left_child = array[2 * i - 1];\n    let right_child = array[2 * i];\n    let max_child_index;\n\n    if (left_child && right_child) {\n      max_child_index = method(left_child, right_child) ? 2 * i : 2 * i + 1;\n    } else if (left_child || right_child) {\n      max_child_index = left_child ? 2 * i : 2 * i + 1;\n    }\n\n    if (max_child_index && method(array[max_child_index - 1], current_node)) {\n      array[i - 1] = array[max_child_index - 1];\n      array[max_child_index - 1] = current_node;\n      current_node = array[max_child_index - 1];\n      i = max_child_index;\n    } else {\n      stop = true;\n    }\n  }\n\n  return array;\n};\n\nexport { get_top_right_bottom_left, add_to_heap, remove_from_heap };","map":{"version":3,"sources":["/Users/vienpham/Desktop/Algorithms_simulation/algorithms/src/Algorithms/solve_maze/helper_method/algorithms_helper_method.js"],"names":["get_top_right_bottom_left","node","array","size","x","y","top","find","n","right","bottom","left","add_to_heap","method","push","i","length","Math","floor","current_node","remove_from_heap","pop","stop","left_child","right_child","max_child_index"],"mappings":"AAAA,MAAMA,yBAAyB,GAAG,CAACC,IAAD,EAAQC,KAAR,EAAgBC,IAAhB,KAAyB;AACvD,MAAI;AAACC,IAAAA,CAAD;AAAKC,IAAAA;AAAL,MAAUJ,IAAd;AACA,MAAIK,GAAG,GAAGJ,KAAK,CAACK,IAAN,CAAWC,CAAC,IAAIA,CAAC,CAACJ,CAAF,KAAQA,CAAR,IAAaI,CAAC,CAACH,CAAF,KAAQA,CAAC,GAAGF,IAAzC,CAAV;AACA,MAAIM,KAAK,GAAGP,KAAK,CAACK,IAAN,CAAWC,CAAC,IAAIA,CAAC,CAACJ,CAAF,KAAQA,CAAC,GAAGD,IAAZ,IAAoBK,CAAC,CAACH,CAAF,KAAQA,CAA5C,CAAZ;AACA,MAAIK,MAAM,GAAGR,KAAK,CAACK,IAAN,CAAWC,CAAC,IAAIA,CAAC,CAACJ,CAAF,KAAQA,CAAR,IAAaI,CAAC,CAACH,CAAF,KAAQA,CAAC,GAAGF,IAAzC,CAAb;AACA,MAAIQ,IAAI,GAAGT,KAAK,CAACK,IAAN,CAAWC,CAAC,IAAIA,CAAC,CAACJ,CAAF,KAAQA,CAAC,GAAGD,IAAZ,IAAoBK,CAAC,CAACH,CAAF,KAAQA,CAA5C,CAAX;AAEA,SAAO;AAACC,IAAAA,GAAD;AAAOG,IAAAA,KAAP;AAAeC,IAAAA,MAAf;AAAwBC,IAAAA;AAAxB,GAAP;AACH,CARD;;AAUA,MAAMC,WAAW,GAAG,CAACX,IAAD,EAAOC,KAAP,EAAcW,MAAd,KAAyB;AACzCX,EAAAA,KAAK,CAACY,IAAN,CAAWb,IAAX;AACA,MAAIc,CAAC,GAAGb,KAAK,CAACc,MAAd;;AACA,SAAMd,KAAK,CAACe,IAAI,CAACC,KAAL,CAAWH,CAAC,GAAG,CAAf,IAAoB,CAArB,CAAL,IAAgCF,MAAM,CAACX,KAAK,CAACa,CAAC,GAAG,CAAL,CAAN,EAAgBb,KAAK,CAACe,IAAI,CAACC,KAAL,CAAWH,CAAC,GAAG,CAAf,IAAoB,CAArB,CAArB,CAA5C,EAA0F;AACxF,QAAII,YAAY,GAAGjB,KAAK,CAACa,CAAC,GAAG,CAAL,CAAxB;AACAb,IAAAA,KAAK,CAACa,CAAC,GAAG,CAAL,CAAL,GAAeb,KAAK,CAACe,IAAI,CAACC,KAAL,CAAWH,CAAC,GAAG,CAAf,IAAoB,CAArB,CAApB;AACAb,IAAAA,KAAK,CAACe,IAAI,CAACC,KAAL,CAAWH,CAAC,GAAG,CAAf,IAAoB,CAArB,CAAL,GAA+BI,YAA/B;AACAJ,IAAAA,CAAC,GAAGE,IAAI,CAACC,KAAL,CAAWH,CAAC,GAAG,CAAf,CAAJ;AACD;;AACD,SAAOb,KAAP;AACD,CAVH;;AAYE,MAAMkB,gBAAgB,GAAG,CAAClB,KAAD,EAASW,MAAT,KAAoB;AAC3C,MAAIE,CAAC,GAAG,CAAR;AACAb,EAAAA,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAACA,KAAK,CAACc,MAAN,GAAe,CAAhB,CAAhB;AACAd,EAAAA,KAAK,CAACmB,GAAN;AACA,MAAIF,YAAY,GAAGjB,KAAK,CAAC,CAAD,CAAxB;AACA,MAAIoB,IAAI,GAAG,KAAX;;AACA,SAAM,CAACA,IAAP,EAAa;AACX,QAAIC,UAAU,GAAGrB,KAAK,CAAE,IAAIa,CAAL,GAAU,CAAX,CAAtB;AACA,QAAIS,WAAW,GAAGtB,KAAK,CAAE,IAAIa,CAAN,CAAvB;AACA,QAAIU,eAAJ;;AACA,QAAGF,UAAU,IAAIC,WAAjB,EAA6B;AAC3BC,MAAAA,eAAe,GAAGZ,MAAM,CAACU,UAAD,EAAYC,WAAZ,CAAN,GAAiC,IAAIT,CAArC,GAAyC,IAAIA,CAAJ,GAAQ,CAAnE;AACD,KAFD,MAEM,IAAGQ,UAAU,IAAIC,WAAjB,EAA6B;AACjCC,MAAAA,eAAe,GAAGF,UAAU,GAAG,IAAIR,CAAP,GAAW,IAAIA,CAAJ,GAAQ,CAA/C;AACD;;AAED,QAAGU,eAAe,IAAIZ,MAAM,CAACX,KAAK,CAACuB,eAAe,GAAG,CAAnB,CAAN,EAA6BN,YAA7B,CAA5B,EAAuE;AACrEjB,MAAAA,KAAK,CAACa,CAAC,GAAG,CAAL,CAAL,GAAeb,KAAK,CAACuB,eAAe,GAAG,CAAnB,CAApB;AACAvB,MAAAA,KAAK,CAACuB,eAAe,GAAG,CAAnB,CAAL,GAA6BN,YAA7B;AACAA,MAAAA,YAAY,GAAGjB,KAAK,CAACuB,eAAe,GAAG,CAAnB,CAApB;AACAV,MAAAA,CAAC,GAAGU,eAAJ;AACD,KALD,MAKK;AACHH,MAAAA,IAAI,GAAG,IAAP;AACD;AACF;;AACD,SAAOpB,KAAP;AACD,CA1BD;;AA4BF,SAAQF,yBAAR,EAAoCY,WAApC,EAAkDQ,gBAAlD","sourcesContent":["const get_top_right_bottom_left = (node , array , size) => {\n    let {x , y} = node\n    let top = array.find(n => n.x === x && n.y === y - size)\n    let right = array.find(n => n.x === x + size && n.y === y)\n    let bottom = array.find(n => n.x === x && n.y === y + size)\n    let left = array.find(n => n.x === x - size && n.y === y)\n\n    return {top , right , bottom , left }\n}\n\nconst add_to_heap = (node, array, method) => {\n    array.push(node)\n    let i = array.length \n    while(array[Math.floor(i / 2) - 1] && method(array[i - 1] , array[Math.floor(i / 2) - 1])){\n      let current_node = array[i - 1]\n      array[i - 1] = array[Math.floor(i / 2) - 1]\n      array[Math.floor(i / 2) - 1] = current_node\n      i = Math.floor(i / 2)\n    }\n    return array \n  }\n  \n  const remove_from_heap = (array , method) => {\n    let i = 1\n    array[0] = array[array.length - 1]\n    array.pop()\n    let current_node = array[0]\n    let stop = false\n    while(!stop) {\n      let left_child = array[(2 * i) - 1]\n      let right_child = array[(2 * i)]\n      let max_child_index \n      if(left_child && right_child){\n        max_child_index = method(left_child,right_child) ? 2 * i : 2 * i + 1\n      }else if(left_child || right_child){\n        max_child_index = left_child ? 2 * i : 2 * i + 1\n      }\n  \n      if(max_child_index && method(array[max_child_index - 1] ,current_node)){\n        array[i - 1] = array[max_child_index - 1]\n        array[max_child_index - 1] = current_node \n        current_node = array[max_child_index - 1]\n        i = max_child_index\n      }else{\n        stop = true\n      }\n    }\n    return array \n  }\n\nexport {get_top_right_bottom_left , add_to_heap , remove_from_heap}"]},"metadata":{},"sourceType":"module"}