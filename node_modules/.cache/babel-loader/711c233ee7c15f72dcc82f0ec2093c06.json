{"ast":null,"code":"const print_close_and_open_list = (close_list, open_list, close_color, open_color, finish_search) => {\n  if (!finish_search) {\n    for (let i = 0; i < open_list.length; i++) {\n      open_list[i].color = open_color;\n      open_list[i].draw();\n    }\n  }\n\n  for (let i = 0; i < close_list.length; i++) {\n    if (!finish_search) {\n      close_list[i].color = close_color;\n    }\n\n    close_list[i].draw();\n  }\n};\n\nconst check_for_mix_node = (target_close_list, x, y) => {\n  let node = target_close_list.find(node => node.x === x && node.y === y);\n\n  if (node) {\n    finish_search = true;\n\n    if (close_list_1.find(node => node.x === x && node.y === y)) {\n      current_node_1 = node;\n    } else {\n      current_node_2 = node;\n    }\n\n    return true;\n  }\n\n  return false;\n};\n\nexport { print_close_and_open_list, check_for_mix_node };","map":{"version":3,"sources":["/Users/vienpham/Desktop/Algorithms_simulation/algorithms/src/Algorithms/solve_maze/bidirectional_helper_method/helper_method.js"],"names":["print_close_and_open_list","close_list","open_list","close_color","open_color","finish_search","i","length","color","draw","check_for_mix_node","target_close_list","x","y","node","find","close_list_1","current_node_1","current_node_2"],"mappings":"AAAA,MAAMA,yBAAyB,GAAG,CAACC,UAAD,EAAcC,SAAd,EAA0BC,WAA1B,EAAwCC,UAAxC,EAAqDC,aAArD,KAAuE;AACrG,MAAG,CAACA,aAAJ,EAAkB;AACd,SAAI,IAAIC,CAAC,GAAG,CAAZ,EAAgBA,CAAC,GAAGJ,SAAS,CAACK,MAA9B,EAAuCD,CAAC,EAAxC,EAA4C;AACxCJ,MAAAA,SAAS,CAACI,CAAD,CAAT,CAAaE,KAAb,GAAqBJ,UAArB;AACAF,MAAAA,SAAS,CAACI,CAAD,CAAT,CAAaG,IAAb;AACH;AACJ;;AAED,OAAI,IAAIH,CAAC,GAAG,CAAZ,EAAgBA,CAAC,GAAGL,UAAU,CAACM,MAA/B,EAAwCD,CAAC,EAAzC,EAA6C;AACzC,QAAG,CAACD,aAAJ,EAAkB;AACdJ,MAAAA,UAAU,CAACK,CAAD,CAAV,CAAcE,KAAd,GAAsBL,WAAtB;AACH;;AACDF,IAAAA,UAAU,CAACK,CAAD,CAAV,CAAcG,IAAd;AACH;AACJ,CAdD;;AAgBA,MAAMC,kBAAkB,GAAG,CAACC,iBAAD,EAAqBC,CAArB,EAAyBC,CAAzB,KAA+B;AACtD,MAAIC,IAAI,GAAGH,iBAAiB,CAACI,IAAlB,CAAuBD,IAAI,IAAIA,IAAI,CAACF,CAAL,KAAWA,CAAX,IAAgBE,IAAI,CAACD,CAAL,KAAWA,CAA1D,CAAX;;AACA,MAAGC,IAAH,EAAQ;AACJT,IAAAA,aAAa,GAAG,IAAhB;;AACA,QAAGW,YAAY,CAACD,IAAb,CAAkBD,IAAI,IAAIA,IAAI,CAACF,CAAL,KAAWA,CAAX,IAAiBE,IAAI,CAACD,CAAL,KAAWA,CAAtD,CAAH,EAA4D;AACxDI,MAAAA,cAAc,GAAGH,IAAjB;AACH,KAFD,MAEK;AACDI,MAAAA,cAAc,GAAGJ,IAAjB;AACH;;AACD,WAAO,IAAP;AACH;;AACD,SAAO,KAAP;AACH,CAZD;;AAcA,SAAQd,yBAAR,EAAoCU,kBAApC","sourcesContent":["const print_close_and_open_list = (close_list , open_list , close_color , open_color , finish_search) => {\n    if(!finish_search){\n        for(let i = 0 ; i < open_list.length ; i ++){\n            open_list[i].color = open_color\n            open_list[i].draw()\n        }\n    }\n\n    for(let i = 0 ; i < close_list.length ; i ++){\n        if(!finish_search){\n            close_list[i].color = close_color \n        }\n        close_list[i].draw()\n    }\n}\n\nconst check_for_mix_node = (target_close_list , x , y) => {\n    let node = target_close_list.find(node => node.x === x && node.y === y)\n    if(node){\n        finish_search = true \n        if(close_list_1.find(node => node.x === x  && node.y === y)){\n            current_node_1 = node\n        }else{\n            current_node_2 = node\n        }\n        return true \n    }\n    return false \n}\n\nexport {print_close_and_open_list , check_for_mix_node}"]},"metadata":{},"sourceType":"module"}