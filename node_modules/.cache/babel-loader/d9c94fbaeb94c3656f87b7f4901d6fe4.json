{"ast":null,"code":"import { Block } from '../helper_method';\nimport { get_top_right_bottom_left, add_to_heap, remove_from_heap } from './helper_method/algorithms_helper_method';\nlet start_node, end_node, nodes, c, canvas, size;\nlet open_list_1, close_list_1, current_node_1, open_list_2, close_list_2, current_node_2, myReq, finish_path, finish_search;\n\nconst bidirectional_a_star = props => {\n  start_node = props.start_node;\n  end_node = props.end_node;\n  nodes = props.nodes;\n  c = props.c;\n  canvas = props.canvas;\n  size = props.size;\n  open_list_1 = [start_node];\n  close_list_1 = [];\n  open_list_2 = [end_node];\n  close_list_2 = [];\n  current_node_1 = null;\n  current_node_2 = null;\n  finish_path = false;\n  finish_search = false;\n  cancelAnimationFrame(myReq);\n  run_solve_maze();\n};\n\nconst stop_bidirectional_a_star = () => {\n  cancelAnimationFrame(myReq);\n};\n\nconst run_solve_maze = () => {\n  myReq = requestAnimationFrame(run_solve_maze);\n  c.clearRect(0, 0, canvas.width, canvas.height);\n\n  for (let i = 0; i < nodes.length; i++) {\n    nodes[i].draw();\n  }\n\n  print_close_and_open_list(close_list_1, open_list_1, 'MediumBlue', 'LightSkyBlue');\n  print_close_and_open_list(close_list_2, open_list_2, 'CadetBlue', 'LightCyan');\n\n  if (open_list_1.length > 0 && !finish_search) {\n    current_node_1 = open_list_1[0];\n    close_list_1.push(current_node_1);\n    open_list_1 = find_child_node(current_node_1, end_node, open_list_1, close_list_1, close_list_2);\n  }\n\n  if (open_list_2.length > 0 && !finish_search) {\n    current_node_2 = open_list_2[0];\n    close_list_2.push(current_node_2);\n    open_list_2 = find_child_node(current_node_2, start_node, open_list_2, close_list_2, close_list_1);\n  }\n\n  if (finish_search) {\n    start_node.draw();\n    end_node.draw();\n\n    if (!current_node_1 && !current_node_2) {\n      finish_path = true;\n    }\n\n    find_path();\n  }\n\n  if (finish_path || !open_list_1.length && !open_list_2.length) {\n    cancelAnimationFrame(myReq);\n  }\n};\n\nconst print_close_and_open_list = (close_list, open_list, close_color, open_color) => {\n  if (!finish_search) {\n    for (let i = 0; i < open_list.length; i++) {\n      open_list[i].color = open_color;\n      open_list[i].draw();\n    }\n  }\n\n  for (let i = 0; i < close_list.length; i++) {\n    if (!finish_search) {\n      close_list[i].color = close_color;\n    }\n\n    close_list[i].draw();\n  }\n};\n\nconst check_for_mix_node = (target_close_list, x, y) => {\n  let node = target_close_list.find(node => node.x === x && node.y === y);\n\n  if (node) {\n    finish_search = true;\n\n    if (close_list_1.find(node => node.x === x && node.y === y)) {\n      current_node_1 = node;\n    } else {\n      current_node_2 = node;\n    }\n\n    return true;\n  }\n\n  return false;\n};\n\nconst find_child_node = (c_node, target_node, open_list, close_list, target_close_list) => {\n  open_list = remove_from_heap(open_list, (a, b) => a.f < b.f);\n  let {\n    top,\n    right,\n    bottom,\n    left\n  } = get_top_right_bottom_left(c_node, nodes, size); // right (x + size , y)\n\n  open_list = add_node(c_node, right, 3, close_list, open_list, target_close_list, target_node); // top (x , y - size)\n\n  open_list = add_node(c_node, top, 2, close_list, open_list, target_close_list, target_node); // left (x - size , y )\n\n  open_list = add_node(c_node, left, 1, close_list, open_list, target_close_list, target_node); // bottom (x , y + size)\n\n  open_list = add_node(c_node, bottom, 0, close_list, open_list, target_close_list, target_node);\n  return open_list;\n};\n\nconst add_node = (c_node, neighbor_node, wall_num, close_list, open_list, target_close_list, target_node) => {\n  if (neighbor_node && !neighbor_node.walls[wall_num] && !close_list.find(node => node.x === neighbor_node.x && node.y === neighbor_node.y)) {\n    let {\n      x,\n      y\n    } = neighbor_node;\n    let node_in_open = open_list.find(n => n.x === x && n.y === y);\n    let n_g = c_node.g + size;\n\n    if (!check_for_mix_node(target_close_list, x, y)) {\n      if (node_in_open && n_g < node_in_open.g) {\n        update_node(node_in_open, n_g, c_node);\n      } else {\n        let new_node = set_node(neighbor_node, n_g, c_node, target_node);\n        open_list = add_to_heap(new_node, open_list, (a, b) => a.f < b.f);\n      }\n    }\n  }\n\n  return open_list;\n};\n\nconst find_path = () => {\n  let color = \"SpringGreen\";\n\n  if (current_node_1) {\n    current_node_1.color = color;\n    current_node_1 = current_node_1.prev_node;\n  }\n\n  if (current_node_2) {\n    current_node_2.color = color;\n    current_node_2 = current_node_2.prev_node;\n  }\n};\n\nconst set_node = (node, g, c_node, target_node) => {\n  let color = \"MediumBlue\";\n  let x_1 = node.x;\n  let y_1 = node.y;\n  let x_2 = target_node.x;\n  let y_2 = target_node.y;\n  let h = (Math.abs(x_1 - x_2) + Math.abs(y_1 - y_2)) * size;\n  let f = h + g;\n  let new_node = new Block(x_1, y_1, c, size, color, c_node, g, h, f);\n  return new_node;\n};\n\nconst update_node = (node, g, parent) => {\n  node.g = g;\n  node.f = g + node.h;\n  node.parent = parent;\n};\n\nexport { bidirectional_a_star, stop_bidirectional_a_star };","map":{"version":3,"sources":["/Users/vienpham/Desktop/Algorithms_simulation/algorithms/src/Algorithms/solve_maze/bidirectional_a_star.js"],"names":["Block","get_top_right_bottom_left","add_to_heap","remove_from_heap","start_node","end_node","nodes","c","canvas","size","open_list_1","close_list_1","current_node_1","open_list_2","close_list_2","current_node_2","myReq","finish_path","finish_search","bidirectional_a_star","props","cancelAnimationFrame","run_solve_maze","stop_bidirectional_a_star","requestAnimationFrame","clearRect","width","height","i","length","draw","print_close_and_open_list","push","find_child_node","find_path","close_list","open_list","close_color","open_color","color","check_for_mix_node","target_close_list","x","y","node","find","c_node","target_node","a","b","f","top","right","bottom","left","add_node","neighbor_node","wall_num","walls","node_in_open","n","n_g","g","update_node","new_node","set_node","prev_node","x_1","y_1","x_2","y_2","h","Math","abs","parent"],"mappings":"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","sourcesContent":["import { Block } from '../helper_method'\nimport {get_top_right_bottom_left , add_to_heap , remove_from_heap} from './helper_method/algorithms_helper_method'\n\nlet start_node , end_node , nodes , c , canvas , size \n\nlet open_list_1 , close_list_1 , current_node_1 , open_list_2 , close_list_2 , current_node_2 , myReq , finish_path , finish_search \n\nconst bidirectional_a_star = props => {\n    start_node = props.start_node\n    end_node = props.end_node \n    nodes = props.nodes\n    c = props.c \n    canvas = props.canvas \n    size = props.size \n\n    open_list_1 = [start_node]\n    close_list_1 = []\n\n    open_list_2 = [end_node]\n    close_list_2 = []\n\n    current_node_1 = null \n    current_node_2 = null \n\n    finish_path = false \n    finish_search = false \n\n    cancelAnimationFrame(myReq)\n    run_solve_maze()\n}\n\nconst stop_bidirectional_a_star = () => {\n    cancelAnimationFrame(myReq)\n}\n\nconst run_solve_maze = () => {\n    myReq = requestAnimationFrame(run_solve_maze)\n    c.clearRect(0,0,canvas.width, canvas.height)\n\n    for(let i = 0 ; i < nodes.length ; i ++){\n        nodes[i].draw()\n    }\n\n    print_close_and_open_list(close_list_1 , open_list_1 , 'MediumBlue' , 'LightSkyBlue' )\n    print_close_and_open_list(close_list_2 , open_list_2 , 'CadetBlue' , 'LightCyan')\n\n    if(open_list_1.length > 0 && !finish_search){\n        current_node_1= open_list_1[0]\n        close_list_1.push(current_node_1)\n        open_list_1 = find_child_node(current_node_1 , end_node, open_list_1 , close_list_1 , close_list_2)\n    }\n\n    if(open_list_2.length > 0 && !finish_search){\n        current_node_2= open_list_2[0]\n        close_list_2.push(current_node_2)\n        open_list_2 = find_child_node(current_node_2 , start_node, open_list_2 , close_list_2 , close_list_1)\n    }\n\n    if(finish_search){\n        start_node.draw()\n        end_node.draw()\n\n        if(!current_node_1 && !current_node_2){\n            finish_path = true\n        }\n        find_path() \n    }\n\n    if(finish_path || (!open_list_1.length && !open_list_2.length)){\n        cancelAnimationFrame(myReq)\n    }\n}\n\nconst print_close_and_open_list = (close_list , open_list , close_color , open_color) => {\n    if(!finish_search){\n        for(let i = 0 ; i < open_list.length ; i ++){\n            open_list[i].color = open_color\n            open_list[i].draw()\n        }\n    }\n\n    for(let i = 0 ; i < close_list.length ; i ++){\n        if(!finish_search){\n            close_list[i].color = close_color \n        }\n        close_list[i].draw()\n    }\n}\n\nconst check_for_mix_node = (target_close_list , x , y) => {\n    let node = target_close_list.find(node => node.x === x && node.y === y)\n    if(node){\n        finish_search = true \n        if(close_list_1.find(node => node.x === x  && node.y === y)){\n            current_node_1 = node\n        }else{\n            current_node_2 = node\n        }\n        return true \n    }\n    return false \n}\n\nconst find_child_node = (c_node , target_node , open_list , close_list , target_close_list) => {\n    open_list = remove_from_heap(open_list , (a,b) => a.f < b.f)\n    let {top , right , bottom , left} = get_top_right_bottom_left(c_node , nodes , size)\n\n    // right (x + size , y)\n    open_list = add_node(c_node , right , 3 , close_list , open_list , target_close_list , target_node)\n\n    // top (x , y - size)\n    open_list = add_node(c_node , top , 2 , close_list , open_list , target_close_list , target_node)\n\n    // left (x - size , y )\n    open_list = add_node(c_node , left , 1 , close_list , open_list , target_close_list , target_node)\n\n    // bottom (x , y + size)\n    open_list = add_node(c_node , bottom , 0 , close_list , open_list , target_close_list , target_node)\n\n    return open_list\n}\n\nconst add_node = (c_node , neighbor_node , wall_num , close_list , open_list , target_close_list , target_node) => {\n    if(\n        neighbor_node \n        && !neighbor_node.walls[wall_num] \n        && !close_list.find(node => node.x === neighbor_node.x  && node.y === neighbor_node.y)\n    ){\n        let {x , y} = neighbor_node \n        let node_in_open = open_list.find(n => n.x === x  && n.y === y)\n        let n_g = c_node.g + size\n\n        if(!check_for_mix_node(target_close_list , x , y)){\n            if(node_in_open && n_g < node_in_open.g){ \n                update_node(node_in_open, n_g , c_node )\n            }else{\n                let new_node = set_node(neighbor_node , n_g , c_node , target_node)\n                open_list = add_to_heap(new_node , open_list , (a,b) => a.f < b.f)\n            }\n        }\n    }\n    return open_list\n}\n\nconst find_path = () => {\n    let color = \"SpringGreen\"\n    if(current_node_1){\n        current_node_1.color = color\n        current_node_1 = current_node_1.prev_node\n    }\n    if(current_node_2){\n        current_node_2.color = color\n        current_node_2 = current_node_2.prev_node \n    }\n}\n\nconst set_node = (node, g , c_node , target_node) => {\n    let color = \"MediumBlue\"\n    let x_1 = node.x \n    let y_1 = node.y \n    let x_2 = target_node.x \n    let y_2 = target_node.y    \n    let h = (Math.abs(x_1 - x_2) + Math.abs(y_1 - y_2)) * size \n    let f = h + g \n    let new_node = new Block(x_1 , y_1 , c , size , color , c_node , g , h , f)\n    return new_node \n}\n\nconst update_node = (node , g , parent) => {\n    node.g = g \n    node.f = g + node.h \n    node.parent = parent \n}\n\nexport {bidirectional_a_star , stop_bidirectional_a_star}"]},"metadata":{},"sourceType":"module"}