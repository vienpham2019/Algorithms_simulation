{"ast":null,"code":"import { Block } from '../helper_method';\nlet c, canvas, size, visited_nodes, nodes, stack, current_node, start_node, end_node, finish_path, myReq;\n\nconst depth_first_search = props => {\n  c = props.c;\n  canvas = props.canvas;\n  size = props.size;\n  visited_nodes = [];\n  nodes = props.nodes;\n  finish_path = false;\n  start_node = props.start_node;\n  end_node = props.end_node;\n  stack = [start_node];\n  current_node = start_node;\n  stack.push(start_node);\n  cancelAnimationFrame(myReq);\n  run_solve_maze();\n};\n\nconst stop_depth_first_search = () => {\n  cancelAnimationFrame(myReq);\n};\n\nconst run_solve_maze = () => {\n  myReq = requestAnimationFrame(run_solve_maze);\n  c.clearRect(0, 0, canvas.width, canvas.height);\n\n  for (let i = 0; i < nodes.length; i++) {\n    nodes[i].draw();\n  }\n\n  for (let i = 0; i < visited_nodes.length; i++) {\n    console.log(current_node.x, current_node.y);\n\n    if (visited_nodes[i].x === current_node.x && visited_nodes.y === current_node.y) {\n      console.log('visit');\n      visited_nodes[i].draw('red');\n    } else {\n      visited_nodes[i].draw('MidnightBlue');\n    }\n  }\n\n  if (stack.length > 0 && !end_node.prev_node) {\n    let is_neighbor = check_neighbor_node();\n\n    if (!is_neighbor) {\n      current_node = stack.shift();\n    }\n  }\n\n  if (end_node.prev_node) {\n    find_path();\n  }\n\n  if (finish_path) {\n    cancelAnimationFrame(myReq);\n  }\n};\n\nconst find_path = () => {\n  current_node.color = \"green\";\n\n  if (current_node.x === start_node.x && current_node.y === start_node.y) {\n    finish_path = true;\n    return;\n  }\n\n  current_node = current_node.prev_node;\n};\n\nconst check_neighbor_node = () => {\n  let {\n    x,\n    y\n  } = current_node; // block \n\n  let color = \"MidnightBlue\";\n  let current_find_node = nodes.find(c_n => c_n.x === x && c_n.y === y); // bottom\n\n  let bottom = nodes.find(n => n.x === x && n.y === y + size);\n\n  if (bottom && !current_find_node.walls[2] && !visited_nodes.find(n => n.x === bottom.x && n.y === bottom.y)) {\n    let bottom_x = bottom.x;\n    let bottom_y = bottom.y;\n\n    if (bottom_x === end_node.x && bottom_y === end_node.y) {\n      end_node.prev_node = current_node;\n    } else {\n      let bottom_block = new Block(bottom_x, bottom_y, c, size, color, current_node);\n      stack = [bottom_block, ...stack];\n      visited_nodes.push(bottom_block);\n      current_node = bottom_block;\n    }\n\n    return true;\n  } // right\n\n\n  let right = nodes.find(n => n.x === x + size && n.y === y);\n\n  if (right && !current_find_node.walls[1] && !visited_nodes.find(n => n.x === right.x && n.y === right.y)) {\n    let right_x = right.x;\n    let right_y = right.y;\n\n    if (right_x === end_node.x && right_y === end_node.y) {\n      end_node.prev_node = current_node;\n    } else {\n      let right_block = new Block(right_x, right_y, c, size, color, current_node);\n      stack = [right_block, ...stack];\n      visited_nodes.push(right_block);\n      current_node = right_block;\n    }\n\n    return true;\n  } // top \n\n\n  let top = nodes.find(n => n.x === x && n.y === y - size);\n\n  if (top && !current_find_node.walls[0] && !visited_nodes.find(n => n.x === top.x && n.y === top.y)) {\n    let top_x = top.x;\n    let top_y = top.y;\n\n    if (top_x === end_node.x && top_y === end_node.y) {\n      end_node.prev_node = current_node;\n    } else {\n      let top_block = new Block(top_x, top_y, c, size, color, current_node);\n      stack = [top_block, ...stack];\n      visited_nodes.push(top_block);\n      current_node = top_block;\n    }\n\n    return true;\n  } // left \n\n\n  let left = nodes.find(n => n.x === x - size && n.y === y);\n\n  if (left && !current_find_node.walls[3] && !visited_nodes.find(n => n.x === left.x && n.y === left.y)) {\n    let left_x = left.x;\n    let left_y = left.y;\n\n    if (left_x === end_node.x && left_y === end_node.y) {\n      end_node.prev_node = current_node;\n    } else {\n      let left_block = new Block(left_x, left_y, c, size, color, current_node);\n      stack = [left_block, ...stack];\n      visited_nodes.push(left_block);\n      current_node = left_block;\n    }\n\n    return true;\n  }\n\n  return false;\n};\n\nexport { depth_first_search, stop_depth_first_search };","map":{"version":3,"sources":["/Users/vienpham/Desktop/Algorithms_simulation/algorithms/src/Algorithms/solve_maze/depth_first_search.js"],"names":["Block","c","canvas","size","visited_nodes","nodes","stack","current_node","start_node","end_node","finish_path","myReq","depth_first_search","props","push","cancelAnimationFrame","run_solve_maze","stop_depth_first_search","requestAnimationFrame","clearRect","width","height","i","length","draw","console","log","x","y","prev_node","is_neighbor","check_neighbor_node","shift","find_path","color","current_find_node","find","c_n","bottom","n","walls","bottom_x","bottom_y","bottom_block","right","right_x","right_y","right_block","top","top_x","top_y","top_block","left","left_x","left_y","left_block"],"mappings":"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","sourcesContent":["import {Block} from '../helper_method'\nlet \n    c , \n    canvas , \n    size , \n    visited_nodes , \n    nodes , \n    stack , \n    current_node , \n    start_node , \n    end_node , \n    finish_path , \n    myReq\n\nconst depth_first_search = (props) => {\n    c = props.c\n    canvas = props.canvas \n    size = props.size \n    visited_nodes = []\n    nodes = props.nodes \n\n    finish_path = false  \n    start_node = props.start_node\n    end_node = props.end_node\n\n    stack = [start_node]\n    current_node = start_node \n\n    stack.push(start_node)\n    cancelAnimationFrame(myReq)\n    run_solve_maze()\n}\n\nconst stop_depth_first_search = () => {\n    cancelAnimationFrame(myReq)\n}\n\nconst run_solve_maze = () => {\n    myReq = requestAnimationFrame(run_solve_maze)\n    c.clearRect(0,0,canvas.width, canvas.height)\n\n    for(let i = 0; i < nodes.length; i ++){\n        nodes[i].draw()\n    }\n\n    for(let i = 0; i < visited_nodes.length; i ++){\n        console.log(current_node.x , current_node.y)\n        if(visited_nodes[i].x === current_node.x && visited_nodes.y === current_node.y){\n            console.log('visit')\n            visited_nodes[i].draw('red')\n        }else{\n            visited_nodes[i].draw('MidnightBlue')\n        }\n    }\n\n    if(stack.length > 0 && !end_node.prev_node){\n        let is_neighbor = check_neighbor_node()\n        if(!is_neighbor){\n            current_node = stack.shift()\n        }\n    }\n\n    if(end_node.prev_node){\n        find_path() \n    }\n\n    if(finish_path){\n        cancelAnimationFrame(myReq)\n    }\n}\n\nconst find_path = () => {\n    current_node.color = \"green\"\n    if(current_node.x === start_node.x && current_node.y === start_node.y){\n        finish_path = true\n        return\n    }\n    current_node = current_node.prev_node\n}\n\nconst check_neighbor_node = () => {\n    let {x , y} = current_node // block \n    let color = \"MidnightBlue\"\n    let current_find_node = nodes.find(c_n => c_n.x === x && c_n.y === y )\n\n    // bottom\n    let bottom = nodes.find(n => n.x === x && n.y === y + size ) \n    if(bottom && !current_find_node.walls[2] && !visited_nodes.find(n => n.x === bottom.x  && n.y === bottom.y )){\n        let bottom_x = bottom.x \n        let bottom_y = bottom.y \n        if(bottom_x === end_node.x && bottom_y === end_node.y){\n            end_node.prev_node = current_node\n        }else{\n            let bottom_block = new Block(bottom_x, bottom_y, c , size ,color , current_node)\n            stack = [bottom_block,...stack]\n            visited_nodes.push(bottom_block)\n            current_node = bottom_block\n        }\n        return true \n    }\n\n    // right\n    let right = nodes.find(n => n.x === x + size && n.y === y )\n    if(right && !current_find_node.walls[1] && !visited_nodes.find(n => n.x === right.x  && n.y === right.y)){\n        let right_x = right.x \n        let right_y = right.y \n        if(right_x === end_node.x && right_y === end_node.y){\n            end_node.prev_node = current_node \n        }else{\n            let right_block = new Block(right_x, right_y, c , size , color ,current_node)\n            stack = [right_block,...stack]\n            visited_nodes.push(right_block)\n            current_node = right_block\n        }\n        return true \n    }\n\n    // top \n    let top = nodes.find(n => n.x === x && n.y === y - size)\n    if(top && !current_find_node.walls[0] && !visited_nodes.find(n => n.x === top.x && n.y === top.y)){\n        let top_x = top.x\n        let top_y = top.y\n        if(top_x === end_node.x && top_y === end_node.y){\n            end_node.prev_node = current_node\n        }else{\n            let top_block = new Block(top_x, top_y , c , size , color, current_node)\n            stack = [top_block,...stack]\n            visited_nodes.push(top_block)\n            current_node = top_block\n        }\n        return true\n    }\n\n    // left \n    let left = nodes.find(n => n.x === x - size && n.y === y)\n    if(left && !current_find_node.walls[3] && !visited_nodes.find(n => n.x === left.x && n.y === left.y)){\n        let left_x = left.x \n        let left_y = left.y \n        if(left_x === end_node.x && left_y === end_node.y){\n            end_node.prev_node = current_node \n        }else{\n            let left_block = new Block(left_x,left_y, c, size , color , current_node)\n            stack = [left_block,...stack]\n            visited_nodes.push(left_block)\n            current_node = left_block\n        }\n        return true \n    }\n\n    return false \n}\n\nexport { depth_first_search ,  stop_depth_first_search}"]},"metadata":{},"sourceType":"module"}