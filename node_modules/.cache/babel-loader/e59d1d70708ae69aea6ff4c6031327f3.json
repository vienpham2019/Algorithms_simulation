{"ast":null,"code":"import { get_top_right_bottom_left } from '../solve_maze/helper_method/algorithms_helper_method';\nlet size, nodes, cols, rows, canvas, c, frame_per_second, speed;\nlet neighbors_node, visited_neighbors_node, current_neighbor_node, myReqDraw;\n\nconst prims_maze = props => {\n  size = props.size;\n  nodes = props.nodes;\n  cols = props.cols;\n  rows = props.rows;\n  canvas = props.canvas;\n  c = props.c;\n  frame_per_second = props.frame_per_second;\n  speed = props.speed;\n  neighbors_node = [];\n  visited_neighbors_node = [];\n  current_neighbor_node = null;\n  clearInterval(myReqDraw);\n  setup_prims_maze(nodes, cols, rows);\n};\n\nconst setup_prims_maze = (nodes_array, w, h) => {\n  let midd_x = Math.floor(w / 2) * size + size / 2;\n  let midd_y = Math.floor(h / 2) * size + size / 2;\n  let center_node = nodes_array.find(node => node.x === midd_x && node.y === midd_y);\n  neighbors_node.push(center_node);\n  visited_neighbors_node.push(center_node);\n  current_neighbor_node = center_node;\n  draw_prims_maze();\n};\n\nconst draw_prims_maze = () => {\n  myReqDraw = setTimeout(() => {\n    draw_prims_maze();\n  }, frame_per_second / speed);\n  c.clearRect(0, 0, canvas.width, canvas.height);\n\n  for (let i = 0; i < nodes.length; i++) {\n    nodes[i].draw();\n  }\n\n  if (neighbors_node.length === 0) {\n    clearInterval(myReqDraw);\n  }\n\n  add_neighbor_node();\n};\n\nconst add_neighbor_node = () => {\n  let {\n    top,\n    right,\n    bottom,\n    left\n  } = get_top_right_bottom_left(current_neighbor_node, nodes, size); // top \n\n  create_neighbor_node(top); // if(\n  //     top \n  //     && !visited_neighbors_node.find(node => node.x === x && node.y === y - size)\n  //     && !neighbors_node.find(node => node.x === x && node.y === y - size)\n  // ){\n  //     neighbors_node.push(top)\n  //     top.prev_node = current_neighbor_node\n  // }\n  // right \n\n  create_neighbor_node(right); // if(\n  //     right \n  //     && !visited_neighbors_node.find(node => node.x === x + size && node.y === y)\n  //     && !neighbors_node.find(node => node.x === x + size && node.y === y)\n  // ){\n  //     neighbors_node.push(right)\n  //     right.prev_node = current_neighbor_node\n  // }\n  //bottom \n\n  create_neighbor_node(bottom); // if(\n  //     bottom \n  //     && !visited_neighbors_node.find(node => node.x === x && node.y === y + size)\n  //     && !neighbors_node.find(node => node.x === x && node.y === y + size)\n  // ){\n  //     neighbors_node.push(bottom)\n  //     bottom.prev_node = current_neighbor_node\n  // }\n  //left \n\n  create_neighbor_node(left); // if(\n  //     left \n  //     && !visited_neighbors_node.find(node => node.x === x - size && node.y === y)\n  //     && !neighbors_node.find(node => node.x === x - size && node.y === y)\n  // ){\n  //     neighbors_node.push(left)\n  //     left.prev_node = current_neighbor_node\n  // }\n\n  neighbors_node = neighbors_node.filter(node => node.x === x && node.y === y ? false : true);\n  link_node_with_random_neighbor();\n};\n\nconst create_neighbor_node = neighbor_node => {\n  if (neighbor_node && !visited_neighbors_node.find(node => node.x === neighbor_node.x && node.y === neighbor_node.y) && !neighbors_node.find(node => node.x === neighbor_node.x && node.y === neighbor_node.y)) {\n    neighbors_node.push(neighbor_node);\n    neighbor_node.prev_node = current_neighbor_node;\n  }\n};\n\nconst link_node_with_random_neighbor = () => {\n  if (neighbors_node.length === 0) return;\n  let random_num = getRandom(0, neighbors_node.length);\n  let random_neighbor = neighbors_node[random_num];\n  let {\n    top,\n    right,\n    bottom,\n    left\n  } = get_top_right_bottom_left(random_neighbor, visited_neighbors_node, size);\n\n  if (top && top.x === random_neighbor.prev_node.x && top.y === random_neighbor.prev_node.y) {\n    random_neighbor.walls[0] = false;\n    top.walls[2] = false;\n  }\n\n  if (right && right.x === random_neighbor.prev_node.x && right.y === random_neighbor.prev_node.y) {\n    random_neighbor.walls[1] = false;\n    right.walls[3] = false;\n  }\n\n  if (bottom && bottom.x === random_neighbor.prev_node.x && bottom.y === random_neighbor.prev_node.y) {\n    random_neighbor.walls[2] = false;\n    bottom.walls[0] = false;\n  }\n\n  if (left && left.x === random_neighbor.prev_node.x && left.y === random_neighbor.prev_node.y) {\n    random_neighbor.walls[3] = false;\n    left.walls[1] = false;\n  }\n\n  current_neighbor_node = random_neighbor;\n  visited_neighbors_node.push(random_neighbor);\n};\n\nconst getRandom = (min, max) => {\n  return Math.floor(Math.random() * (max - min) + min);\n};\n\nexport { prims_maze };","map":{"version":3,"sources":["/Users/vienpham/Desktop/Algorithms_simulation/algorithms/src/Algorithms/draw_maze/prims_maze_generation.js"],"names":["get_top_right_bottom_left","size","nodes","cols","rows","canvas","c","frame_per_second","speed","neighbors_node","visited_neighbors_node","current_neighbor_node","myReqDraw","prims_maze","props","clearInterval","setup_prims_maze","nodes_array","w","h","midd_x","Math","floor","midd_y","center_node","find","node","x","y","push","draw_prims_maze","setTimeout","clearRect","width","height","i","length","draw","add_neighbor_node","top","right","bottom","left","create_neighbor_node","filter","link_node_with_random_neighbor","neighbor_node","prev_node","random_num","getRandom","random_neighbor","walls","min","max","random"],"mappings":"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","sourcesContent":["import {get_top_right_bottom_left} from '../solve_maze/helper_method/algorithms_helper_method'\n\nlet size , nodes , cols , rows , canvas , c , frame_per_second , speed \nlet neighbors_node , visited_neighbors_node , current_neighbor_node , myReqDraw \nconst prims_maze = props => {\n    size = props.size\n    nodes = props.nodes \n    cols = props.cols \n    rows = props.rows \n    canvas = props.canvas \n    c = props.c \n\n    frame_per_second = props.frame_per_second\n    speed = props.speed\n\n    neighbors_node = []\n    visited_neighbors_node = []\n    current_neighbor_node = null \n    \n    clearInterval(myReqDraw)\n    setup_prims_maze(nodes , cols , rows)\n}\n\nconst setup_prims_maze = (nodes_array , w , h) => {\n    let midd_x =  Math.floor(w / 2) * size + (size / 2)\n    let midd_y =  Math.floor(h / 2) * size + (size / 2)\n    let center_node = nodes_array.find(node => node.x === midd_x && node.y === midd_y)\n    neighbors_node.push(center_node)\n    visited_neighbors_node.push(center_node)\n    current_neighbor_node = center_node\n\n    draw_prims_maze()\n}\n\nconst draw_prims_maze = () => {\n    myReqDraw = setTimeout(() => {\n        draw_prims_maze()\n    }, frame_per_second / speed)\n    c.clearRect(0,0,canvas.width, canvas.height)\n\n    for(let i = 0; i < nodes.length; i ++){\n        nodes[i].draw()\n    }\n\n    if(neighbors_node.length === 0){\n        clearInterval(myReqDraw)\n    }\n\n    add_neighbor_node()\n}\n\nconst add_neighbor_node = () => {\n    \n    let {top , right , bottom , left} = get_top_right_bottom_left(current_neighbor_node , nodes , size) \n\n    // top \n    create_neighbor_node(top)\n    // if(\n    //     top \n    //     && !visited_neighbors_node.find(node => node.x === x && node.y === y - size)\n    //     && !neighbors_node.find(node => node.x === x && node.y === y - size)\n    // ){\n    //     neighbors_node.push(top)\n    //     top.prev_node = current_neighbor_node\n    // }\n\n    // right \n    create_neighbor_node(right)\n\n    // if(\n    //     right \n    //     && !visited_neighbors_node.find(node => node.x === x + size && node.y === y)\n    //     && !neighbors_node.find(node => node.x === x + size && node.y === y)\n    // ){\n    //     neighbors_node.push(right)\n    //     right.prev_node = current_neighbor_node\n    // }\n\n    //bottom \n    create_neighbor_node(bottom)\n\n    // if(\n    //     bottom \n    //     && !visited_neighbors_node.find(node => node.x === x && node.y === y + size)\n    //     && !neighbors_node.find(node => node.x === x && node.y === y + size)\n    // ){\n    //     neighbors_node.push(bottom)\n    //     bottom.prev_node = current_neighbor_node\n    // }\n\n    //left \n    create_neighbor_node(left)\n\n    // if(\n    //     left \n    //     && !visited_neighbors_node.find(node => node.x === x - size && node.y === y)\n    //     && !neighbors_node.find(node => node.x === x - size && node.y === y)\n    // ){\n    //     neighbors_node.push(left)\n    //     left.prev_node = current_neighbor_node\n    // }\n\n    neighbors_node = neighbors_node.filter(node => node.x === x && node.y === y ? false : true )\n\n    link_node_with_random_neighbor()\n}\n\nconst create_neighbor_node = (neighbor_node) => {\n    if(\n        neighbor_node \n        && !visited_neighbors_node.find(node => node.x === neighbor_node.x && node.y === neighbor_node.y)\n        && !neighbors_node.find(node => node.x === neighbor_node.x && node.y === neighbor_node.y)\n    ){\n        neighbors_node.push(neighbor_node)\n        neighbor_node.prev_node = current_neighbor_node\n    }\n}\n\nconst link_node_with_random_neighbor = () => {\n    if(neighbors_node.length === 0) return\n    let random_num = getRandom(0 , neighbors_node.length)\n    let random_neighbor = neighbors_node[random_num]\n    let {top , right , bottom , left} = get_top_right_bottom_left(random_neighbor,visited_neighbors_node , size)\n\n    if(top && top.x === random_neighbor.prev_node.x && top.y === random_neighbor.prev_node.y){\n        random_neighbor.walls[0] = false \n        top.walls[2] = false\n    }\n\n    if(right && right.x === random_neighbor.prev_node.x && right.y === random_neighbor.prev_node.y){\n        random_neighbor.walls[1] = false \n        right.walls[3] = false\n    }\n\n    if(bottom && bottom.x === random_neighbor.prev_node.x && bottom.y === random_neighbor.prev_node.y){\n        random_neighbor.walls[2] = false \n        bottom.walls[0] = false\n    }\n\n    if(left && left.x === random_neighbor.prev_node.x && left.y === random_neighbor.prev_node.y){\n        random_neighbor.walls[3] = false \n        left.walls[1] = false\n    }\n\n    current_neighbor_node = random_neighbor\n    visited_neighbors_node.push(random_neighbor)\n}\n\n\nconst getRandom = (min,max) => {\n    return Math.floor(Math.random() * (max - min) + min)\n}\n\nexport {prims_maze}\n\n"]},"metadata":{},"sourceType":"module"}