{"ast":null,"code":"let c;\n\nconst Block = function (x, y, color = \"red\", prev_node = null) {\n  this.x = x;\n  this.y = y;\n  this.dx = size;\n  this.dy = size;\n  this.prev_node = prev_node;\n  this.color = color;\n\n  this.draw = () => {\n    c.beginPath();\n    c.rect(this.x + size / 8, this.y + size / 8, size * (3 / 4), size * (3 / 4));\n    c.fillStyle = this.color;\n    c.fill();\n  };\n\n  this.move = () => {\n    let current_node = stack[0];\n    let neighbor_nodes = [];\n    let x = current_node.x;\n    let y = current_node.y; // top\n\n    if (y - size > 0 && !visited_nodes.find(n => n.x === x && n.y === y - size)) {\n      let top = nodes.find(n => n.x === x && n.y === y - size);\n      neighbor_nodes.push(top);\n    } // right \n\n\n    if (x + size < width && !visited_nodes.find(n => n.x === x + size && n.y === y)) {\n      let right = nodes.find(n => n.x === x + size && n.y === y);\n      neighbor_nodes.push(right);\n    } // bottom\n\n\n    if (y + size < height && !visited_nodes.find(n => n.x === x && n.y === y + size)) {\n      let bottom = nodes.find(n => n.x === x && n.y === y + size);\n      neighbor_nodes.push(bottom);\n    } // left\n\n\n    if (x - size > 0 && !visited_nodes.find(n => n.x === x - size && n.y === y)) {\n      let left = nodes.find(n => n.x === x - size && n.y === y);\n      neighbor_nodes.push(left);\n    }\n\n    if (neighbor_nodes.length > 0) {\n      let next_node = neighbor_nodes[Math.floor(Math.random() * neighbor_nodes.length)];\n      stack.unshift(next_node);\n      visited_nodes.push(next_node);\n      this.dx = next_node.x - current_node.x;\n      this.dy = next_node.y - current_node.y;\n      this.x += this.dx;\n      this.y += this.dy;\n\n      if (this.dx > 0) {\n        // right \n        current_node.walls[1] = false;\n        next_node.walls[3] = false;\n      } else if (this.dx < 0) {\n        // left\n        current_node.walls[3] = false;\n        next_node.walls[1] = false;\n      }\n\n      if (this.dy > 0) {\n        // down\n        current_node.walls[2] = false;\n        next_node.walls[0] = false;\n      } else if (this.dy < 0) {\n        // up\n        current_node.walls[0] = false;\n        next_node.walls[2] = false;\n      }\n    } else {\n      let dx = current_node.x - (this.x + size / 2);\n      let dy = current_node.y - (this.y + size / 2);\n      this.x += dx;\n      this.y += dy;\n      stack.shift();\n    }\n\n    this.draw();\n  };\n};\n\nconst Node = function (x, y, neighbor_node = [], prev_node = null) {\n  this.x = x;\n  this.y = y;\n  this.neighbor_node = neighbor_node;\n  this.prev_node = prev_node;\n  this.walls = [true, true, true, true]; // [top, right , bottom , left ]\n\n  this.draw = (color = \"white\") => {\n    let x = this.x - size / 2;\n    let y = this.y - size / 2; // Top \n\n    if (this.walls[0]) {\n      c.beginPath();\n      c.moveTo(x, y);\n      c.lineTo(x + size, y);\n      c.lineWidth = 4;\n      c.lineCap = \"round\";\n      c.strokeStyle = color;\n      c.stroke();\n    } // right\n\n\n    if (this.walls[1]) {\n      c.beginPath();\n      c.moveTo(x + size, y);\n      c.lineTo(x + size, y + size);\n      c.lineWidth = 4;\n      c.lineCap = \"round\";\n      c.strokeStyle = color;\n      c.stroke();\n    } // bottom\n\n\n    if (this.walls[2]) {\n      c.beginPath();\n      c.moveTo(x + size, y + size);\n      c.lineTo(x, y + size);\n      c.lineWidth = 4;\n      c.lineCap = \"round\";\n      c.strokeStyle = color;\n      c.stroke();\n    } // left \n\n\n    if (this.walls[3]) {\n      c.beginPath();\n      c.moveTo(x, y + size);\n      c.lineTo(x, y);\n      c.lineWidth = 4;\n      c.lineCap = \"round\";\n      c.strokeStyle = color;\n      c.stroke();\n    }\n  };\n};\n\nconst setup_block_and_node = ctx => {\n  c = ctx;\n};\n\nexport { Block, Node, setup_block_and_node };","map":{"version":3,"sources":["/Users/vienpham/Desktop/Algorithms_simulation/algorithms/src/Algorithms/helper_method.js"],"names":["c","Block","x","y","color","prev_node","dx","size","dy","draw","beginPath","rect","fillStyle","fill","move","current_node","stack","neighbor_nodes","visited_nodes","find","n","top","nodes","push","width","right","height","bottom","left","length","next_node","Math","floor","random","unshift","walls","shift","Node","neighbor_node","moveTo","lineTo","lineWidth","lineCap","strokeStyle","stroke","setup_block_and_node","ctx"],"mappings":"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","sourcesContent":["let c \n\nconst Block = function(x , y , color = \"red\", prev_node = null){\n    this.x = x \n    this.y = y \n    this.dx = size\n    this.dy = size\n    this.prev_node  = prev_node\n    this.color = color\n\n    this.draw = () => {\n        c.beginPath()\n        c.rect(this.x + size / 8 , this.y + size / 8, size * (3 / 4), size * (3 /4))\n        c.fillStyle = this.color\n        c.fill()\n    }\n\n    this.move = () => {\n        let current_node = stack[0]\n        let neighbor_nodes = []\n        let x = current_node.x\n        let y = current_node.y\n\n        // top\n        if(y - size > 0 && !visited_nodes.find(n => n.x === x && n.y === y - size)){\n            let top = nodes.find(n => n.x === x && n.y === y - size)\n            neighbor_nodes.push(top)\n        }\n\n        // right \n        if(x + size < width && !visited_nodes.find(n => n.x === x + size && n.y === y)){\n            let right = nodes.find(n => n.x === x + size && n.y === y)\n            neighbor_nodes.push(right)\n        }\n\n        // bottom\n        if(y + size < height && !visited_nodes.find(n => n.x === x && n.y === y + size)){\n            let bottom = nodes.find(n => n.x === x && n.y === y + size)\n            neighbor_nodes.push(bottom)\n        }\n\n        // left\n        if(x - size > 0 && !visited_nodes.find(n => n.x === x - size && n.y === y)){\n            let left = nodes.find(n => n.x === x - size && n.y === y)\n            neighbor_nodes.push(left)\n        }\n\n        if(neighbor_nodes.length > 0){\n            let next_node = neighbor_nodes[Math.floor(Math.random() * neighbor_nodes.length)]\n            stack.unshift(next_node)\n            visited_nodes.push(next_node)\n            this.dx = next_node.x - current_node.x\n            this.dy = next_node.y - current_node.y\n\n            this.x += this.dx \n            this.y += this.dy\n\n            if(this.dx > 0) { // right \n                current_node.walls[1] = false \n                next_node.walls[3] = false \n            }else if(this.dx < 0){ // left\n                current_node.walls[3] = false \n                next_node.walls[1] = false \n            } \n\n            if(this.dy > 0) { // down\n                current_node.walls[2] = false \n                next_node.walls[0] = false \n            }else if(this.dy < 0){ // up\n                current_node.walls[0] = false \n                next_node.walls[2] = false \n            }\n        }else{\n            let dx = current_node.x  - (this.x + (size / 2))\n            let dy = current_node.y  - (this.y + (size / 2))\n            this.x += dx \n            this.y += dy\n            stack.shift()\n        }\n        this.draw()\n    }\n}\n\nconst Node = function(x , y , neighbor_node = [], prev_node = null){\n    this.x = x\n    this.y = y\n    this.neighbor_node = neighbor_node\n    this.prev_node = prev_node \n    this.walls = [true,true,true,true] // [top, right , bottom , left ]\n\n    this.draw = (color = \"white\") => {\n        let x = this.x - (size / 2)\n        let y = this.y - (size / 2)\n\n        // Top \n        if(this.walls[0]){\n            c.beginPath()\n            c.moveTo(x, y)\n            c.lineTo(x + size , y)\n            c.lineWidth = 4\n            c.lineCap = \"round\"\n            c.strokeStyle = color\n            c.stroke()\n        }\n\n        // right\n        if(this.walls[1]){\n            c.beginPath()\n            c.moveTo(x + size, y)\n            c.lineTo(x + size , y +size)\n            c.lineWidth = 4\n            c.lineCap = \"round\"\n            c.strokeStyle = color\n            c.stroke()\n        }\n\n        // bottom\n        if(this.walls[2]){\n            c.beginPath()\n            c.moveTo(x + size, y + size)\n            c.lineTo(x, y +size)\n            c.lineWidth = 4\n            c.lineCap = \"round\"\n            c.strokeStyle = color\n            c.stroke()\n        }\n\n        // left \n        if(this.walls[3]){\n            c.beginPath()\n            c.moveTo(x, y + size)\n            c.lineTo(x, y)\n            c.lineWidth = 4\n            c.lineCap = \"round\"\n            c.strokeStyle = color\n            c.stroke()\n        }\n    }\n}\n\nconst setup_block_and_node = ctx => {\n    c = ctx\n}\n\nexport {Block , Node , setup_block_and_node}"]},"metadata":{},"sourceType":"module"}