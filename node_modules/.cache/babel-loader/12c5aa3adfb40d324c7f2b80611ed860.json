{"ast":null,"code":"let path = [];\n\nfunction merge_sort(array) {\n  if (array.length === 1) return array;\n  const midd = Math.floor(array.length / 2);\n  const left_arr = array.slice(0, midd);\n  const right_arr = array.slice(midd, array.length);\n  return merge(merge_sort(left_arr), merge_sort(right_arr));\n}\n\nconst merge = (left_array, right_array) => {\n  let sort_array = [];\n  let index = 0;\n\n  while (left_array.length && right_array.length) {\n    // let {min_index, min_left_node , min_right_node} = find_min_node(left_array , right_array)\n    if (left_array[0].height < right_array[0].height) {\n      let left_node = left_array[0]; // let {min_index, min_left_node , min_right_node} = find_min_node(left_array)\n      //   if(left_node.index !== min_index){\n      //     if(min_left_node){\n      //       min_left_node.index = left_node.index\n      //     }else{\n      //       min_right_node.index = left_node.index\n      //     }\n      //     left_node.index = min_index\n      //   }\n\n      left_node.index = index;\n      path.push(left_node);\n      sort_array.push(left_array.shift());\n    } else {\n      let right_node = right_array[0]; //   let {min_index, min_left_node , min_right_node} = find_min_node(right_array)\n      //   if(right_node.index !== min_index){\n      //     if(min_left_node){\n      //       min_left_node.index = right_node.index\n      //     }else{\n      //       min_right_node.index = right_node.index\n      //     }\n      //     right_node.index = min_index\n      //   }\n\n      right_node.index = index;\n      path.push(right_node);\n      sort_array.push(right_array.shift());\n    }\n\n    index++;\n  }\n\n  while (left_array.length) {\n    let left_n = left_array[0]; // let {min_index, min_left_node , min_right_node} = find_min_node(left_array,right_array)\n    // if(left_n.index !== min_index){\n    //   if(min_left_node){\n    //     min_left_node.index = left_n.index\n    //   }else{\n    //     min_right_node.index = left_n.index\n    //   }\n    //   left_n.index = min_index\n    // }\n\n    left_n.index = index;\n    path.push(left_n);\n    sort_array.push(left_array.shift());\n    index++;\n  }\n\n  while (right_array.length) {\n    let right_n = right_array[0]; // let {min_index, min_right_node , min_left_node } = find_min_node(left_array,right_array)\n    // if(right_n.index !== min_index){\n    //   if(min_left_node){\n    //     min_left_node.index = right_n.index\n    //   }else{\n    //     min_right_node.index = right_n.index\n    //   }\n    //   right_n.index = min_index\n    // }\n\n    right_n.index = index;\n    path.push(right_n);\n    sort_array.push(right_array.shift());\n    index++;\n  }\n\n  return sort_array;\n};\n\nconst find_min_node = (left_array = [], right_array = []) => {\n  let com_arr = [...left_array, ...right_array];\n  let min_index = Math.min(...com_arr.map(element => element.index));\n  let min_left_node = left_array.find(element => element.index === min_index);\n  let min_right_node = right_array.find(element => element.index === min_index);\n  return {\n    min_index,\n    min_left_node,\n    min_right_node\n  };\n};\n\nconst solve_array = array => {\n  let answer = merge_sort(array);\n  if (answer) return path;\n};\n\nexport default solve_array;","map":{"version":3,"sources":["/Users/vienpham/Desktop/Algorithms_simulation/algorithms/src/Algorithms/mergeSort.js"],"names":["path","merge_sort","array","length","midd","Math","floor","left_arr","slice","right_arr","merge","left_array","right_array","sort_array","index","height","left_node","push","shift","right_node","left_n","right_n","find_min_node","com_arr","min_index","min","map","element","min_left_node","find","min_right_node","solve_array","answer"],"mappings":"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","sourcesContent":["let path = []\n\nfunction merge_sort(array){\n  if(array.length === 1) return array \n\n  const midd = Math.floor(array.length / 2)\n  const left_arr = array.slice(0,midd)\n  const right_arr = array.slice(midd, array.length)\n\n  return merge(merge_sort(left_arr), merge_sort(right_arr))\n}\n\nconst merge = (left_array, right_array) => {\n  let sort_array = []\n  let index = 0\n\n  while(left_array.length && right_array.length){\n    // let {min_index, min_left_node , min_right_node} = find_min_node(left_array , right_array)\n    if(left_array[0].height < right_array[0].height){\n        let left_node = left_array[0]\n        // let {min_index, min_left_node , min_right_node} = find_min_node(left_array)\n    //   if(left_node.index !== min_index){\n    //     if(min_left_node){\n    //       min_left_node.index = left_node.index\n    //     }else{\n    //       min_right_node.index = left_node.index\n    //     }\n    //     left_node.index = min_index\n    //   }\n    left_node.index = index \n      path.push(left_node)\n      sort_array.push(left_array.shift())\n    }else{\n      let right_node = right_array[0]\n    //   let {min_index, min_left_node , min_right_node} = find_min_node(right_array)\n    //   if(right_node.index !== min_index){\n    //     if(min_left_node){\n    //       min_left_node.index = right_node.index\n    //     }else{\n    //       min_right_node.index = right_node.index\n    //     }\n    //     right_node.index = min_index\n    //   }\n    right_node.index = index \n      path.push(right_node)\n      sort_array.push(right_array.shift())\n    }\n    index ++\n  }\n\n  while(left_array.length) {\n    let left_n = left_array[0]\n    // let {min_index, min_left_node , min_right_node} = find_min_node(left_array,right_array)\n    // if(left_n.index !== min_index){\n    //   if(min_left_node){\n    //     min_left_node.index = left_n.index\n    //   }else{\n    //     min_right_node.index = left_n.index\n    //   }\n    //   left_n.index = min_index\n    // }\n    left_n.index = index \n    path.push(left_n)\n    sort_array.push(left_array.shift())\n    index++ \n  }\n  while(right_array.length) {\n    let right_n = right_array[0]\n    // let {min_index, min_right_node , min_left_node } = find_min_node(left_array,right_array)\n    // if(right_n.index !== min_index){\n    //   if(min_left_node){\n    //     min_left_node.index = right_n.index\n    //   }else{\n    //     min_right_node.index = right_n.index\n    //   }\n    //   right_n.index = min_index\n    // }\n    right_n.index = index\n    path.push(right_n)\n    sort_array.push(right_array.shift())\n    index ++\n  }\n  return sort_array\n}\n\nconst find_min_node = (left_array = [],right_array = []) => {\n  let com_arr = [...left_array,...right_array]\n  let min_index =  Math.min(...com_arr.map(element => element.index))\n\n  let min_left_node = left_array.find(element => element.index === min_index)\n\n  let min_right_node = right_array.find(element => element.index === min_index)\n\n  return {min_index, min_left_node , min_right_node}\n}\n\nconst solve_array = array => {\n  let answer = merge_sort(array)\n  if(answer) return path\n}\n\nexport default solve_array"]},"metadata":{},"sourceType":"module"}