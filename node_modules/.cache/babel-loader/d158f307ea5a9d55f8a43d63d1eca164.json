{"ast":null,"code":"import { Block } from '../helper_method';\nlet start_node, end_node, nodes, c, canvas, size;\nlet open_list_1, close_list_1, current_node_1, open_list_2, close_list_2, current_node_2, myReq, finish_path, finish_search;\n\nconst bidirectional_dijkstra = props => {\n  start_node = props.start_node;\n  start_node.distance = 0;\n  end_node = props.end_node;\n  nodes = props.nodes;\n  c = props.c;\n  canvas = props.canvas;\n  size = props.size; // end_node.prev_node = null\n\n  open_list_1 = [start_node];\n  close_list_1 = [];\n  open_list_2 = [end_node];\n  close_list_2 = [];\n  current_node_1 = start_node;\n  current_node_2 = end_node;\n  finish_path = false;\n  finish_search = false;\n  cancelAnimationFrame(myReq);\n  run_solve_maze();\n};\n\nconst stop_bidirectional_dijkstra = () => {\n  cancelAnimationFrame(myReq);\n};\n\nconst run_solve_maze = () => {\n  myReq = requestAnimationFrame(run_solve_maze);\n  c.clearRect(0, 0, canvas.width, canvas.height);\n\n  for (let i = 0; i < nodes.length; i++) {\n    nodes[i].draw();\n  }\n\n  for (let i = 0; i < close_list_1.length; i++) {\n    if (!finish_search) {\n      close_list_1[i].color = 'MidnightBlue';\n    }\n\n    close_list_1[i].draw();\n  }\n\n  for (let i = 0; i < open_list_1.length; i++) {\n    open_list_1[i].color = 'DeepSkyBlue';\n    open_list_1[i].draw();\n  }\n\n  for (let i = 0; i < close_list_2.length; i++) {\n    if (!finish_search) {\n      close_list_2[i].color = 'MidnightBlue';\n    }\n\n    close_list_2[i].draw();\n  }\n\n  for (let i = 0; i < open_list_2.length; i++) {\n    open_list_2[i].color = 'DeepSkyBlue';\n    open_list_2[i].draw();\n  }\n\n  if (current_node_1.x === current_node_2.x && current_node_1.y === current_node_2.y) {\n    finish_search = true;\n    finish_path = true;\n  }\n\n  if (open_list_1.length > 0 && !finish_path) {\n    current_node_1 = open_list_1.sort((a, b) => a.distance - b.distance)[0];\n    close_list_1.push(current_node_1);\n    find_child_node();\n  } // if(end_node.prev_node){\n  //     start_node.draw()\n  //     end_node.draw()\n  //     find_path() \n  // }\n\n\n  if (finish_path) {\n    cancelAnimationFrame(myReq);\n  }\n};\n\nconst find_child_node = () => {\n  let {\n    top,\n    right,\n    bottom,\n    left\n  } = get_top_right_bottom_left(current_node_1, nodes); // Right (x + size , y)\n\n  if (right && !right.walls[3] && !close_list_1.find(node => node.x === right.x && node.y === right.y)) {\n    let right_in_open = open_list_1.find(n => n.x === right.x && n.y === right.y);\n    right_in_open ? update_node(right_in_open) : open_list_1.push(create_new_node(right));\n  } // top (x , y - size)\n\n\n  if (top && !top.walls[2] && !close_list_1.find(node => node.x === top.x && node.y === top.y)) {\n    let top_in_open = open_list_1.find(n => n.x === top.x && n.y === top.y);\n    top_in_open ? update_node(top_in_open) : open_list_1.push(create_new_node(top));\n  } // left (x - size , y )\n\n\n  if (left && !left.walls[1] && !close_list_1.find(node => node.x === left.x && node.y === left.y)) {\n    let left_in_open = open_list_1.find(n => n.x === left.x && n.y === left.y);\n    left_in_open ? update_node(left_in_open) : open_list_1.push(create_new_node(left));\n  } // bottom (x , y + size)\n\n\n  if (bottom && !bottom.walls[0] && !close_list_1.find(node => node.x === bottom.x && node.y === bottom.y)) {\n    let bottom_in_open = open_list_1.find(n => n.x === bottom.x && n.y === bottom.y);\n    bottom_in_open ? update_node(bottom_in_open) : open_list_1.push(create_new_node(bottom));\n  }\n\n  open_list_1 = open_list_1.filter(node => node.x === current_node_1.x && node.y === current_node_1.y ? false : true);\n};\n\nconst find_path = () => {\n  current_node_1.color = \"LimeGreen\";\n\n  if (current_node_1.x === start_node.x && current_node_1.y === start_node.y) {\n    finish_path = true;\n    return;\n  }\n\n  current_node_1 = current_node_1.prev_node;\n  return;\n};\n\nconst create_new_node = node => {\n  let distance = find_distance(node);\n  return new Block(node.x, node.y, c, size, 'MidnightBlue', current_node_1, null, null, null, distance);\n};\n\nconst find_distance = node => {\n  // find distance from current node to next node \n  let x_1 = current_node_1.x;\n  let y_1 = current_node_1.y;\n  let x_2 = node.x;\n  let y_2 = node.y;\n  return (Math.abs(x_1 - x_2) + Math.abs(y_1 - y_2)) * size + current_node_1.distance;\n};\n\nconst update_node = node => {\n  if (current_node_1.distance + size < node.distance) {\n    node.distance = find_distance(node);\n  }\n};\n\nconst get_top_right_bottom_left = (node, array) => {\n  let {\n    x,\n    y\n  } = node;\n  let top = array.find(n => n.x === x && n.y === y - size);\n  let right = array.find(n => n.x === x + size && n.y === y);\n  let bottom = array.find(n => n.x === x && n.y === y + size);\n  let left = array.find(n => n.x === x - size && n.y === y);\n  return {\n    top,\n    right,\n    bottom,\n    left\n  };\n};\n\nexport { bidirectional_dijkstra, stop_bidirectional_dijkstra };","map":{"version":3,"sources":["/Users/vienpham/Desktop/Algorithms_simulation/algorithms/src/Algorithms/solve_maze/bidirectional_dijkstra.js"],"names":["Block","start_node","end_node","nodes","c","canvas","size","open_list_1","close_list_1","current_node_1","open_list_2","close_list_2","current_node_2","myReq","finish_path","finish_search","bidirectional_dijkstra","props","distance","cancelAnimationFrame","run_solve_maze","stop_bidirectional_dijkstra","requestAnimationFrame","clearRect","width","height","i","length","draw","color","x","y","sort","a","b","push","find_child_node","top","right","bottom","left","get_top_right_bottom_left","walls","find","node","right_in_open","n","update_node","create_new_node","top_in_open","left_in_open","bottom_in_open","filter","find_path","prev_node","find_distance","x_1","y_1","x_2","y_2","Math","abs","array"],"mappings":"AAAA,SAASA,KAAT,QAAsB,kBAAtB;AAEA,IAAIC,UAAJ,EAAiBC,QAAjB,EAA4BC,KAA5B,EAAoCC,CAApC,EAAwCC,MAAxC,EAAiDC,IAAjD;AAEA,IAAIC,WAAJ,EAAkBC,YAAlB,EAAiCC,cAAjC,EAAkDC,WAAlD,EAAgEC,YAAhE,EAA+EC,cAA/E,EAAgGC,KAAhG,EAAwGC,WAAxG,EAAsHC,aAAtH;;AAEA,MAAMC,sBAAsB,GAAGC,KAAK,IAAI;AACpChB,EAAAA,UAAU,GAAGgB,KAAK,CAAChB,UAAnB;AACAA,EAAAA,UAAU,CAACiB,QAAX,GAAsB,CAAtB;AACAhB,EAAAA,QAAQ,GAAGe,KAAK,CAACf,QAAjB;AACAC,EAAAA,KAAK,GAAGc,KAAK,CAACd,KAAd;AACAC,EAAAA,CAAC,GAAGa,KAAK,CAACb,CAAV;AACAC,EAAAA,MAAM,GAAGY,KAAK,CAACZ,MAAf;AACAC,EAAAA,IAAI,GAAGW,KAAK,CAACX,IAAb,CAPoC,CASpC;;AAEAC,EAAAA,WAAW,GAAG,CAACN,UAAD,CAAd;AACAO,EAAAA,YAAY,GAAG,EAAf;AAEAE,EAAAA,WAAW,GAAG,CAACR,QAAD,CAAd;AACAS,EAAAA,YAAY,GAAG,EAAf;AAEAF,EAAAA,cAAc,GAAGR,UAAjB;AACAW,EAAAA,cAAc,GAAGV,QAAjB;AACAY,EAAAA,WAAW,GAAG,KAAd;AACAC,EAAAA,aAAa,GAAG,KAAhB;AAEAI,EAAAA,oBAAoB,CAACN,KAAD,CAApB;AACAO,EAAAA,cAAc;AACjB,CAxBD;;AA0BA,MAAMC,2BAA2B,GAAG,MAAM;AACtCF,EAAAA,oBAAoB,CAACN,KAAD,CAApB;AACH,CAFD;;AAIA,MAAMO,cAAc,GAAG,MAAM;AACzBP,EAAAA,KAAK,GAAGS,qBAAqB,CAACF,cAAD,CAA7B;AACAhB,EAAAA,CAAC,CAACmB,SAAF,CAAY,CAAZ,EAAc,CAAd,EAAgBlB,MAAM,CAACmB,KAAvB,EAA8BnB,MAAM,CAACoB,MAArC;;AAEA,OAAI,IAAIC,CAAC,GAAG,CAAZ,EAAgBA,CAAC,GAAGvB,KAAK,CAACwB,MAA1B,EAAmCD,CAAC,EAApC,EAAwC;AACpCvB,IAAAA,KAAK,CAACuB,CAAD,CAAL,CAASE,IAAT;AACH;;AAED,OAAI,IAAIF,CAAC,GAAG,CAAZ,EAAgBA,CAAC,GAAGlB,YAAY,CAACmB,MAAjC,EAA0CD,CAAC,EAA3C,EAA+C;AAC3C,QAAG,CAACX,aAAJ,EAAkB;AACdP,MAAAA,YAAY,CAACkB,CAAD,CAAZ,CAAgBG,KAAhB,GAAwB,cAAxB;AACH;;AACDrB,IAAAA,YAAY,CAACkB,CAAD,CAAZ,CAAgBE,IAAhB;AACH;;AAED,OAAI,IAAIF,CAAC,GAAG,CAAZ,EAAgBA,CAAC,GAAGnB,WAAW,CAACoB,MAAhC,EAAyCD,CAAC,EAA1C,EAA8C;AAC1CnB,IAAAA,WAAW,CAACmB,CAAD,CAAX,CAAeG,KAAf,GAAuB,aAAvB;AACAtB,IAAAA,WAAW,CAACmB,CAAD,CAAX,CAAeE,IAAf;AACH;;AAED,OAAI,IAAIF,CAAC,GAAG,CAAZ,EAAgBA,CAAC,GAAGf,YAAY,CAACgB,MAAjC,EAA0CD,CAAC,EAA3C,EAA+C;AAC3C,QAAG,CAACX,aAAJ,EAAkB;AACdJ,MAAAA,YAAY,CAACe,CAAD,CAAZ,CAAgBG,KAAhB,GAAwB,cAAxB;AACH;;AACDlB,IAAAA,YAAY,CAACe,CAAD,CAAZ,CAAgBE,IAAhB;AACH;;AAED,OAAI,IAAIF,CAAC,GAAG,CAAZ,EAAgBA,CAAC,GAAGhB,WAAW,CAACiB,MAAhC,EAAyCD,CAAC,EAA1C,EAA8C;AAC1ChB,IAAAA,WAAW,CAACgB,CAAD,CAAX,CAAeG,KAAf,GAAuB,aAAvB;AACAnB,IAAAA,WAAW,CAACgB,CAAD,CAAX,CAAeE,IAAf;AACH;;AAED,MAAGnB,cAAc,CAACqB,CAAf,KAAqBlB,cAAc,CAACkB,CAApC,IAAyCrB,cAAc,CAACsB,CAAf,KAAqBnB,cAAc,CAACmB,CAAhF,EAAkF;AAC9EhB,IAAAA,aAAa,GAAG,IAAhB;AACAD,IAAAA,WAAW,GAAG,IAAd;AACH;;AAED,MAAGP,WAAW,CAACoB,MAAZ,GAAqB,CAArB,IAA0B,CAACb,WAA9B,EAA0C;AACtCL,IAAAA,cAAc,GAAGF,WAAW,CAACyB,IAAZ,CAAiB,CAACC,CAAD,EAAGC,CAAH,KAASD,CAAC,CAACf,QAAF,GAAagB,CAAC,CAAChB,QAAzC,EAAmD,CAAnD,CAAjB;AACAV,IAAAA,YAAY,CAAC2B,IAAb,CAAkB1B,cAAlB;AACA2B,IAAAA,eAAe;AAClB,GAzCwB,CA2CzB;AACA;AACA;AACA;AACA;;;AACA,MAAGtB,WAAH,EAAe;AACXK,IAAAA,oBAAoB,CAACN,KAAD,CAApB;AACH;AACJ,CAnDD;;AAqDA,MAAMuB,eAAe,GAAG,MAAM;AAE1B,MAAI;AAACC,IAAAA,GAAD;AAAOC,IAAAA,KAAP;AAAeC,IAAAA,MAAf;AAAwBC,IAAAA;AAAxB,MAAgCC,yBAAyB,CAAChC,cAAD,EAAkBN,KAAlB,CAA7D,CAF0B,CAI1B;;AACA,MAAGmC,KAAK,IAAI,CAACA,KAAK,CAACI,KAAN,CAAY,CAAZ,CAAV,IAA4B,CAAClC,YAAY,CAACmC,IAAb,CAAkBC,IAAI,IAAIA,IAAI,CAACd,CAAL,KAAWQ,KAAK,CAACR,CAAjB,IAAuBc,IAAI,CAACb,CAAL,KAAWO,KAAK,CAACP,CAAlE,CAAhC,EAAqG;AACjG,QAAIc,aAAa,GAAGtC,WAAW,CAACoC,IAAZ,CAAiBG,CAAC,IAAIA,CAAC,CAAChB,CAAF,KAAQQ,KAAK,CAACR,CAAd,IAAoBgB,CAAC,CAACf,CAAF,KAAQO,KAAK,CAACP,CAAxD,CAApB;AAEAc,IAAAA,aAAa,GAAGE,WAAW,CAACF,aAAD,CAAd,GAAgCtC,WAAW,CAAC4B,IAAZ,CAAiBa,eAAe,CAACV,KAAD,CAAhC,CAA7C;AACH,GATyB,CAW1B;;;AACA,MAAGD,GAAG,IAAI,CAACA,GAAG,CAACK,KAAJ,CAAU,CAAV,CAAR,IAAwB,CAAClC,YAAY,CAACmC,IAAb,CAAkBC,IAAI,IAAIA,IAAI,CAACd,CAAL,KAAWO,GAAG,CAACP,CAAf,IAAoBc,IAAI,CAACb,CAAL,KAAWM,GAAG,CAACN,CAA7D,CAA5B,EAA4F;AACxF,QAAIkB,WAAW,GAAG1C,WAAW,CAACoC,IAAZ,CAAiBG,CAAC,IAAIA,CAAC,CAAChB,CAAF,KAAQO,GAAG,CAACP,CAAZ,IAAkBgB,CAAC,CAACf,CAAF,KAAQM,GAAG,CAACN,CAApD,CAAlB;AAEAkB,IAAAA,WAAW,GAAGF,WAAW,CAACE,WAAD,CAAd,GAA8B1C,WAAW,CAAC4B,IAAZ,CAAiBa,eAAe,CAACX,GAAD,CAAhC,CAAzC;AACH,GAhByB,CAkB1B;;;AACA,MAAGG,IAAI,IAAI,CAACA,IAAI,CAACE,KAAL,CAAW,CAAX,CAAT,IAA0B,CAAClC,YAAY,CAACmC,IAAb,CAAkBC,IAAI,IAAIA,IAAI,CAACd,CAAL,KAAWU,IAAI,CAACV,CAAhB,IAAqBc,IAAI,CAACb,CAAL,KAAWS,IAAI,CAACT,CAA/D,CAA9B,EAAgG;AAC5F,QAAImB,YAAY,GAAG3C,WAAW,CAACoC,IAAZ,CAAiBG,CAAC,IAAIA,CAAC,CAAChB,CAAF,KAAQU,IAAI,CAACV,CAAb,IAAmBgB,CAAC,CAACf,CAAF,KAAQS,IAAI,CAACT,CAAtD,CAAnB;AAEAmB,IAAAA,YAAY,GAAGH,WAAW,CAACG,YAAD,CAAd,GAA+B3C,WAAW,CAAC4B,IAAZ,CAAiBa,eAAe,CAACR,IAAD,CAAhC,CAA3C;AACH,GAvByB,CAyB1B;;;AACA,MAAGD,MAAM,IAAI,CAACA,MAAM,CAACG,KAAP,CAAa,CAAb,CAAX,IAA6B,CAAClC,YAAY,CAACmC,IAAb,CAAkBC,IAAI,IAAIA,IAAI,CAACd,CAAL,KAAWS,MAAM,CAACT,CAAlB,IAAuBc,IAAI,CAACb,CAAL,KAAWQ,MAAM,CAACR,CAAnE,CAAjC,EAAuG;AACnG,QAAIoB,cAAc,GAAG5C,WAAW,CAACoC,IAAZ,CAAiBG,CAAC,IAAIA,CAAC,CAAChB,CAAF,KAAQS,MAAM,CAACT,CAAf,IAAqBgB,CAAC,CAACf,CAAF,KAAQQ,MAAM,CAACR,CAA1D,CAArB;AAEAoB,IAAAA,cAAc,GAAGJ,WAAW,CAACI,cAAD,CAAd,GAAiC5C,WAAW,CAAC4B,IAAZ,CAAiBa,eAAe,CAACT,MAAD,CAAhC,CAA/C;AACH;;AAEDhC,EAAAA,WAAW,GAAGA,WAAW,CAAC6C,MAAZ,CAAmBR,IAAI,IAAIA,IAAI,CAACd,CAAL,KAAWrB,cAAc,CAACqB,CAA1B,IAA+Bc,IAAI,CAACb,CAAL,KAAWtB,cAAc,CAACsB,CAAzD,GAA6D,KAA7D,GAAqE,IAAhG,CAAd;AACH,CAjCD;;AAmCA,MAAMsB,SAAS,GAAG,MAAM;AACpB5C,EAAAA,cAAc,CAACoB,KAAf,GAAuB,WAAvB;;AACA,MAAGpB,cAAc,CAACqB,CAAf,KAAqB7B,UAAU,CAAC6B,CAAhC,IAAqCrB,cAAc,CAACsB,CAAf,KAAqB9B,UAAU,CAAC8B,CAAxE,EAA0E;AACtEjB,IAAAA,WAAW,GAAG,IAAd;AACA;AACH;;AACDL,EAAAA,cAAc,GAAGA,cAAc,CAAC6C,SAAhC;AACA;AACH,CARD;;AAUA,MAAMN,eAAe,GAAIJ,IAAD,IAAU;AAC9B,MAAI1B,QAAQ,GAAGqC,aAAa,CAACX,IAAD,CAA5B;AACA,SAAO,IAAI5C,KAAJ,CAAU4C,IAAI,CAACd,CAAf,EAAmBc,IAAI,CAACb,CAAxB,EAA4B3B,CAA5B,EAAgCE,IAAhC,EAAuC,cAAvC,EAAwDG,cAAxD,EAAyE,IAAzE,EAAgF,IAAhF,EAAuF,IAAvF,EAA8FS,QAA9F,CAAP;AACH,CAHD;;AAKA,MAAMqC,aAAa,GAAIX,IAAD,IAAU;AAC5B;AACA,MAAIY,GAAG,GAAG/C,cAAc,CAACqB,CAAzB;AACA,MAAI2B,GAAG,GAAGhD,cAAc,CAACsB,CAAzB;AAEA,MAAI2B,GAAG,GAAGd,IAAI,CAACd,CAAf;AACA,MAAI6B,GAAG,GAAGf,IAAI,CAACb,CAAf;AAED,SAAQ,CAAC6B,IAAI,CAACC,GAAL,CAASL,GAAG,GAAGE,GAAf,IAAsBE,IAAI,CAACC,GAAL,CAASJ,GAAG,GAAGE,GAAf,CAAvB,IAA8CrD,IAA/C,GAAwDG,cAAc,CAACS,QAA9E;AACF,CATD;;AAWA,MAAM6B,WAAW,GAAGH,IAAI,IAAI;AACxB,MAAGnC,cAAc,CAACS,QAAf,GAA0BZ,IAA1B,GAAiCsC,IAAI,CAAC1B,QAAzC,EAAkD;AAC9C0B,IAAAA,IAAI,CAAC1B,QAAL,GAAgBqC,aAAa,CAACX,IAAD,CAA7B;AACH;AACJ,CAJD;;AAMA,MAAMH,yBAAyB,GAAG,CAACG,IAAD,EAAQkB,KAAR,KAAmB;AACjD,MAAI;AAAChC,IAAAA,CAAD;AAAKC,IAAAA;AAAL,MAAUa,IAAd;AACA,MAAIP,GAAG,GAAGyB,KAAK,CAACnB,IAAN,CAAWG,CAAC,IAAIA,CAAC,CAAChB,CAAF,KAAQA,CAAR,IAAagB,CAAC,CAACf,CAAF,KAAQA,CAAC,GAAGzB,IAAzC,CAAV;AACA,MAAIgC,KAAK,GAAGwB,KAAK,CAACnB,IAAN,CAAWG,CAAC,IAAIA,CAAC,CAAChB,CAAF,KAAQA,CAAC,GAAGxB,IAAZ,IAAoBwC,CAAC,CAACf,CAAF,KAAQA,CAA5C,CAAZ;AACA,MAAIQ,MAAM,GAAGuB,KAAK,CAACnB,IAAN,CAAWG,CAAC,IAAIA,CAAC,CAAChB,CAAF,KAAQA,CAAR,IAAagB,CAAC,CAACf,CAAF,KAAQA,CAAC,GAAGzB,IAAzC,CAAb;AACA,MAAIkC,IAAI,GAAGsB,KAAK,CAACnB,IAAN,CAAWG,CAAC,IAAIA,CAAC,CAAChB,CAAF,KAAQA,CAAC,GAAGxB,IAAZ,IAAoBwC,CAAC,CAACf,CAAF,KAAQA,CAA5C,CAAX;AAEA,SAAO;AAACM,IAAAA,GAAD;AAAOC,IAAAA,KAAP;AAAeC,IAAAA,MAAf;AAAwBC,IAAAA;AAAxB,GAAP;AACH,CARD;;AAUA,SAAQxB,sBAAR,EAAiCK,2BAAjC","sourcesContent":["import { Block } from '../helper_method'\n\nlet start_node , end_node , nodes , c , canvas , size \n\nlet open_list_1 , close_list_1 , current_node_1 , open_list_2 , close_list_2 , current_node_2 , myReq , finish_path , finish_search \n\nconst bidirectional_dijkstra = props => {\n    start_node = props.start_node\n    start_node.distance = 0\n    end_node = props.end_node \n    nodes = props.nodes\n    c = props.c \n    canvas = props.canvas \n    size = props.size \n\n    // end_node.prev_node = null\n    \n    open_list_1 = [start_node]\n    close_list_1 = []\n\n    open_list_2 = [end_node]\n    close_list_2 = []\n\n    current_node_1 = start_node\n    current_node_2 = end_node \n    finish_path = false \n    finish_search = false \n\n    cancelAnimationFrame(myReq)\n    run_solve_maze()\n}\n\nconst stop_bidirectional_dijkstra = () => {\n    cancelAnimationFrame(myReq)\n}\n\nconst run_solve_maze = () => {\n    myReq = requestAnimationFrame(run_solve_maze)\n    c.clearRect(0,0,canvas.width, canvas.height)\n\n    for(let i = 0 ; i < nodes.length ; i ++){\n        nodes[i].draw()\n    }\n\n    for(let i = 0 ; i < close_list_1.length ; i ++){\n        if(!finish_search){\n            close_list_1[i].color = 'MidnightBlue'\n        }\n        close_list_1[i].draw()\n    }\n\n    for(let i = 0 ; i < open_list_1.length ; i ++){\n        open_list_1[i].color = 'DeepSkyBlue'\n        open_list_1[i].draw()\n    }\n\n    for(let i = 0 ; i < close_list_2.length ; i ++){\n        if(!finish_search){\n            close_list_2[i].color = 'MidnightBlue'\n        }\n        close_list_2[i].draw()\n    }\n\n    for(let i = 0 ; i < open_list_2.length ; i ++){\n        open_list_2[i].color = 'DeepSkyBlue'\n        open_list_2[i].draw()\n    }\n\n    if(current_node_1.x === current_node_2.x && current_node_1.y === current_node_2.y){\n        finish_search = true \n        finish_path = true \n    }\n\n    if(open_list_1.length > 0 && !finish_path){\n        current_node_1 = open_list_1.sort((a,b) => a.distance - b.distance)[0] \n        close_list_1.push(current_node_1)\n        find_child_node()\n    }\n\n    // if(end_node.prev_node){\n    //     start_node.draw()\n    //     end_node.draw()\n    //     find_path() \n    // }\n    if(finish_path){\n        cancelAnimationFrame(myReq)\n    }\n}\n\nconst find_child_node = () => {\n\n    let {top , right , bottom , left} = get_top_right_bottom_left(current_node_1 , nodes )\n\n    // Right (x + size , y)\n    if(right && !right.walls[3] && !close_list_1.find(node => node.x === right.x  && node.y === right.y)){\n        let right_in_open = open_list_1.find(n => n.x === right.x  && n.y === right.y)\n\n        right_in_open ? update_node(right_in_open) : open_list_1.push(create_new_node(right))\n    }\n\n    // top (x , y - size)\n    if(top && !top.walls[2] && !close_list_1.find(node => node.x === top.x && node.y === top.y)){\n        let top_in_open = open_list_1.find(n => n.x === top.x  && n.y === top.y)\n\n        top_in_open ? update_node(top_in_open) : open_list_1.push(create_new_node(top))\n    }\n\n    // left (x - size , y )\n    if(left && !left.walls[1] && !close_list_1.find(node => node.x === left.x && node.y === left.y)){\n        let left_in_open = open_list_1.find(n => n.x === left.x  && n.y === left.y)\n        \n        left_in_open ? update_node(left_in_open) : open_list_1.push(create_new_node(left))\n    }\n\n    // bottom (x , y + size)\n    if(bottom && !bottom.walls[0] &&!close_list_1.find(node => node.x === bottom.x && node.y === bottom.y)){\n        let bottom_in_open = open_list_1.find(n => n.x === bottom.x  && n.y === bottom.y)\n        \n        bottom_in_open ? update_node(bottom_in_open) : open_list_1.push(create_new_node(bottom))\n    }\n\n    open_list_1 = open_list_1.filter(node => node.x === current_node_1.x && node.y === current_node_1.y ? false : true )\n}\n\nconst find_path = () => {\n    current_node_1.color = \"LimeGreen\"\n    if(current_node_1.x === start_node.x && current_node_1.y === start_node.y){\n        finish_path = true\n        return\n    }\n    current_node_1 = current_node_1.prev_node\n    return \n}\n\nconst create_new_node = (node) => {\n    let distance = find_distance(node)\n    return new Block(node.x , node.y , c , size , 'MidnightBlue' , current_node_1 , null , null , null , distance)\n}\n\nconst find_distance = (node) => {\n    // find distance from current node to next node \n    let x_1 = current_node_1.x \n    let y_1 = current_node_1.y \n\n    let x_2 = node.x \n    let y_2 = node.y\n\n   return ((Math.abs(x_1 - x_2) + Math.abs(y_1 - y_2)) * size ) + current_node_1.distance\n}\n\nconst update_node = node => {\n    if(current_node_1.distance + size < node.distance){\n        node.distance = find_distance(node)\n    }\n}\n\nconst get_top_right_bottom_left = (node , array ) => {\n    let {x , y} = node\n    let top = array.find(n => n.x === x && n.y === y - size)\n    let right = array.find(n => n.x === x + size && n.y === y)\n    let bottom = array.find(n => n.x === x && n.y === y + size)\n    let left = array.find(n => n.x === x - size && n.y === y)\n\n    return {top , right , bottom , left }\n}\n\nexport {bidirectional_dijkstra , stop_bidirectional_dijkstra}"]},"metadata":{},"sourceType":"module"}