{"ast":null,"code":"import { Node, Block } from './helper_method';\nlet size, width, height, cols, rows;\nlet delay;\nlet speed;\nlet canvas, c;\nlet nodes, block;\nlet visited_nodes, stack;\nlet quere, finish_path, nodes_path, path, current_node;\nlet start_node, end_node;\nlet myReq, myReqDraw;\nlet stop = false;\n\nconst setUp = props => {\n  c = props.c;\n  canvas = props.canvas;\n  nodes = [];\n  visited_nodes = [];\n  stack = [];\n  quere = [];\n  nodes_path = [];\n  path = [];\n  finish_path = false;\n  cols = props.cols;\n  rows = props.rows;\n  size = props.size;\n  width = size * cols;\n  height = size * rows;\n  delay = 0;\n  speed = 50;\n  canvas.width = width;\n  canvas.height = height;\n  stop = !stop;\n  cancelAnimationFrame(myReq);\n  console.log(stop);\n  draw_divide_maze();\n};\n\nconst draw_divide_maze = () => {\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      let x = j * size + size / 2;\n      let y = i * size + size / 2;\n      let node = new Node(x, y, c, size);\n\n      if (i === 0 && j !== 0) {\n        node.walls[0] = true;\n      } else if (i === rows - 1) {\n        node.walls[2] = true;\n      }\n\n      if (j === 0) {\n        node.walls[3] = true;\n      } else if (j === cols - 1 && i !== rows - 1) {\n        node.walls[1] = true;\n      }\n\n      if (i === 0 && j === 0) {\n        stack.push(node);\n        visited_nodes.push(node);\n      }\n\n      nodes.push(node);\n    }\n  }\n\n  start_node = new Block(size / 2, size / 2, c, size, \"blue\");\n  quere.push(start_node);\n  end_node = new Block((cols - 1) * size + size / 2, (rows - 1) * size + size / 2, c, size, \"green\");\n  draw_maze(nodes, cols, rows, 0, 0);\n};\n\nconst set_maze = (s_delay, nodes_array, x_max, y_max, x_min, y_min) => {\n  let random_x = getRandom(x_min, x_max);\n  let random_y = getRandom(y_min, y_max);\n  let x_or_y = getRandom(-20, 20);\n  return new Promise(resolve => {\n    setTimeout(() => {\n      for (let i = 0; i < nodes_array.length; i++) {\n        if (x_or_y > 0) {\n          // x\n          if (nodes_array[i].x === random_x * size + size / 2 && nodes_array[i].y <= y_max * size + size / 2 && nodes_array[i].y >= y_min * size + size / 2 && nodes_array[i].x !== (cols - 1) * size + size / 2) {\n            if (nodes_array[i].y !== random_y * size + size / 2) {\n              nodes_array[i].walls[1] = true;\n              let {\n                x,\n                y\n              } = nodes_array[i];\n              let neightbor_node = nodes_array.find(node => node.x === x + size && node.y === y);\n\n              if (neightbor_node) {\n                neightbor_node.walls[3] = true;\n              }\n            }\n          }\n        } else {\n          if (nodes_array[i].y === random_y * size + size / 2 && nodes_array[i].x <= x_max * size + size / 2 && nodes_array[i].x >= x_min * size + size / 2) {\n            if (nodes_array[i].x !== random_x * size + size / 2) {\n              nodes_array[i].walls[2] = true;\n              let {\n                x,\n                y\n              } = nodes_array[i];\n              let neightbor_node = nodes_array.find(node => node.x === x && node.y === y + size);\n\n              if (neightbor_node) {\n                neightbor_node.walls[0] = true;\n              }\n            }\n          }\n        }\n\n        nodes_array[i].draw();\n      }\n    }, s_delay * speed);\n  });\n};\n\nconst draw_maze = async function (nodes_array, x_max, y_max, x_min, y_min) {\n  if (x_max - x_min < 1 || y_max - y_min < 1 || stop) return;\n  delay++;\n  let result = await set_maze(delay, nodes_array, x_max, y_max, x_min, y_min);\n\n  if (x_or_y > 0) {\n    // setTimeout(() => {\n    if (result) {\n      draw_maze(nodes_array, random_x, y_max, x_min, y_min); // right \n      // }, delay * (speed + 10));\n      // setTimeout(() => {\n\n      draw_maze(nodes_array, x_max, y_max, random_x + 1, y_min); // left \n    } // }, delay * (speed + 20));\n\n  } else {\n    // setTimeout(() => {\n    if (result) {\n      draw_maze(nodes_array, x_max, random_y, x_min, y_min); // top \n      // }, delay * (speed + 10));\n      // setTimeout(() => {\n\n      draw_maze(nodes_array, x_max, y_max, x_min, random_y + 1); // bottom\n    } // }, delay * (speed + 20));\n\n  }\n\n  return;\n};\n\nconst run_solve_maze = () => {\n  myReq = requestAnimationFrame(run_solve_maze);\n  c.clearRect(0, 0, canvas.width, canvas.height);\n\n  for (let i = 0; i < nodes.length; i++) {\n    nodes[i].draw();\n  }\n\n  for (let i = 0; i < nodes_path.length; i++) {\n    nodes_path[i].draw();\n  }\n\n  start_node.draw();\n  end_node.draw();\n\n  if (end_node.prev_node) {\n    find_path();\n  }\n\n  if (finish_path) {\n    cancelAnimationFrame(myReq);\n  }\n\n  if (!end_node.prev_node && !finish_path) {\n    solve_maze();\n  }\n};\n\nconst solve_maze = () => {\n  let quere_nodes = [...quere];\n  quere.shift(); // visited_nodes_for_path.push(current_node)\n\n  if (end_node.prev_node) {\n    return;\n  }\n\n  for (let i = 0; i < quere_nodes.length; i++) {\n    check_neighbor_node(quere_nodes[i]);\n  }\n};\n\nconst check_neighbor_node = node => {\n  let x = node.x;\n  let y = node.y;\n  let color = \"MidnightBlue\";\n  let current_find_node = nodes.find(c_n => c_n.x === node.x && c_n.y === node.y); // top \n\n  let top = nodes.find(n => n.x === x && n.y === y - size);\n\n  if (top && !current_find_node.walls[0] && !nodes_path.find(n => n.x === top.x && n.y === top.y)) {\n    let top_x = top.x;\n    let top_y = top.y;\n\n    if (top_x === end_node.x && top_y === end_node.y) {\n      end_node.prev_node = node;\n      current_node = node;\n      return;\n    } else {\n      let top_block = new Block(top_x, top_y, c, size, color, node);\n      quere.push(top_block);\n      nodes_path.push(top_block);\n    }\n  } // right\n\n\n  let right = nodes.find(n => n.x === x + size && n.y === y);\n\n  if (right && !current_find_node.walls[1] && !nodes_path.find(n => n.x === right.x && n.y === right.y)) {\n    let right_x = right.x;\n    let right_y = right.y;\n\n    if (right_x === end_node.x && right_y === end_node.y) {\n      end_node.prev_node = node;\n      current_node = node;\n      return;\n    } else {\n      let right_block = new Block(right_x, right_y, c, size, color, node);\n      quere.push(right_block);\n      nodes_path.push(right_block);\n    }\n  } // bottom\n\n\n  let bottom = nodes.find(n => n.x === x && n.y === y + size);\n\n  if (bottom && !current_find_node.walls[2] && !nodes_path.find(n => n.x === bottom.x && n.y === bottom.y)) {\n    let bottom_x = bottom.x;\n    let bottom_y = bottom.y;\n\n    if (bottom_x === end_node.x && bottom_y === end_node.y) {\n      end_node.prev_node = node;\n      current_node = node;\n      return;\n    } else {\n      let bottom_block = new Block(bottom_x, bottom_y, c, size, color, node);\n      quere.push(bottom_block);\n      nodes_path.push(bottom_block);\n    }\n  } // left \n\n\n  let left = nodes.find(n => n.x === x - size && n.y === y);\n\n  if (left && !current_find_node.walls[3] && !nodes_path.find(n => n.x === left.x && n.y === left.y)) {\n    let left_x = left.x;\n    let left_y = left.y;\n\n    if (left_x === end_node.x && left_y === end_node.y) {\n      end_node.prev_node = node;\n      current_node = node;\n      return;\n    } else {\n      let left_block = new Block(left_x, left_y, c, size, color, node);\n      quere.push(left_block);\n      nodes_path.push(left_block);\n    }\n  }\n};\n\nconst find_path = () => {\n  current_node.color = \"green\";\n\n  if (current_node.x === start_node.x && current_node.y === start_node.y) {\n    finish_path = true;\n    return;\n  }\n\n  current_node = current_node.prev_node;\n};\n\nconst getRandom = (min, max) => {\n  return Math.floor(Math.random() * (max - min) + min);\n};\n\nexport { setUp, run_solve_maze };","map":{"version":3,"sources":["/Users/vienpham/Desktop/Algorithms_simulation/algorithms/src/Algorithms/depth_first_search_maze.js"],"names":["Node","Block","size","width","height","cols","rows","delay","speed","canvas","c","nodes","block","visited_nodes","stack","quere","finish_path","nodes_path","path","current_node","start_node","end_node","myReq","myReqDraw","stop","setUp","props","cancelAnimationFrame","console","log","draw_divide_maze","i","j","x","y","node","walls","push","draw_maze","set_maze","s_delay","nodes_array","x_max","y_max","x_min","y_min","random_x","getRandom","random_y","x_or_y","Promise","resolve","setTimeout","length","neightbor_node","find","draw","result","run_solve_maze","requestAnimationFrame","clearRect","prev_node","find_path","solve_maze","quere_nodes","shift","check_neighbor_node","color","current_find_node","c_n","top","n","top_x","top_y","top_block","right","right_x","right_y","right_block","bottom","bottom_x","bottom_y","bottom_block","left","left_x","left_y","left_block","min","max","Math","floor","random"],"mappings":"AAAA,SAAQA,IAAR,EAAeC,KAAf,QAA2B,iBAA3B;AAEA,IAAIC,IAAJ,EAAWC,KAAX,EAAmBC,MAAnB,EAA4BC,IAA5B,EAAmCC,IAAnC;AAEA,IAAIC,KAAJ;AAEA,IAAIC,KAAJ;AAEA,IAAIC,MAAJ,EAAaC,CAAb;AAEA,IAAIC,KAAJ,EAAYC,KAAZ;AAEA,IAAIC,aAAJ,EAAoBC,KAApB;AAEA,IAAIC,KAAJ,EAAYC,WAAZ,EAA0BC,UAA1B,EAAuCC,IAAvC,EAA8CC,YAA9C;AAEA,IAAIC,UAAJ,EAAgBC,QAAhB;AAEA,IAAIC,KAAJ,EAAYC,SAAZ;AAEA,IAAIC,IAAI,GAAG,KAAX;;AAEA,MAAMC,KAAK,GAAIC,KAAD,IAAW;AACvBhB,EAAAA,CAAC,GAAGgB,KAAK,CAAChB,CAAV;AACAD,EAAAA,MAAM,GAAGiB,KAAK,CAACjB,MAAf;AACAE,EAAAA,KAAK,GAAG,EAAR;AACAE,EAAAA,aAAa,GAAG,EAAhB;AACAC,EAAAA,KAAK,GAAG,EAAR;AACAC,EAAAA,KAAK,GAAG,EAAR;AACAE,EAAAA,UAAU,GAAG,EAAb;AACAC,EAAAA,IAAI,GAAG,EAAP;AACAF,EAAAA,WAAW,GAAG,KAAd;AAEAX,EAAAA,IAAI,GAAGqB,KAAK,CAACrB,IAAb;AACAC,EAAAA,IAAI,GAAGoB,KAAK,CAACpB,IAAb;AACAJ,EAAAA,IAAI,GAAGwB,KAAK,CAACxB,IAAb;AACAC,EAAAA,KAAK,GAAGD,IAAI,GAAGG,IAAf;AACAD,EAAAA,MAAM,GAAGF,IAAI,GAAGI,IAAhB;AAEAC,EAAAA,KAAK,GAAG,CAAR;AACAC,EAAAA,KAAK,GAAG,EAAR;AAEAC,EAAAA,MAAM,CAACN,KAAP,GAAeA,KAAf;AACAM,EAAAA,MAAM,CAACL,MAAP,GAAgBA,MAAhB;AAEAoB,EAAAA,IAAI,GAAG,CAACA,IAAR;AACAG,EAAAA,oBAAoB,CAACL,KAAD,CAApB;AACAM,EAAAA,OAAO,CAACC,GAAR,CAAYL,IAAZ;AACAM,EAAAA,gBAAgB;AACjB,CA3BD;;AA6BA,MAAMA,gBAAgB,GAAG,MAAM;AAC7B,OAAI,IAAIC,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGzB,IAAnB,EAA0ByB,CAAC,EAA3B,EAA+B;AAC7B,SAAI,IAAIC,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAG3B,IAAnB,EAA0B2B,CAAC,EAA3B,EAA+B;AAC3B,UAAIC,CAAC,GAAGD,CAAC,GAAG9B,IAAJ,GAAYA,IAAI,GAAG,CAA3B;AACA,UAAIgC,CAAC,GAAGH,CAAC,GAAG7B,IAAJ,GAAYA,IAAI,GAAG,CAA3B;AACA,UAAIiC,IAAI,GAAG,IAAInC,IAAJ,CAASiC,CAAT,EAAYC,CAAZ,EAAgBxB,CAAhB,EAAoBR,IAApB,CAAX;;AACA,UAAG6B,CAAC,KAAK,CAAN,IAAWC,CAAC,KAAK,CAApB,EAAuB;AACnBG,QAAAA,IAAI,CAACC,KAAL,CAAW,CAAX,IAAgB,IAAhB;AACH,OAFD,MAEM,IAAGL,CAAC,KAAKzB,IAAI,GAAG,CAAhB,EAAkB;AACpB6B,QAAAA,IAAI,CAACC,KAAL,CAAW,CAAX,IAAgB,IAAhB;AACH;;AAED,UAAGJ,CAAC,KAAK,CAAT,EAAW;AACPG,QAAAA,IAAI,CAACC,KAAL,CAAW,CAAX,IAAgB,IAAhB;AACH,OAFD,MAEM,IAAGJ,CAAC,KAAK3B,IAAI,GAAG,CAAb,IAAkB0B,CAAC,KAAKzB,IAAI,GAAG,CAAlC,EAAoC;AACtC6B,QAAAA,IAAI,CAACC,KAAL,CAAW,CAAX,IAAgB,IAAhB;AACH;;AAED,UAAGL,CAAC,KAAK,CAAN,IAAWC,CAAC,KAAK,CAApB,EAAsB;AAClBlB,QAAAA,KAAK,CAACuB,IAAN,CAAWF,IAAX;AACAtB,QAAAA,aAAa,CAACwB,IAAd,CAAmBF,IAAnB;AACH;;AACDxB,MAAAA,KAAK,CAAC0B,IAAN,CAAWF,IAAX;AACH;AACF;;AAEDf,EAAAA,UAAU,GAAG,IAAInB,KAAJ,CAAUC,IAAI,GAAG,CAAjB,EAAmBA,IAAI,GAAG,CAA1B,EAA8BQ,CAA9B,EAAkCR,IAAlC,EAAyC,MAAzC,CAAb;AACAa,EAAAA,KAAK,CAACsB,IAAN,CAAWjB,UAAX;AACAC,EAAAA,QAAQ,GAAG,IAAIpB,KAAJ,CAAU,CAACI,IAAI,GAAG,CAAR,IAAaH,IAAb,GAAqBA,IAAI,GAAG,CAAtC,EAAyC,CAAEI,IAAI,GAAG,CAAT,IAAeJ,IAAf,GAAuBA,IAAI,GAAG,CAAvE,EAA4EQ,CAA5E,EAAgFR,IAAhF,EAAuF,OAAvF,CAAX;AACAoC,EAAAA,SAAS,CAAC3B,KAAD,EAASN,IAAT,EAAeC,IAAf,EAAqB,CAArB,EAAwB,CAAxB,CAAT;AACD,CA9BD;;AAgCA,MAAMiC,QAAQ,GAAG,CAACC,OAAD,EAAWC,WAAX,EAAyBC,KAAzB,EAAgCC,KAAhC,EAAuCC,KAAvC,EAA+CC,KAA/C,KAAyD;AACxE,MAAIC,QAAQ,GAAGC,SAAS,CAACH,KAAD,EAAOF,KAAP,CAAxB;AACA,MAAIM,QAAQ,GAAGD,SAAS,CAACF,KAAD,EAAOF,KAAP,CAAxB;AACA,MAAIM,MAAM,GAAGF,SAAS,CAAC,CAAC,EAAF,EAAM,EAAN,CAAtB;AACA,SAAO,IAAIG,OAAJ,CAAYC,OAAO,IAAI;AAC5BC,IAAAA,UAAU,CAAC,MAAM;AACf,WAAI,IAAIrB,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGU,WAAW,CAACY,MAA/B,EAAuCtB,CAAC,EAAxC,EAA4C;AACxC,YAAGkB,MAAM,GAAG,CAAZ,EAAe;AAAE;AACb,cACIR,WAAW,CAACV,CAAD,CAAX,CAAeE,CAAf,KAAqBa,QAAQ,GAAG5C,IAAX,GAAmBA,IAAI,GAAG,CAA/C,IACGuC,WAAW,CAACV,CAAD,CAAX,CAAeG,CAAf,IAAoBS,KAAK,GAAGzC,IAAR,GAAgBA,IAAI,GAAG,CAD9C,IAEGuC,WAAW,CAACV,CAAD,CAAX,CAAeG,CAAf,IAAoBW,KAAK,GAAG3C,IAAR,GAAgBA,IAAI,GAAG,CAF9C,IAGGuC,WAAW,CAACV,CAAD,CAAX,CAAeE,CAAf,KAAqB,CAAC5B,IAAI,GAAG,CAAR,IAAaH,IAAb,GAAqBA,IAAI,GAAG,CAJxD,EAKK;AACD,gBAAIuC,WAAW,CAACV,CAAD,CAAX,CAAeG,CAAf,KAAqBc,QAAQ,GAAG9C,IAAX,GAAmBA,IAAI,GAAG,CAAnD,EAAsD;AAClDuC,cAAAA,WAAW,CAACV,CAAD,CAAX,CAAeK,KAAf,CAAqB,CAArB,IAA0B,IAA1B;AACA,kBAAI;AAACH,gBAAAA,CAAD;AAAKC,gBAAAA;AAAL,kBAAUO,WAAW,CAACV,CAAD,CAAzB;AACA,kBAAIuB,cAAc,GAAGb,WAAW,CAACc,IAAZ,CAAiBpB,IAAI,IAAIA,IAAI,CAACF,CAAL,KAAWA,CAAC,GAAG/B,IAAf,IAAuBiC,IAAI,CAACD,CAAL,KAAWA,CAA3D,CAArB;;AACA,kBAAGoB,cAAH,EAAkB;AACdA,gBAAAA,cAAc,CAAClB,KAAf,CAAqB,CAArB,IAA0B,IAA1B;AACH;AACJ;AACJ;AACJ,SAhBD,MAgBK;AACD,cACIK,WAAW,CAACV,CAAD,CAAX,CAAeG,CAAf,KAAqBc,QAAQ,GAAG9C,IAAX,GAAmBA,IAAI,GAAG,CAA/C,IACGuC,WAAW,CAACV,CAAD,CAAX,CAAeE,CAAf,IAAoBS,KAAK,GAAGxC,IAAR,GAAgBA,IAAI,GAAG,CAD9C,IAEGuC,WAAW,CAACV,CAAD,CAAX,CAAeE,CAAf,IAAoBW,KAAK,GAAG1C,IAAR,GAAgBA,IAAI,GAAG,CAHlD,EAIK;AACD,gBAAGuC,WAAW,CAACV,CAAD,CAAX,CAAeE,CAAf,KAAqBa,QAAQ,GAAG5C,IAAX,GAAmBA,IAAI,GAAG,CAAlD,EAAqD;AACjDuC,cAAAA,WAAW,CAACV,CAAD,CAAX,CAAeK,KAAf,CAAqB,CAArB,IAA0B,IAA1B;AACA,kBAAI;AAACH,gBAAAA,CAAD;AAAKC,gBAAAA;AAAL,kBAAUO,WAAW,CAACV,CAAD,CAAzB;AACA,kBAAIuB,cAAc,GAAGb,WAAW,CAACc,IAAZ,CAAiBpB,IAAI,IAAIA,IAAI,CAACF,CAAL,KAAWA,CAAX,IAAgBE,IAAI,CAACD,CAAL,KAAWA,CAAC,GAAGhC,IAAxD,CAArB;;AACA,kBAAGoD,cAAH,EAAkB;AACdA,gBAAAA,cAAc,CAAClB,KAAf,CAAqB,CAArB,IAA0B,IAA1B;AACH;AACJ;AACJ;AACJ;;AACCK,QAAAA,WAAW,CAACV,CAAD,CAAX,CAAeyB,IAAf;AACH;AACF,KApCO,EAoCLhB,OAAO,GAAGhC,KApCL,CAAV;AAqCD,GAtCM,CAAP;AAuCD,CA3CD;;AA6CA,MAAM8B,SAAS,GAAG,gBAAeG,WAAf,EAA6BC,KAA7B,EAAoCC,KAApC,EAA2CC,KAA3C,EAAmDC,KAAnD,EAAyD;AAEzE,MAAGH,KAAK,GAAGE,KAAR,GAAgB,CAAhB,IAAqBD,KAAK,GAAGE,KAAR,GAAgB,CAArC,IAA0CrB,IAA7C,EAAmD;AAEnDjB,EAAAA,KAAK;AAEH,MAAIkD,MAAM,GAAG,MAAMlB,QAAQ,CAAChC,KAAD,EAASkC,WAAT,EAAuBC,KAAvB,EAA8BC,KAA9B,EAAqCC,KAArC,EAA6CC,KAA7C,CAA3B;;AACA,MAAGI,MAAM,GAAG,CAAZ,EAAc;AACV;AACI,QAAGQ,MAAH,EAAU;AACRnB,MAAAA,SAAS,CAACG,WAAD,EAAcK,QAAd,EAAwBH,KAAxB,EAA+BC,KAA/B,EAAsCC,KAAtC,CAAT,CADQ,CAC8C;AAC1D;AACA;;AACIP,MAAAA,SAAS,CAACG,WAAD,EAAcC,KAAd,EAAqBC,KAArB,EAA4BG,QAAQ,GAAG,CAAvC,EAA0CD,KAA1C,CAAT,CAJQ,CAIkD;AAC3D,KAPK,CAQV;;AACH,GATD,MASK;AACD;AACE,QAAGY,MAAH,EAAU;AACRnB,MAAAA,SAAS,CAACG,WAAD,EAAcC,KAAd,EAAqBM,QAArB,EAA+BJ,KAA/B,EAAsCC,KAAtC,CAAT,CADQ,CAC8C;AAC1D;AACA;;AACIP,MAAAA,SAAS,CAACG,WAAD,EAAcC,KAAd,EAAqBC,KAArB,EAA4BC,KAA5B,EAAoCI,QAAQ,GAAG,CAA/C,CAAT,CAJQ,CAImD;AAC5D,KAPF,CAQD;;AACH;;AACH;AACD,CA3BD;;AA6BA,MAAMU,cAAc,GAAG,MAAM;AAC3BpC,EAAAA,KAAK,GAAGqC,qBAAqB,CAACD,cAAD,CAA7B;AACAhD,EAAAA,CAAC,CAACkD,SAAF,CAAY,CAAZ,EAAc,CAAd,EAAgBnD,MAAM,CAACN,KAAvB,EAA8BM,MAAM,CAACL,MAArC;;AAEA,OAAI,IAAI2B,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGpB,KAAK,CAAC0C,MAAzB,EAAiCtB,CAAC,EAAlC,EAAsC;AAClCpB,IAAAA,KAAK,CAACoB,CAAD,CAAL,CAASyB,IAAT;AACH;;AAED,OAAI,IAAIzB,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGd,UAAU,CAACoC,MAA9B,EAAsCtB,CAAC,EAAvC,EAA2C;AACvCd,IAAAA,UAAU,CAACc,CAAD,CAAV,CAAcyB,IAAd;AACH;;AAEDpC,EAAAA,UAAU,CAACoC,IAAX;AACAnC,EAAAA,QAAQ,CAACmC,IAAT;;AACA,MAAGnC,QAAQ,CAACwC,SAAZ,EAAsB;AACpBC,IAAAA,SAAS;AACV;;AACD,MAAG9C,WAAH,EAAe;AACbW,IAAAA,oBAAoB,CAACL,KAAD,CAApB;AACD;;AACD,MAAG,CAACD,QAAQ,CAACwC,SAAV,IAAuB,CAAC7C,WAA3B,EAAuC;AACrC+C,IAAAA,UAAU;AACX;AACF,CAvBD;;AAyBA,MAAMA,UAAU,GAAG,MAAM;AACvB,MAAIC,WAAW,GAAG,CAAC,GAAGjD,KAAJ,CAAlB;AACAA,EAAAA,KAAK,CAACkD,KAAN,GAFuB,CAGvB;;AACA,MAAG5C,QAAQ,CAACwC,SAAZ,EAAsB;AAClB;AACH;;AACD,OAAI,IAAI9B,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGiC,WAAW,CAACX,MAA/B,EAAwCtB,CAAC,EAAzC,EAA6C;AACzCmC,IAAAA,mBAAmB,CAACF,WAAW,CAACjC,CAAD,CAAZ,CAAnB;AACH;AACF,CAVD;;AAYA,MAAMmC,mBAAmB,GAAI/B,IAAD,IAAU;AACpC,MAAIF,CAAC,GAAGE,IAAI,CAACF,CAAb;AACA,MAAIC,CAAC,GAAGC,IAAI,CAACD,CAAb;AACA,MAAIiC,KAAK,GAAG,cAAZ;AACA,MAAIC,iBAAiB,GAAGzD,KAAK,CAAC4C,IAAN,CAAWc,GAAG,IAAIA,GAAG,CAACpC,CAAJ,KAAUE,IAAI,CAACF,CAAf,IAAoBoC,GAAG,CAACnC,CAAJ,KAAUC,IAAI,CAACD,CAArD,CAAxB,CAJoC,CAKpC;;AACA,MAAIoC,GAAG,GAAG3D,KAAK,CAAC4C,IAAN,CAAWgB,CAAC,IAAIA,CAAC,CAACtC,CAAF,KAAQA,CAAR,IAAasC,CAAC,CAACrC,CAAF,KAAQA,CAAC,GAAGhC,IAAzC,CAAV;;AACA,MAAGoE,GAAG,IAAI,CAACF,iBAAiB,CAAChC,KAAlB,CAAwB,CAAxB,CAAR,IAAsC,CAACnB,UAAU,CAACsC,IAAX,CAAgBgB,CAAC,IAAIA,CAAC,CAACtC,CAAF,KAAQqC,GAAG,CAACrC,CAAZ,IAAiBsC,CAAC,CAACrC,CAAF,KAAQoC,GAAG,CAACpC,CAAlD,CAA1C,EAA+F;AAC3F,QAAIsC,KAAK,GAAGF,GAAG,CAACrC,CAAhB;AACA,QAAIwC,KAAK,GAAGH,GAAG,CAACpC,CAAhB;;AACA,QAAGsC,KAAK,KAAKnD,QAAQ,CAACY,CAAnB,IAAwBwC,KAAK,KAAKpD,QAAQ,CAACa,CAA9C,EAAgD;AAC5Cb,MAAAA,QAAQ,CAACwC,SAAT,GAAqB1B,IAArB;AACAhB,MAAAA,YAAY,GAAGgB,IAAf;AACA;AACH,KAJD,MAIK;AACD,UAAIuC,SAAS,GAAG,IAAIzE,KAAJ,CAAUuE,KAAV,EAAiBC,KAAjB,EAAyB/D,CAAzB,EAA6BR,IAA7B,EAAoCiE,KAApC,EAA2ChC,IAA3C,CAAhB;AACApB,MAAAA,KAAK,CAACsB,IAAN,CAAWqC,SAAX;AACAzD,MAAAA,UAAU,CAACoB,IAAX,CAAgBqC,SAAhB;AACH;AACJ,GAnBmC,CAqBpC;;;AACA,MAAIC,KAAK,GAAGhE,KAAK,CAAC4C,IAAN,CAAWgB,CAAC,IAAIA,CAAC,CAACtC,CAAF,KAAQA,CAAC,GAAG/B,IAAZ,IAAoBqE,CAAC,CAACrC,CAAF,KAAQA,CAA5C,CAAZ;;AACA,MAAGyC,KAAK,IAAI,CAACP,iBAAiB,CAAChC,KAAlB,CAAwB,CAAxB,CAAV,IAAwC,CAACnB,UAAU,CAACsC,IAAX,CAAgBgB,CAAC,IAAIA,CAAC,CAACtC,CAAF,KAAQ0C,KAAK,CAAC1C,CAAd,IAAoBsC,CAAC,CAACrC,CAAF,KAAQyC,KAAK,CAACzC,CAAvD,CAA5C,EAAsG;AAClG,QAAI0C,OAAO,GAAGD,KAAK,CAAC1C,CAApB;AACA,QAAI4C,OAAO,GAAGF,KAAK,CAACzC,CAApB;;AACA,QAAG0C,OAAO,KAAKvD,QAAQ,CAACY,CAArB,IAA0B4C,OAAO,KAAKxD,QAAQ,CAACa,CAAlD,EAAoD;AAChDb,MAAAA,QAAQ,CAACwC,SAAT,GAAqB1B,IAArB;AACAhB,MAAAA,YAAY,GAAGgB,IAAf;AACA;AACH,KAJD,MAIK;AACD,UAAI2C,WAAW,GAAG,IAAI7E,KAAJ,CAAU2E,OAAV,EAAmBC,OAAnB,EAA4BnE,CAA5B,EAAgCR,IAAhC,EAAuCiE,KAAvC,EAA8ChC,IAA9C,CAAlB;AACApB,MAAAA,KAAK,CAACsB,IAAN,CAAWyC,WAAX;AACA7D,MAAAA,UAAU,CAACoB,IAAX,CAAgByC,WAAhB;AACH;AACJ,GAnCmC,CAqCpC;;;AACA,MAAIC,MAAM,GAAGpE,KAAK,CAAC4C,IAAN,CAAWgB,CAAC,IAAIA,CAAC,CAACtC,CAAF,KAAQA,CAAR,IAAasC,CAAC,CAACrC,CAAF,KAAQA,CAAC,GAAGhC,IAAzC,CAAb;;AACA,MAAG6E,MAAM,IAAI,CAACX,iBAAiB,CAAChC,KAAlB,CAAwB,CAAxB,CAAX,IAAyC,CAACnB,UAAU,CAACsC,IAAX,CAAgBgB,CAAC,IAAIA,CAAC,CAACtC,CAAF,KAAQ8C,MAAM,CAAC9C,CAAf,IAAqBsC,CAAC,CAACrC,CAAF,KAAQ6C,MAAM,CAAC7C,CAAzD,CAA7C,EAA0G;AACtG,QAAI8C,QAAQ,GAAGD,MAAM,CAAC9C,CAAtB;AACA,QAAIgD,QAAQ,GAAGF,MAAM,CAAC7C,CAAtB;;AACA,QAAG8C,QAAQ,KAAK3D,QAAQ,CAACY,CAAtB,IAA2BgD,QAAQ,KAAK5D,QAAQ,CAACa,CAApD,EAAsD;AAClDb,MAAAA,QAAQ,CAACwC,SAAT,GAAqB1B,IAArB;AACAhB,MAAAA,YAAY,GAAGgB,IAAf;AACA;AACH,KAJD,MAIK;AACD,UAAI+C,YAAY,GAAG,IAAIjF,KAAJ,CAAU+E,QAAV,EAAoBC,QAApB,EAA8BvE,CAA9B,EAAkCR,IAAlC,EAAwCiE,KAAxC,EAA+ChC,IAA/C,CAAnB;AACApB,MAAAA,KAAK,CAACsB,IAAN,CAAW6C,YAAX;AACAjE,MAAAA,UAAU,CAACoB,IAAX,CAAgB6C,YAAhB;AACH;AACJ,GAnDmC,CAqDpC;;;AACA,MAAIC,IAAI,GAAGxE,KAAK,CAAC4C,IAAN,CAAWgB,CAAC,IAAIA,CAAC,CAACtC,CAAF,KAAQA,CAAC,GAAG/B,IAAZ,IAAoBqE,CAAC,CAACrC,CAAF,KAAQA,CAA5C,CAAX;;AACA,MAAGiD,IAAI,IAAI,CAACf,iBAAiB,CAAChC,KAAlB,CAAwB,CAAxB,CAAT,IAAuC,CAACnB,UAAU,CAACsC,IAAX,CAAgBgB,CAAC,IAAIA,CAAC,CAACtC,CAAF,KAAQkD,IAAI,CAAClD,CAAb,IAAkBsC,CAAC,CAACrC,CAAF,KAAQiD,IAAI,CAACjD,CAApD,CAA3C,EAAkG;AAC9F,QAAIkD,MAAM,GAAGD,IAAI,CAAClD,CAAlB;AACA,QAAIoD,MAAM,GAAGF,IAAI,CAACjD,CAAlB;;AACA,QAAGkD,MAAM,KAAK/D,QAAQ,CAACY,CAApB,IAAyBoD,MAAM,KAAKhE,QAAQ,CAACa,CAAhD,EAAkD;AAC9Cb,MAAAA,QAAQ,CAACwC,SAAT,GAAqB1B,IAArB;AACAhB,MAAAA,YAAY,GAAGgB,IAAf;AACA;AACH,KAJD,MAIK;AACD,UAAImD,UAAU,GAAG,IAAIrF,KAAJ,CAAUmF,MAAV,EAAiBC,MAAjB,EAAyB3E,CAAzB,EAA4BR,IAA5B,EAAmCiE,KAAnC,EAA2ChC,IAA3C,CAAjB;AACApB,MAAAA,KAAK,CAACsB,IAAN,CAAWiD,UAAX;AACArE,MAAAA,UAAU,CAACoB,IAAX,CAAgBiD,UAAhB;AACH;AACJ;AAEF,CArED;;AAuEA,MAAMxB,SAAS,GAAG,MAAM;AACtB3C,EAAAA,YAAY,CAACgD,KAAb,GAAqB,OAArB;;AACA,MAAGhD,YAAY,CAACc,CAAb,KAAmBb,UAAU,CAACa,CAA9B,IAAmCd,YAAY,CAACe,CAAb,KAAmBd,UAAU,CAACc,CAApE,EAAsE;AAClElB,IAAAA,WAAW,GAAG,IAAd;AACA;AACH;;AACDG,EAAAA,YAAY,GAAGA,YAAY,CAAC0C,SAA5B;AACD,CAPD;;AASA,MAAMd,SAAS,GAAG,CAACwC,GAAD,EAAKC,GAAL,KAAa;AAC7B,SAAOC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,MAAiBH,GAAG,GAAGD,GAAvB,IAA8BA,GAAzC,CAAP;AACD,CAFD;;AAIA,SAAQ9D,KAAR,EAAgBiC,cAAhB","sourcesContent":["import {Node , Block} from './helper_method'\n\nlet size , width , height , cols , rows \n\nlet delay\n\nlet speed\n\nlet canvas , c \n\nlet nodes , block \n\nlet visited_nodes , stack \n\nlet quere , finish_path , nodes_path , path , current_node\n \nlet start_node, end_node \n\nlet myReq , myReqDraw\n\nlet stop = false\n\nconst setUp = (props) => {\n  c = props.c\n  canvas = props.canvas \n  nodes = []\n  visited_nodes = []\n  stack = []\n  quere = []\n  nodes_path = []\n  path = []\n  finish_path = false \n\n  cols = props.cols \n  rows = props.rows \n  size = props.size \n  width = size * cols \n  height = size * rows\n\n  delay = 0 \n  speed = 50\n\n  canvas.width = width\n  canvas.height = height\n\n  stop = !stop \n  cancelAnimationFrame(myReq)\n  console.log(stop)\n  draw_divide_maze()\n}\n\nconst draw_divide_maze = () => {\n  for(let i = 0; i < rows ; i ++){\n    for(let j = 0; j < cols ; j ++){\n        let x = j * size + (size / 2)\n        let y = i * size + (size / 2)\n        let node = new Node(x, y , c , size )\n        if(i === 0 && j !== 0) {\n            node.walls[0] = true\n        }else if(i === rows - 1){\n            node.walls[2] = true\n        }\n\n        if(j === 0){\n            node.walls[3] = true \n        }else if(j === cols - 1 && i !== rows - 1){\n            node.walls[1] = true\n        }\n\n        if(i === 0 && j === 0){\n            stack.push(node)\n            visited_nodes.push(node)\n        }\n        nodes.push(node)\n    }\n  }\n\n  start_node = new Block(size / 2,size / 2 , c , size , \"blue\")\n  quere.push(start_node)\n  end_node = new Block((cols - 1) * size + (size / 2),( rows - 1 ) * size + (size / 2) , c , size , \"green\" )\n  draw_maze(nodes , cols, rows, 0, 0)\n}\n\nconst set_maze = (s_delay , nodes_array , x_max, y_max, x_min , y_min) => {\n  let random_x = getRandom(x_min,x_max)\n  let random_y = getRandom(y_min,y_max)\n  let x_or_y = getRandom(-20, 20) \n  return new Promise(resolve => {\n    setTimeout(() => {\n      for(let i = 0; i < nodes_array.length; i ++){\n          if(x_or_y > 0) { // x\n              if (\n                  nodes_array[i].x === random_x * size + (size / 2) \n                  && nodes_array[i].y <= y_max * size + (size / 2)\n                  && nodes_array[i].y >= y_min * size + (size / 2)\n                  && nodes_array[i].x !== (cols - 1) * size + (size / 2)\n                  ){\n                  if (nodes_array[i].y !== random_y * size + (size / 2)){\n                      nodes_array[i].walls[1] = true\n                      let {x , y} = nodes_array[i]\n                      let neightbor_node = nodes_array.find(node => node.x === x + size && node.y === y) \n                      if(neightbor_node){\n                          neightbor_node.walls[3] = true\n                      } \n                  }\n              }\n          }else{\n              if(\n                  nodes_array[i].y === random_y * size + (size / 2)\n                  && nodes_array[i].x <= x_max * size + (size / 2)\n                  && nodes_array[i].x >= x_min * size + (size / 2)\n                  ){\n                  if(nodes_array[i].x !== random_x * size + (size / 2)){\n                      nodes_array[i].walls[2] = true\n                      let {x , y} = nodes_array[i]\n                      let neightbor_node = nodes_array.find(node => node.x === x && node.y === y + size) \n                      if(neightbor_node){\n                          neightbor_node.walls[0] = true\n                      } \n                  }\n              }\n          }\n            nodes_array[i].draw()\n        }\n      }, s_delay * speed)\n  })\n}\n\nconst draw_maze = async function(nodes_array , x_max, y_max, x_min , y_min){\n\n  if(x_max - x_min < 1 || y_max - y_min < 1 || stop) return\n\n  delay ++\n\n    let result = await set_maze(delay , nodes_array , x_max, y_max, x_min , y_min)\n    if(x_or_y > 0){ \n        // setTimeout(() => {\n            if(result){\n              draw_maze(nodes_array, random_x, y_max, x_min, y_min) // right \n          // }, delay * (speed + 10));\n          // setTimeout(() => {\n              draw_maze(nodes_array, x_max, y_max, random_x + 1, y_min) // left \n            }\n        // }, delay * (speed + 20));\n    }else{\n        // setTimeout(() => {\n          if(result){\n            draw_maze(nodes_array, x_max, random_y, x_min, y_min) // top \n        // }, delay * (speed + 10));\n        // setTimeout(() => {\n            draw_maze(nodes_array, x_max, y_max, x_min , random_y + 1) // bottom\n          }\n        // }, delay * (speed + 20));\n    }\n  return \n}\n\nconst run_solve_maze = () => {\n  myReq = requestAnimationFrame(run_solve_maze)\n  c.clearRect(0,0,canvas.width, canvas.height)\n\n  for(let i = 0; i < nodes.length; i ++){\n      nodes[i].draw()\n  }\n\n  for(let i = 0; i < nodes_path.length; i ++){\n      nodes_path[i].draw()\n  }\n\n  start_node.draw()\n  end_node.draw()\n  if(end_node.prev_node){\n    find_path()\n  }\n  if(finish_path){\n    cancelAnimationFrame(myReq)\n  }\n  if(!end_node.prev_node && !finish_path){\n    solve_maze()\n  }\n}\n\nconst solve_maze = () => {\n  let quere_nodes = [...quere]\n  quere.shift()\n  // visited_nodes_for_path.push(current_node)\n  if(end_node.prev_node){\n      return\n  }\n  for(let i = 0; i < quere_nodes.length ; i ++){\n      check_neighbor_node(quere_nodes[i])\n  }\n}\n\nconst check_neighbor_node = (node) => {\n  let x = node.x\n  let y = node.y\n  let color = \"MidnightBlue\"\n  let current_find_node = nodes.find(c_n => c_n.x === node.x && c_n.y === node.y )\n  // top \n  let top = nodes.find(n => n.x === x && n.y === y - size)\n  if(top && !current_find_node.walls[0] && !nodes_path.find(n => n.x === top.x && n.y === top.y)){\n      let top_x = top.x\n      let top_y = top.y\n      if(top_x === end_node.x && top_y === end_node.y){\n          end_node.prev_node = node \n          current_node = node \n          return \n      }else{\n          let top_block = new Block(top_x, top_y , c , size , color, node)\n          quere.push(top_block)\n          nodes_path.push(top_block)\n      }\n  }\n\n  // right\n  let right = nodes.find(n => n.x === x + size && n.y === y )\n  if(right && !current_find_node.walls[1] && !nodes_path.find(n => n.x === right.x  && n.y === right.y)){\n      let right_x = right.x \n      let right_y = right.y \n      if(right_x === end_node.x && right_y === end_node.y){\n          end_node.prev_node = node \n          current_node = node \n          return \n      }else{\n          let right_block = new Block(right_x, right_y, c , size , color ,node)\n          quere.push(right_block)\n          nodes_path.push(right_block)\n      }\n  }\n\n  // bottom\n  let bottom = nodes.find(n => n.x === x && n.y === y + size ) \n  if(bottom && !current_find_node.walls[2] && !nodes_path.find(n => n.x === bottom.x  && n.y === bottom.y )){\n      let bottom_x = bottom.x \n      let bottom_y = bottom.y \n      if(bottom_x === end_node.x && bottom_y === end_node.y){\n          end_node.prev_node = node \n          current_node = node \n          return \n      }else{\n          let bottom_block = new Block(bottom_x, bottom_y, c , size ,color ,node)\n          quere.push(bottom_block)\n          nodes_path.push(bottom_block)\n      }\n  }\n\n  // left \n  let left = nodes.find(n => n.x === x - size && n.y === y)\n  if(left && !current_find_node.walls[3] && !nodes_path.find(n => n.x === left.x && n.y === left.y)){\n      let left_x = left.x \n      let left_y = left.y \n      if(left_x === end_node.x && left_y === end_node.y){\n          end_node.prev_node = node \n          current_node = node \n          return \n      }else{\n          let left_block = new Block(left_x,left_y, c, size , color , node)\n          quere.push(left_block)\n          nodes_path.push(left_block)\n      }\n  }\n\n}\n\nconst find_path = () => {\n  current_node.color = \"green\"\n  if(current_node.x === start_node.x && current_node.y === start_node.y){\n      finish_path = true\n      return\n  }\n  current_node = current_node.prev_node\n}\n\nconst getRandom = (min,max) => {\n  return Math.floor(Math.random() * (max - min) + min)\n}\n\nexport {setUp , run_solve_maze}\n"]},"metadata":{},"sourceType":"module"}