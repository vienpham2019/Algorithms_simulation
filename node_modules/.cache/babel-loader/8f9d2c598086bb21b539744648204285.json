{"ast":null,"code":"let path = [];\n\nfunction merge_sort(array) {\n  if (array.length === 1) return array;\n  const midd = Math.floor(array.length / 2);\n  const left_arr = array.slice(0, midd);\n  const right_arr = array.slice(midd, array.length);\n  return merge(merge_sort(left_arr), merge_sort(right_arr));\n}\n\nconst merge = (left_array, right_array) => {\n  let sort_array = [];\n  let index = 0;\n\n  while (left_array.length && right_array.length) {\n    // let {min_index, min_left_node , min_right_node} = find_min_node(left_array , right_array)\n    if (left_array[0].height < right_array[0].height) {\n      // let left_node = left_array[0]\n      // let {min_index, min_left_node , min_right_node} = find_min_node(left_array)\n      //   if(left_node.index !== min_index){\n      //     if(min_left_node){\n      //       min_left_node.index = left_node.index\n      //     }else{\n      //       min_right_node.index = left_node.index\n      //     }\n      //     left_node.index = min_index\n      //   }\n      left_array[0].index = index;\n      path.push(left_array[0]);\n      sort_array.push(left_array.shift());\n    } else {\n      //   let {min_index, min_left_node , min_right_node} = find_min_node(right_array)\n      //   if(right_node.index !== min_index){\n      //     if(min_left_node){\n      //       min_left_node.index = right_node.index\n      //     }else{\n      //       min_right_node.index = right_node.index\n      //     }\n      //     right_node.index = min_index\n      //   }\n      right_array[0].index = index;\n      path.push(right_array[0]);\n      sort_array.push(right_array.shift());\n    }\n\n    index++;\n  }\n\n  while (left_array.length) {\n    let left_n = left_array[0]; // let {min_index, min_left_node , min_right_node} = find_min_node(left_array,right_array)\n    // if(left_n.index !== min_index){\n    //   if(min_left_node){\n    //     min_left_node.index = left_n.index\n    //   }else{\n    //     min_right_node.index = left_n.index\n    //   }\n    //   left_n.index = min_index\n    // }\n\n    left_n.index = index;\n    path.push(left_n);\n    sort_array.push(left_array.shift());\n    index++;\n  }\n\n  while (right_array.length) {\n    let right_n = right_array[0]; // let {min_index, min_right_node , min_left_node } = find_min_node(left_array,right_array)\n    // if(right_n.index !== min_index){\n    //   if(min_left_node){\n    //     min_left_node.index = right_n.index\n    //   }else{\n    //     min_right_node.index = right_n.index\n    //   }\n    //   right_n.index = min_index\n    // }\n\n    right_n.index = index;\n    path.push(right_n);\n    sort_array.push(right_array.shift());\n    index++;\n  }\n\n  return sort_array;\n};\n\nconst find_min_node = (left_array = [], right_array = []) => {\n  let com_arr = [...left_array, ...right_array];\n  let min_index = Math.min(...com_arr.map(element => element.index));\n  let min_left_node = left_array.find(element => element.index === min_index);\n  let min_right_node = right_array.find(element => element.index === min_index);\n  return {\n    min_index,\n    min_left_node,\n    min_right_node\n  };\n};\n\nconst solve_array = array => {\n  let answer = merge_sort(array);\n  if (answer) return path;\n};\n\nexport default solve_array;","map":{"version":3,"sources":["/Users/vienpham/Desktop/Algorithms_simulation/algorithms/src/Algorithms/mergeSort.js"],"names":["path","merge_sort","array","length","midd","Math","floor","left_arr","slice","right_arr","merge","left_array","right_array","sort_array","index","height","push","shift","left_n","right_n","find_min_node","com_arr","min_index","min","map","element","min_left_node","find","min_right_node","solve_array","answer"],"mappings":"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","sourcesContent":["let path = []\n\nfunction merge_sort(array){\n  if(array.length === 1) return array \n\n  const midd = Math.floor(array.length / 2)\n  const left_arr = array.slice(0,midd)\n  const right_arr = array.slice(midd, array.length)\n\n  return merge(merge_sort(left_arr), merge_sort(right_arr))\n}\n\nconst merge = (left_array, right_array) => {\n  let sort_array = []\n  let index = 0\n\n  while(left_array.length && right_array.length){\n    // let {min_index, min_left_node , min_right_node} = find_min_node(left_array , right_array)\n    if(left_array[0].height < right_array[0].height){\n        // let left_node = left_array[0]\n        // let {min_index, min_left_node , min_right_node} = find_min_node(left_array)\n    //   if(left_node.index !== min_index){\n    //     if(min_left_node){\n    //       min_left_node.index = left_node.index\n    //     }else{\n    //       min_right_node.index = left_node.index\n    //     }\n    //     left_node.index = min_index\n    //   }\n    left_array[0].index = index \n      path.push(left_array[0])\n      sort_array.push(left_array.shift())\n    }else{\n    //   let {min_index, min_left_node , min_right_node} = find_min_node(right_array)\n    //   if(right_node.index !== min_index){\n    //     if(min_left_node){\n    //       min_left_node.index = right_node.index\n    //     }else{\n    //       min_right_node.index = right_node.index\n    //     }\n    //     right_node.index = min_index\n    //   }\n    right_array[0].index = index \n      path.push(right_array[0])\n      sort_array.push(right_array.shift())\n    }\n    index ++\n  }\n\n  while(left_array.length) {\n    let left_n = left_array[0]\n    // let {min_index, min_left_node , min_right_node} = find_min_node(left_array,right_array)\n    // if(left_n.index !== min_index){\n    //   if(min_left_node){\n    //     min_left_node.index = left_n.index\n    //   }else{\n    //     min_right_node.index = left_n.index\n    //   }\n    //   left_n.index = min_index\n    // }\n    left_n.index = index \n    path.push(left_n)\n    sort_array.push(left_array.shift())\n    index++ \n  }\n  while(right_array.length) {\n    let right_n = right_array[0]\n    // let {min_index, min_right_node , min_left_node } = find_min_node(left_array,right_array)\n    // if(right_n.index !== min_index){\n    //   if(min_left_node){\n    //     min_left_node.index = right_n.index\n    //   }else{\n    //     min_right_node.index = right_n.index\n    //   }\n    //   right_n.index = min_index\n    // }\n    right_n.index = index\n    path.push(right_n)\n    sort_array.push(right_array.shift())\n    index ++\n  }\n  return sort_array\n}\n\nconst find_min_node = (left_array = [],right_array = []) => {\n  let com_arr = [...left_array,...right_array]\n  let min_index =  Math.min(...com_arr.map(element => element.index))\n\n  let min_left_node = left_array.find(element => element.index === min_index)\n\n  let min_right_node = right_array.find(element => element.index === min_index)\n\n  return {min_index, min_left_node , min_right_node}\n}\n\nconst solve_array = array => {\n  let answer = merge_sort(array)\n  if(answer) return path\n}\n\nexport default solve_array"]},"metadata":{},"sourceType":"module"}