{"version":3,"sources":["Algorithms/solve_maze/breadth_first_search.js","Algorithms/solve_maze/depth_first_search.js","Algorithms/solve_maze/a_star.js","Algorithms/solve_maze/greedy_best_first_search.js","Algorithms/solve_maze/dijkstra.js","Algorithms/solve_maze/bidirectional_dijkstra.js","Algorithms/solve_maze/bidirectional_a_star.js","Algorithms/draw_maze/recursive_division_maze_generation.js","Algorithms/draw_maze/prims_maze_generation.js","Algorithms/draw_maze/depth_first_search_maze_generation.js","Algorithms/mazeController.js","Algorithms/helper_method.js","Algorithms/solve_maze/helper_method/algorithms_helper_method.js","App.js","reducer/mazeGeneratorReducer.js","index.js"],"names":["c","canvas","size","nodes","start_node","end_node","visited_nodes","quere","current_node","finish_path","myReq","stack","open_list","close_list","close_list_1","close_list_2","open_list_1","current_node_1","open_list_2","current_node_2","finish_search","delay","speed","cols","rows","frame_per_second","neighbors_node","visited_neighbors_node","current_neighbor_node","myReqDraw","block","width","height","select_draw_algorithims","start_location","end_location","Node","x","y","walls","neighbor_node","prev_node","this","grid","draw","color","beginPath","moveTo","lineTo","lineWidth","lineCap","strokeStyle","stroke","every","e","rect","fillStyle","fill","Block","g","h","f","distance","Infinity","get_top_right_bottom_left","node","array","top","find","n","right","bottom","left","add_to_heap","method","push","i","length","Math","floor","remove_from_heap","pop","stop","left_child","right_child","max_child_index","stop_breadth_first_search","cancelAnimationFrame","run_solve_maze","requestAnimationFrame","clearRect","find_path","solve_maze","quere_nodes","shift","check_neighbor_node","current_find_node","c_n","add_node","wall_num","new_block","stop_depth_first_search","stop_a_star","find_child_node","a","b","node_in_open","n_g","update_node","new_node","set_node","x_1","y_1","x_2","y_2","abs","parent","stop_greedy_best_first_search","sort","filter","stop_dijkstra","create_new_node","find_distance","stop_bidirectional_dijkstra","print_close_and_open_list","close_color","open_color","c_node","next_close_list","neighbor_close_list","check_for_mix_node","stop_bidirectional_a_star","target_node","target_close_list","draw_maze","nodes_array","x_max","y_max","x_min","y_min","random_x","getRandom","random_y","x_or_y","setTimeout","neightbor_node","min","max","random","setup_prims_maze","w","midd_x","midd_y","center_node","draw_prims_maze","clearInterval","add_neighbor_node","create_neighbor_node","link_node_with_random_neighbor","random_num","random_neighbor","move_block","neighbor_nodes","next_node","unshift","left_right","up_down","setUp","props","draw_divide_maze","clearTimeout","myTimeOut","j","depth_first_search_maze","prims_maze","draw_delay","recursive_dividion_maze","check_recursive_delay","algorithms","depth_first_search","breadth_first_search","dijkstra","greedy_best_first_search","bidirectional_a_star","bidirectional_dijkstra","update_info","select_start","select_end","display_points","App","run_set_point","refs","maze","state","window","innerWidth","innerHeight","offsetLeft","offsetTop","setState","addEventListener","pageX","pageY","value","dispay_draw_button","updateCanvas","getContext","swal","button","content","style","select_solve_algorithims","draw_maze_algorithims","solve_maze_algorithims","start_x","start_y","end_x","end_y","className","minWidth","id","aria-label","onChange","target","map","algorithm","maxWidth","s","selected","type","placeholder","onClick","class","position","backgroundColor","ref","Component","connect","init_state","mazeGenerationReducer","store","createStore","mazeGeneratorReducer","_REDUX_DEVTOOLS_EXTENSION_","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.e36941da.chunk.js","sourcesContent":["import {Block} from '../helper_method'\nimport {get_top_right_bottom_left} from './helper_method/algorithms_helper_method'\n\nlet c , canvas , size , nodes , start_node , end_node \n    \nlet visited_nodes ,  quere , current_node , finish_path , myReq\n\nconst breadth_first_search = (props) => {\n    c = props.c\n    canvas = props.canvas \n    size = props.size \n    visited_nodes = []\n    nodes = props.nodes \n\n    quere = []\n    finish_path = false \n    current_node = null  \n    start_node = props.start_node\n    end_node = props.end_node\n\n    end_node.prev_node = null\n\n    quere.push(start_node)\n    cancelAnimationFrame(myReq)\n    run_solve_maze()\n}\n\nconst stop_breadth_first_search = () => {\n    cancelAnimationFrame(myReq)\n}\n\nconst run_solve_maze = () => {\n    myReq = requestAnimationFrame(run_solve_maze)\n    c.clearRect(0,0,canvas.width, canvas.height)\n\n    for(let i = 0; i < nodes.length; i ++){\n        nodes[i].draw()\n    }\n\n    for(let i = 0; i < visited_nodes.length; i ++){\n        visited_nodes[i].draw()\n    }\n\n    if(end_node.prev_node && !finish_path){\n        find_path()\n    }\n    \n    if(finish_path || !quere.length){\n        cancelAnimationFrame(myReq)\n    }\n    if(!end_node.prev_node && !finish_path){\n        solve_maze()\n    }\n}\n  \nconst solve_maze = () => {\n    let quere_nodes = [...quere]\n    quere.shift()\n    // visited_nodes_for_path.push(current_node)\n    if(end_node.prev_node){\n        return\n    }\n    for(let i = 0; i < quere_nodes.length ; i ++){\n        check_neighbor_node(quere_nodes[i])\n    }\n}\n  \nconst check_neighbor_node = (node) => {\n    let current_find_node = nodes.find(c_n => c_n.x === node.x && c_n.y === node.y )\n    let { top , right , bottom , left } = get_top_right_bottom_left(node , nodes , size)\n    // top \n    add_node(top , node , 0 , current_find_node)\n\n    // right\n    add_node(right , node , 1 , current_find_node)\n\n    // bottom\n    add_node(bottom , node , 2 , current_find_node)\n\n    // left \n    add_node(left , node , 3 , current_find_node)\n}\n\nconst add_node = (neighbor_node , node , wall_num , current_find_node) => {\n    let color = 'MediumBlue' \n    if(neighbor_node && !current_find_node.walls[wall_num] && !visited_nodes.find(n => n.x === neighbor_node.x && n.y === neighbor_node.y)){\n        let {x , y} = neighbor_node\n        if(x === end_node.x && y === end_node.y){\n            end_node.prev_node = node \n            current_node = node \n        }else{\n            let new_block = new Block(x, y , c , size , color, node)\n            quere.push(new_block)\n            visited_nodes.push(new_block)\n        }\n    }\n    return \n}\n  \nconst find_path = () => {\n    current_node.color = \"LimeGreen\"\n    if(!current_node.prev_node){\n        finish_path = true\n    }\n    current_node = current_node.prev_node\n}\n\nexport { breadth_first_search ,  stop_breadth_first_search}\n\n","import {Block} from '../helper_method'\nimport {get_top_right_bottom_left} from './helper_method/algorithms_helper_method'\n\nlet c , canvas , size ,  nodes , start_node , end_node \n    \nlet visited_nodes , stack , current_node ,  finish_path , myReq\n\nconst depth_first_search = (props) => {\n    c = props.c\n    canvas = props.canvas \n    size = props.size \n    nodes = props.nodes \n\n    finish_path = false  \n    start_node = props.start_node\n    end_node = props.end_node\n\n    end_node.prev_node = null\n\n    stack = [start_node]\n    visited_nodes = [start_node]\n    current_node = start_node \n\n    stack.push(start_node)\n    cancelAnimationFrame(myReq)\n    run_solve_maze()\n}\n\nconst stop_depth_first_search = () => {\n    cancelAnimationFrame(myReq)\n}\n\nconst run_solve_maze = () => {\n    myReq = requestAnimationFrame(run_solve_maze)\n    c.clearRect(0,0,canvas.width, canvas.height)\n\n    for(let i = 0; i < nodes.length; i ++){\n        nodes[i].draw()\n    }\n\n    for(let i = 0 ; i < visited_nodes.length; i ++){\n        if(!end_node.prev_node){\n            visited_nodes[i].color = 'MediumBlue' \n        }\n        visited_nodes[i].draw()\n    }\n\n    if(!end_node.prev_node){\n        for(let i = 0 ; i < stack.length ; i ++){\n            stack[i].color = 'LightSkyBlue' \n            stack[i].draw()\n        }\n    }\n\n    if(stack.length > 0 && !end_node.prev_node){\n        current_node = stack[0]\n        if(!check_neighbor_node()){\n            stack.shift()\n        }\n    }\n\n    if(end_node.prev_node){\n        start_node.draw()\n        end_node.draw()\n        find_path() \n    }\n\n    if(finish_path || !stack.length){\n        cancelAnimationFrame(myReq)\n    }\n}\n\nconst find_path = () => {\n    current_node.color = \"LimeGreen\"\n    if(current_node.x === start_node.x && current_node.y === start_node.y){\n        finish_path = true\n        return\n    }\n    current_node = current_node.prev_node\n}\n\nconst check_neighbor_node = () => {\n    let {x , y} = current_node // block \n    // let color = \"MidnightBlue\"\n    let current_find_node = nodes.find(c_n => c_n.x === x && c_n.y === y )\n    let {top , right , bottom , left } = get_top_right_bottom_left(current_node , nodes , size)\n\n    // bottom\n    if(add_node(bottom , current_find_node , 2)) return true \n\n    // right\n    if(add_node(right , current_find_node , 1)) return true \n\n    // top \n    if(add_node(top , current_find_node , 0)) return true \n\n    // left \n    if(add_node(left , current_find_node , 3)) return true \n\n    return false \n}\n\nconst add_node = (neighbor_node , current_find_node , wall_num) => {\n    let color = 'MediumBlue'\n    if(\n        neighbor_node \n        && !current_find_node.walls[wall_num] \n        && !visited_nodes.find(n => n.x === neighbor_node.x  && n.y === neighbor_node.y)\n    ){\n        let {x , y} = neighbor_node\n        if(x === end_node.x && y === end_node.y){\n            end_node.prev_node = current_node\n        }else{\n            let new_block = new Block(x, y, c , size ,color , current_node)\n            stack = [new_block,...stack]\n            visited_nodes.push(new_block)\n        }\n        return true \n    }\n    return false \n}\n\nexport { depth_first_search ,  stop_depth_first_search}","import { Block } from '../helper_method'\nimport {get_top_right_bottom_left , add_to_heap , remove_from_heap} from './helper_method/algorithms_helper_method'\n\nlet start_node , end_node , nodes , c , canvas , size \n\nlet open_list , close_list , current_node , myReq\n\nconst a_star = props => {\n    start_node = props.start_node\n    end_node = props.end_node \n    nodes = props.nodes\n    c = props.c \n    canvas = props.canvas \n    size = props.size \n\n    end_node.prev_node = null\n\n    open_list = add_to_heap(start_node , [] , (a,b) => a.f < b.f)\n    close_list = []\n    current_node = null \n\n    cancelAnimationFrame(myReq)\n    run_solve_maze()\n}\n\nconst stop_a_star = () => {\n    cancelAnimationFrame(myReq)\n}\n\nconst run_solve_maze = () => {\n    myReq = requestAnimationFrame(run_solve_maze)\n    c.clearRect(0,0,canvas.width, canvas.height)\n\n    for(let i = 0 ; i < nodes.length ; i ++){\n        nodes[i].draw()\n    }\n\n    for(let i = 0 ; i < close_list.length ; i ++){\n        if(!end_node.prev_node){\n            close_list[i].color = 'MediumBlue'\n        }\n        close_list[i].draw()\n    }\n\n    for(let i = 0 ; i < open_list.length ; i ++){\n        open_list[i].color = 'LightSkyBlue'\n        open_list[i].draw()\n    }\n\n    if(current_node && end_node.x === current_node.x && end_node.y === current_node.y){\n        end_node.prev_node = current_node.prev_node\n    }\n\n    if(open_list.length > 0 && !end_node.prev_node){\n        current_node = open_list[0]\n        close_list.push(current_node)\n        find_child_node()\n    }\n\n    if(end_node.prev_node && current_node){\n        current_node.color = \"LimeGreen\"\n        current_node.draw()\n        current_node = current_node.prev_node\n    }\n\n    if(!current_node || open_list.length === 0){\n        cancelAnimationFrame(myReq)\n    }\n}\n\nconst find_child_node = () => {\n\n    open_list = remove_from_heap(open_list , (a,b) => a.f < b.f)\n    let {top , right , bottom , left} = get_top_right_bottom_left(current_node , nodes , size)\n\n    // right (x + size , y)\n    add_node(right , 3)\n\n    // top (x , y - size)\n    add_node(top , 2)\n\n    // left (x - size , y )\n    add_node(left , 1)\n\n    // bottom (x , y + size)\n    add_node(bottom , 0)\n}\n\nconst add_node = (neighbor_node , wall_num) => {\n    if(\n        neighbor_node \n        && !neighbor_node.walls[wall_num] \n        &&  !close_list.find(node => node.x === neighbor_node.x && node.y === neighbor_node.y)\n    ){\n        let {x , y} = neighbor_node\n        let node_in_open = open_list.find(n => n.x === x  && n.y === y)\n        let n_g = current_node.g + size \n\n        if(node_in_open && n_g < node_in_open.g){\n            update_node(node_in_open, n_g , current_node )\n        }else{\n            let new_node = set_node(neighbor_node, n_g)\n            open_list = add_to_heap(new_node, open_list , (a,b) => a.f < b.f)\n        }\n    }\n}\n\nconst set_node = (node, g) => {\n    let color = 'MediumBlue'\n    let x_1 = node.x \n    let y_1 = node.y \n    let x_2 = end_node.x \n    let y_2 = end_node.y    \n    let h = (Math.abs(x_1 - x_2) + Math.abs(y_1 - y_2)) * size \n    let f = h + g \n    let new_node = new Block(x_1 , y_1 , c , size , color , current_node , g , h , f)\n    return new_node \n}\n\nconst update_node = (node , g , parent) => {\n    node.g = g \n    node.f = g + node.h \n    node.parent = parent \n}\n\nexport {a_star , stop_a_star}","import { Block } from '../helper_method'\nimport {get_top_right_bottom_left} from './helper_method/algorithms_helper_method'\n\nlet start_node , end_node , nodes , c , canvas , size \n\nlet open_list , close_list , current_node , myReq , finish_path\n\nconst greedy_best_first_search = props => {\n    start_node = props.start_node\n    end_node = props.end_node \n    nodes = props.nodes\n    c = props.c \n    canvas = props.canvas \n    size = props.size \n\n    end_node.prev_node = null\n    \n    open_list = [start_node]\n    close_list = []\n    current_node = null \n    finish_path = false \n\n    cancelAnimationFrame(myReq)\n    run_solve_maze()\n}\n\nconst stop_greedy_best_first_search = () => {\n    cancelAnimationFrame(myReq)\n}\n\nconst run_solve_maze = () => {\n    myReq = requestAnimationFrame(run_solve_maze)\n    c.clearRect(0,0,canvas.width, canvas.height)\n\n    for(let i = 0 ; i < nodes.length ; i ++){\n        nodes[i].draw()\n    }\n\n    for(let i = 0 ; i < close_list.length ; i ++){\n        if(!end_node.prev_node){\n            close_list[i].color = 'MediumBlue'\n        }\n        close_list[i].draw()\n    }\n\n    for(let i = 0 ; i < open_list.length ; i ++){\n        open_list[i].color = 'LightSkyBlue' \n        open_list[i].draw()\n    }\n\n    if(current_node && end_node.x === current_node.x && end_node.y === current_node.y){\n        end_node.prev_node = current_node.prev_node\n    }\n\n    if(open_list.length > 0 && !end_node.prev_node){\n        // h is the distance between current node to end node \n        current_node = open_list.sort((a,b) => a.h - b.h)[0] \n        close_list.push(current_node)\n        find_child_node()\n    }\n\n    if(end_node.prev_node){\n        start_node.draw()\n        end_node.draw()\n        find_path() \n    }\n    if(finish_path || !open_list.length){\n        cancelAnimationFrame(myReq)\n    }\n}\n\nconst find_child_node = () => {\n\n    let {top , right , bottom , left} = get_top_right_bottom_left(current_node , nodes , size)\n\n    // right (x + size , y)\n    add_node(right , 3)\n\n    // top (x , y - size)\n    add_node(top , 2)\n\n    // left (x - size , y )\n    add_node(left , 1)\n\n    // bottom (x , y + size)\n    add_node(bottom , 0)\n\n    open_list = open_list.filter(node => node.x === current_node.x && node.y === current_node.y ? false : true )\n}\n\nconst add_node = (neighbor_node , wall_num) => {\n    if(\n        neighbor_node \n        && !neighbor_node.walls[wall_num] \n        &&!close_list.find(node => node.x === neighbor_node.x && node.y === neighbor_node.y)\n    ){\n        let {x , y} = neighbor_node\n        let node_in_open = open_list.find(n => n.x === x  && n.y === y)\n        if(!node_in_open) open_list.push(set_node(neighbor_node))\n    }\n}\n\nconst find_path = () => {\n    current_node.color = \"LimeGreen\"\n    if(current_node.x === start_node.x && current_node.y === start_node.y){\n        finish_path = true\n        return\n    }\n    current_node = current_node.prev_node\n    return \n}\n\nconst set_node = (node) => {\n    let color = 'MediumBlue'\n    let x_1 = node.x \n    let y_1 = node.y \n    let x_2 = end_node.x \n    let y_2 = end_node.y    \n    let h = (Math.abs(x_1 - x_2) + Math.abs(y_1 - y_2)) * size\n    let new_node = new Block(x_1 , y_1 , c , size , color , current_node , null , h )\n    return new_node \n}\n\nexport {greedy_best_first_search , stop_greedy_best_first_search}","import { Block } from '../helper_method'\n\nimport {get_top_right_bottom_left , add_to_heap , remove_from_heap} from './helper_method/algorithms_helper_method'\n\nlet start_node , end_node , nodes , c , canvas , size \n\nlet open_list , close_list , current_node , myReq , finish_path\n\nconst dijkstra = props => {\n    start_node = props.start_node\n    start_node.distance = 0\n    end_node = props.end_node \n    nodes = props.nodes\n    c = props.c \n    canvas = props.canvas \n    size = props.size \n\n    end_node.prev_node = null\n    \n    open_list = [start_node]\n    close_list = []\n    current_node = null \n    finish_path = false \n\n    cancelAnimationFrame(myReq)\n    run_solve_maze()\n}\n\nconst stop_dijkstra = () => {\n    cancelAnimationFrame(myReq)\n}\n\nconst run_solve_maze = () => {\n    myReq = requestAnimationFrame(run_solve_maze)\n    c.clearRect(0,0,canvas.width, canvas.height)\n\n    for(let i = 0 ; i < nodes.length ; i ++){\n        nodes[i].draw()\n    }\n\n    for(let i = 0 ; i < close_list.length ; i ++){\n        if(!end_node.prev_node){\n            close_list[i].color = 'MediumBlue'\n        }\n        close_list[i].draw()\n    }\n\n    for(let i = 0 ; i < open_list.length ; i ++){\n        open_list[i].color = 'LightSkyBlue' \n        open_list[i].draw()\n    }\n\n    if(current_node && end_node.x === current_node.x && end_node.y === current_node.y){\n        end_node.prev_node = current_node.prev_node\n    }\n\n    if(open_list.length > 0 && !end_node.prev_node){\n        // current_node = open_list.sort((a,b) => a.distance - b.distance)[0] \n        current_node = open_list[0] \n        close_list.push(current_node)\n        find_child_node()\n    }\n\n    if(end_node.prev_node){\n        start_node.draw()\n        end_node.draw()\n        find_path() \n    }\n\n    if(finish_path || open_list.length === 0){\n        cancelAnimationFrame(myReq)\n    }\n}\n\nconst find_child_node = () => {\n    open_list = remove_from_heap(open_list , (a,b) => a.distance < b.distance)\n    let {top , right , bottom , left} = get_top_right_bottom_left(current_node , nodes , size)\n\n    // right (x + size , y)\n    add_node(right , 3)\n\n    // top (x , y - size)\n    add_node(top , 2)\n\n    // left (x - size , y )\n    add_node(left , 1)\n\n    // bottom (x , y + size)\n    add_node(bottom , 0)\n\n    open_list = open_list.filter(node => node.x === current_node.x && node.y === current_node.y ? false : true )\n}\n\nconst add_node = (neighbor_node , wall_num) => {\n    if(\n        neighbor_node \n        && !neighbor_node.walls[wall_num] \n        &&!close_list.find(node => node.x === neighbor_node.x && node.y === neighbor_node.y)\n    ){\n        let {x , y} = neighbor_node\n        let node_in_open = open_list.find(n => n.x === x  && n.y === y)\n        \n        if(node_in_open){\n            update_node(node_in_open)\n        }else{\n            let new_node = create_new_node(neighbor_node)\n            open_list = add_to_heap(new_node , open_list , (a,b) => a.distance < b.distance)\n        }\n            \n    }\n}\n\nconst find_path = () => {\n    current_node.color = \"LimeGreen\"\n    if(current_node.x === start_node.x && current_node.y === start_node.y){\n        finish_path = true\n        return\n    }\n    current_node = current_node.prev_node\n    return \n}\n\nconst create_new_node = (node) => {\n    let distance = find_distance(node)\n    return new Block(node.x , node.y , c , size , 'MediumBlue' , current_node , null , null , null , distance)\n}\n\nconst find_distance = (node) => {\n    // find distance from current node to next node \n    let x_1 = current_node.x \n    let y_1 = current_node.y \n\n    let x_2 = node.x \n    let y_2 = node.y\n\n   return ((Math.abs(x_1 - x_2) + Math.abs(y_1 - y_2)) * size ) + current_node.distance\n}\n\nconst update_node = node => {\n    if(current_node.distance + size < node.distance){\n        node.distance = find_distance(node)\n    }\n}\n\nexport {dijkstra , stop_dijkstra}","import { Block } from '../helper_method'\nimport {get_top_right_bottom_left , add_to_heap , remove_from_heap} from './helper_method/algorithms_helper_method'\n\nlet start_node , end_node , nodes , c , canvas , size \n\nlet close_list_1 , close_list_2 , open_list_1 , current_node_1 , open_list_2, current_node_2 , myReq , finish_path , finish_search \n\nconst bidirectional_dijkstra = props => {\n    start_node = props.start_node\n    start_node.distance = 0\n    \n    end_node = props.end_node \n    end_node.distance = 0\n\n    nodes = props.nodes\n    c = props.c \n    canvas = props.canvas \n    size = props.size \n    \n    open_list_1 = [start_node]\n    close_list_1 = []\n\n    open_list_2 = [end_node]\n    close_list_2 = []\n\n    current_node_1 = start_node\n    current_node_2 = end_node \n\n    finish_path = false \n    finish_search = false \n\n    cancelAnimationFrame(myReq)\n    run_solve_maze()\n}\n\nconst stop_bidirectional_dijkstra = () => {\n    cancelAnimationFrame(myReq)\n}\n\nconst run_solve_maze = () => {\n    myReq = requestAnimationFrame(run_solve_maze)\n    c.clearRect(0,0,canvas.width, canvas.height)\n\n    for(let i = 0 ; i < nodes.length ; i ++){\n        nodes[i].draw()\n    }\n\n    print_close_and_open_list(close_list_1 , open_list_1 , 'MediumBlue' , 'LightSkyBlue' )\n    print_close_and_open_list(close_list_2 , open_list_2 , 'CadetBlue' , 'LightCyan')\n\n    if(open_list_2.length > 0 && !finish_search){\n        current_node_2 = open_list_2[0] \n        close_list_2.push(current_node_2)\n        open_list_2 = find_child_node(current_node_2 , open_list_2 , close_list_2 , close_list_1)\n    }\n\n    if(open_list_1.length > 0 && !finish_search){\n        current_node_1 = open_list_1[0] \n        close_list_1.push(current_node_1)\n        open_list_1 = find_child_node(current_node_1 , open_list_1 , close_list_1 , close_list_2)\n    }\n\n    if(finish_search){\n        start_node.draw()\n        end_node.draw()\n\n        if(!current_node_1 && !current_node_2){\n            finish_path = true\n        }\n\n        find_path() \n    }\n\n    if(finish_path || (!open_list_1.length && !open_list_2.length)){\n        cancelAnimationFrame(myReq)\n    }\n}\n\nconst print_close_and_open_list = (close_list , open_list , close_color , open_color ) => {\n    if(!finish_search){\n        for(let i = 0 ; i < open_list.length ; i ++){\n            open_list[i].color = open_color\n            open_list[i].draw()\n        }\n    }\n\n    for(let i = 0 ; i < close_list.length ; i ++){\n        if(!finish_search){\n            close_list[i].color = close_color \n        }\n        close_list[i].draw()\n    }\n}\n\nconst check_for_mix_node = (next_close_list , x , y) => {\n    let node = next_close_list.find(node => node.x === x && node.y === y)\n    if(node){\n        finish_search = true \n        if(close_list_1.find(node => node.x === x  && node.y === y)){\n            current_node_1 = node\n        }else{\n            current_node_2 = node\n        }\n        return true \n    }\n    return false \n}\n\nconst find_child_node = (c_node , open_list , close_list , next_close_list) => {\n    open_list = remove_from_heap(open_list , (a,b) => a.distance < b.distance)\n    let {top , right , bottom , left} = get_top_right_bottom_left(c_node , nodes , size)\n\n    // Right (x + size , y)\n    open_list = add_node(right , c_node , 3 , close_list , open_list , next_close_list) // 3\n\n    // top (x , y - size)\n    open_list = add_node(top , c_node , 2 , close_list , open_list , next_close_list) // 2\n\n    // left (x - size , y )\n    open_list = add_node(left , c_node , 1 , close_list , open_list , next_close_list) // 1\n\n    // bottom (x , y + size)\n    open_list = add_node(bottom , c_node , 0 , close_list , open_list , next_close_list) // 0\n\n    return open_list\n}\n\nconst add_node = (neighbor_node , c_node , wall_num , close_list , open_list , neighbor_close_list) => {\n    if(neighbor_node && !neighbor_node.walls[wall_num] &&!close_list.find(node => node.x === neighbor_node.x && node.y === neighbor_node.y)){\n        let {x , y} = neighbor_node\n        let node_in_open = open_list.find(n => n.x === x  && n.y === y)\n        \n        if(!check_for_mix_node(neighbor_close_list , x , y)){\n            if(node_in_open){\n                update_node(node_in_open , c_node) \n            } else{\n                let new_node = create_new_node(neighbor_node , c_node)\n                open_list = add_to_heap(new_node , open_list , (a,b) => a.distance < b.distance)\n            }\n        }\n    }\n    return open_list\n}\n\nconst find_path = () => {\n    let color = \"LimeGreen\"\n    if(current_node_1){\n        current_node_1.color = color\n        current_node_1 = current_node_1.prev_node\n    }\n    if(current_node_2){\n        current_node_2.color = color\n        current_node_2 = current_node_2.prev_node \n    }\n}\n\nconst create_new_node = (node , c_node) => {\n    let distance = find_distance(node , c_node)\n    return new Block(node.x , node.y , c , size , 'MidnightBlue' , c_node , null , null , null , distance)\n}\n\nconst find_distance = (node , c_node) => {\n    // find distance from current node to next node \n    let x_1 = c_node.x \n    let y_1 = c_node.y\n\n    let x_2 = node.x \n    let y_2 = node.y\n\n   return ((Math.abs(x_1 - x_2) + Math.abs(y_1 - y_2)) * size ) + c_node.distance\n}\n\nconst update_node = (node , c_node) => {\n    if(c_node.distance + size < node.distance){\n        node.distance = find_distance(node , c_node)\n    }\n    return node\n}\n\nexport {bidirectional_dijkstra , stop_bidirectional_dijkstra}","import { Block } from '../helper_method'\nimport {get_top_right_bottom_left , add_to_heap , remove_from_heap} from './helper_method/algorithms_helper_method'\n\nlet start_node , end_node , nodes , c , canvas , size \n\nlet open_list_1 , close_list_1 , current_node_1 , open_list_2 , close_list_2 , current_node_2 , myReq , finish_path , finish_search \n\nconst bidirectional_a_star = props => {\n    start_node = props.start_node\n    end_node = props.end_node \n    nodes = props.nodes\n    c = props.c \n    canvas = props.canvas \n    size = props.size \n\n    open_list_1 = [start_node]\n    close_list_1 = []\n\n    open_list_2 = [end_node]\n    close_list_2 = []\n\n    current_node_1 = null \n    current_node_2 = null \n\n    finish_path = false \n    finish_search = false \n\n    cancelAnimationFrame(myReq)\n    run_solve_maze()\n}\n\nconst stop_bidirectional_a_star = () => {\n    cancelAnimationFrame(myReq)\n}\n\nconst run_solve_maze = () => {\n    myReq = requestAnimationFrame(run_solve_maze)\n    c.clearRect(0,0,canvas.width, canvas.height)\n\n    for(let i = 0 ; i < nodes.length ; i ++){\n        nodes[i].draw()\n    }\n\n    print_close_and_open_list(close_list_1 , open_list_1 , 'MediumBlue' , 'LightSkyBlue' )\n    print_close_and_open_list(close_list_2 , open_list_2 , 'CadetBlue' , 'LightCyan')\n\n    if(open_list_1.length > 0 && !finish_search){\n        current_node_1= open_list_1[0]\n        close_list_1.push(current_node_1)\n        open_list_1 = find_child_node(current_node_1 , end_node, open_list_1 , close_list_1 , close_list_2)\n    }\n\n    if(open_list_2.length > 0 && !finish_search){\n        current_node_2= open_list_2[0]\n        close_list_2.push(current_node_2)\n        open_list_2 = find_child_node(current_node_2 , start_node, open_list_2 , close_list_2 , close_list_1)\n    }\n\n    if(finish_search){\n        start_node.draw()\n        end_node.draw()\n\n        if(!current_node_1 && !current_node_2){\n            finish_path = true\n        }\n        find_path() \n    }\n\n    if(finish_path || (!open_list_1.length && !open_list_2.length)){\n        cancelAnimationFrame(myReq)\n    }\n}\n\nconst print_close_and_open_list = (close_list , open_list , close_color , open_color) => {\n    if(!finish_search){\n        for(let i = 0 ; i < open_list.length ; i ++){\n            open_list[i].color = open_color\n            open_list[i].draw()\n        }\n    }\n\n    for(let i = 0 ; i < close_list.length ; i ++){\n        if(!finish_search){\n            close_list[i].color = close_color \n        }\n        close_list[i].draw()\n    }\n}\n\nconst check_for_mix_node = (target_close_list , x , y) => {\n    let node = target_close_list.find(node => node.x === x && node.y === y)\n    if(node){\n        finish_search = true \n        if(close_list_1.find(node => node.x === x  && node.y === y)){\n            current_node_1 = node\n        }else{\n            current_node_2 = node\n        }\n        return true \n    }\n    return false \n}\n\nconst find_child_node = (c_node , target_node , open_list , close_list , target_close_list) => {\n    open_list = remove_from_heap(open_list , (a,b) => a.f < b.f)\n    let {top , right , bottom , left} = get_top_right_bottom_left(c_node , nodes , size)\n\n    // right (x + size , y)\n    open_list = add_node(c_node , right , 3 , close_list , open_list , target_close_list , target_node)\n\n    // top (x , y - size)\n    open_list = add_node(c_node , top , 2 , close_list , open_list , target_close_list , target_node)\n\n    // left (x - size , y )\n    open_list = add_node(c_node , left , 1 , close_list , open_list , target_close_list , target_node)\n\n    // bottom (x , y + size)\n    open_list = add_node(c_node , bottom , 0 , close_list , open_list , target_close_list , target_node)\n\n    return open_list\n}\n\nconst add_node = (c_node , neighbor_node , wall_num , close_list , open_list , target_close_list , target_node) => {\n    if(\n        neighbor_node \n        && !neighbor_node.walls[wall_num] \n        && !close_list.find(node => node.x === neighbor_node.x  && node.y === neighbor_node.y)\n    ){\n        let {x , y} = neighbor_node \n        let node_in_open = open_list.find(n => n.x === x  && n.y === y)\n        let n_g = c_node.g + size\n\n        if(!check_for_mix_node(target_close_list , x , y)){\n            if(node_in_open && n_g < node_in_open.g){ \n                update_node(node_in_open, n_g , c_node )\n            }else{\n                let new_node = set_node(neighbor_node , n_g , c_node , target_node)\n                open_list = add_to_heap(new_node , open_list , (a,b) => a.f < b.f)\n            }\n        }\n    }\n    return open_list\n}\n\nconst find_path = () => {\n    let color = \"SpringGreen\"\n    if(current_node_1){\n        current_node_1.color = color\n        current_node_1 = current_node_1.prev_node\n    }\n    if(current_node_2){\n        current_node_2.color = color\n        current_node_2 = current_node_2.prev_node \n    }\n}\n\nconst set_node = (node, g , c_node , target_node) => {\n    let color = \"MediumBlue\"\n    let x_1 = node.x \n    let y_1 = node.y \n    let x_2 = target_node.x \n    let y_2 = target_node.y    \n    let h = (Math.abs(x_1 - x_2) + Math.abs(y_1 - y_2)) * size \n    let f = h + g \n    let new_node = new Block(x_1 , y_1 , c , size , color , c_node , g , h , f)\n    return new_node \n}\n\nconst update_node = (node , g , parent) => {\n    node.g = g \n    node.f = g + node.h \n    node.parent = parent \n}\n\nexport {bidirectional_a_star , stop_bidirectional_a_star}","let delay , speed , size , cols , rows , nodes\n\nconst recursive_dividion_maze = (props) => {\n    delay = props.delay\n    speed = props.speed \n    size = props.size \n    cols = props.cols \n    rows = props.rows\n    nodes = props.nodes\n\n    return draw_maze(nodes , cols , rows , 0, 0 , delay , speed , size)\n}\n\nconst draw_maze = (nodes_array , x_max, y_max, x_min , y_min) => {\n\n    if(x_max - x_min < 1 || y_max - y_min < 1) return\n  \n    let random_x = getRandom(x_min,x_max)\n    let random_y = getRandom(y_min,y_max)\n    let x_or_y = getRandom(-20, 20) \n  \n    delay ++\n  \n    setTimeout(() => {\n      for(let i = 0; i < nodes_array.length; i ++){\n          if(x_or_y > 0) { // x\n              if (\n                  nodes_array[i].x === random_x * size + (size / 2) \n                  && nodes_array[i].y <= y_max * size + (size / 2)\n                  && nodes_array[i].y >= y_min * size + (size / 2)\n                  && nodes_array[i].x !== (cols - 1) * size + (size / 2)\n                  ){\n                  if (nodes_array[i].y !== random_y * size + (size / 2)){\n                      nodes_array[i].walls[1] = true\n                      let {x , y} = nodes_array[i]\n                      let neightbor_node = nodes_array.find(node => node.x === (x + size) && node.y === y) \n                      if(neightbor_node){\n                          neightbor_node.walls[3] = true\n                      } \n                  }\n              }\n          }else{\n              if(\n                  nodes_array[i].y === random_y * size + (size / 2)\n                  && nodes_array[i].x <= x_max * size + (size / 2)\n                  && nodes_array[i].x >= x_min * size + (size / 2)\n                  ){\n                  if(nodes_array[i].x !== random_x * size + (size / 2)){\n                      nodes_array[i].walls[2] = true\n                      let {x , y} = nodes_array[i]\n                      let neightbor_node = nodes_array.find(node => node.x === x && node.y === (y + size)) \n                      if(neightbor_node){\n                        neightbor_node.walls[0] = true\n                      } \n                  }\n              }\n          }\n            nodes_array[i].draw()\n        }\n    }, delay * speed)\n  \n    if(x_or_y > 0){ \n      draw_maze(nodes_array, random_x, y_max, x_min, y_min) // right \n      draw_maze(nodes_array, x_max, y_max, random_x + 1, y_min) // left \n    }else{\n      draw_maze(nodes_array, x_max, random_y, x_min, y_min) // top \n      draw_maze(nodes_array, x_max, y_max, x_min , random_y + 1) // bottom\n    }\n  \n    return delay \n}\n\nconst getRandom = (min,max) => {\n    return Math.floor(Math.random() * (max - min) + min)\n}\n\nexport {recursive_dividion_maze}","import {get_top_right_bottom_left} from '../solve_maze/helper_method/algorithms_helper_method'\n\nlet size , nodes , cols , rows , canvas , c , frame_per_second , speed \nlet neighbors_node , visited_neighbors_node , current_neighbor_node , myReqDraw \nconst prims_maze = props => {\n    size = props.size\n    nodes = props.nodes \n    cols = props.cols \n    rows = props.rows \n    canvas = props.canvas \n    c = props.c \n\n    frame_per_second = props.frame_per_second\n    speed = props.speed\n\n    neighbors_node = []\n    visited_neighbors_node = []\n    current_neighbor_node = null \n    \n    clearInterval(myReqDraw)\n    setup_prims_maze(nodes , cols , rows)\n}\n\nconst stop_prims_draw_maze = () => {\n    clearInterval(myReqDraw)\n}\n\nconst setup_prims_maze = (nodes_array , w , h) => {\n    let midd_x =  Math.floor(w / 2) * size + (size / 2)\n    let midd_y =  Math.floor(h / 2) * size + (size / 2)\n    let center_node = nodes_array.find(node => node.x === midd_x && node.y === midd_y)\n    neighbors_node.push(center_node)\n    visited_neighbors_node.push(center_node)\n    current_neighbor_node = center_node\n\n    draw_prims_maze()\n}\n\nconst draw_prims_maze = () => {\n    myReqDraw = setTimeout(() => {\n        draw_prims_maze()\n    }, frame_per_second / speed)\n    c.clearRect(0,0,canvas.width, canvas.height)\n\n    for(let i = 0; i < nodes.length; i ++){\n        nodes[i].draw()\n    }\n\n    if(neighbors_node.length === 0){\n        clearInterval(myReqDraw)\n    }\n\n    add_neighbor_node()\n}\n\nconst add_neighbor_node = () => {\n    let {x , y} = current_neighbor_node\n    let {top , right , bottom , left} = get_top_right_bottom_left(current_neighbor_node , nodes , size) \n\n    // top \n    create_neighbor_node(top)\n\n    // right \n    create_neighbor_node(right)\n\n    //bottom \n    create_neighbor_node(bottom)\n\n    //left \n    create_neighbor_node(left)\n\n    neighbors_node = neighbors_node.filter(node => node.x === x && node.y === y ? false : true )\n\n    link_node_with_random_neighbor()\n}\n\nconst create_neighbor_node = (neighbor_node) => {\n    if(\n        neighbor_node \n        && !visited_neighbors_node.find(node => node.x === neighbor_node.x && node.y === neighbor_node.y)\n        && !neighbors_node.find(node => node.x === neighbor_node.x && node.y === neighbor_node.y)\n    ){\n        neighbors_node.push(neighbor_node)\n        neighbor_node.prev_node = current_neighbor_node\n    }\n}\n\nconst link_node_with_random_neighbor = () => {\n    if(neighbors_node.length === 0) return\n    let random_num = getRandom(0 , neighbors_node.length)\n    let random_neighbor = neighbors_node[random_num]\n    let {top , right , bottom , left} = get_top_right_bottom_left(random_neighbor,visited_neighbors_node , size)\n\n    if(top && top.x === random_neighbor.prev_node.x && top.y === random_neighbor.prev_node.y){\n        random_neighbor.walls[0] = false \n        top.walls[2] = false\n    }\n\n    if(right && right.x === random_neighbor.prev_node.x && right.y === random_neighbor.prev_node.y){\n        random_neighbor.walls[1] = false \n        right.walls[3] = false\n    }\n\n    if(bottom && bottom.x === random_neighbor.prev_node.x && bottom.y === random_neighbor.prev_node.y){\n        random_neighbor.walls[2] = false \n        bottom.walls[0] = false\n    }\n\n    if(left && left.x === random_neighbor.prev_node.x && left.y === random_neighbor.prev_node.y){\n        random_neighbor.walls[3] = false \n        left.walls[1] = false\n    }\n\n    current_neighbor_node = random_neighbor\n    visited_neighbors_node.push(random_neighbor)\n}\n\nconst getRandom = (min,max) => {\n    return Math.floor(Math.random() * (max - min) + min)\n}\n\nexport {prims_maze , stop_prims_draw_maze}\n\n","import {Block} from '../helper_method'\nlet nodes , canvas , c , stack , size , cols , rows , frame_per_second , speed \n\nlet block , finish_path , myReq , visited_nodes , width , height \n\nconst depth_first_search_maze = props => {\n    nodes = props.nodes \n    canvas = props.canvas \n    c = props.c \n    stack = props.stack\n    size = props.size\n    cols = props.cols \n    rows = props.rows\n    frame_per_second = props.frame_per_second\n    speed = props.speed\n\n    block = new Block(size / 2,size / 2 , c , size)\n\n    width = cols * size \n    height = rows * size  \n\n    let start_node = nodes.find(n => n.x === (size / 2) && n.y === (size / 2))\n\n    finish_path = false   \n    visited_nodes = [start_node]\n\n    clearInterval(myReq)\n    draw_maze()\n}\n\nconst stop_depth_first_search_draw_maze = () => {\n    clearInterval(myReq)\n}\n\nconst draw_maze = () => {\n    myReq = setTimeout(() => {\n        draw_maze()\n    }, frame_per_second / speed);\n    c.clearRect(0,0,canvas.width, canvas.height)\n\n    for(let i = 0; i < nodes.length; i ++){\n        nodes[i].draw()\n    }\n\n    if(stack.length === 0){\n        clearInterval(myReq)\n    }else{ \n        move_block()  \n    }\n}\n\nconst move_block = () => {\n    let current_node = stack[0]\n    let neighbor_nodes = []\n    let x = current_node.x\n    let y = current_node.y\n\n    // top\n    if(y - size > 0 && !visited_nodes.find(n => n.x === x && n.y === y - size)){\n        let top = nodes.find(n => n.x === x && n.y === y - size)\n        neighbor_nodes.push(top)\n    }\n\n    // right \n    if(x + size < width && !visited_nodes.find(n => n.x === x + size && n.y === y)){\n        let right = nodes.find(n => n.x === x + size && n.y === y)\n        neighbor_nodes.push(right)\n    }\n\n    // bottom\n    if(y + size < height && !visited_nodes.find(n => n.x === x && n.y === y + size)){\n        let bottom = nodes.find(n => n.x === x && n.y === y + size)\n        neighbor_nodes.push(bottom)\n    }\n\n    // left\n    if(x - size > 0 && !visited_nodes.find(n => n.x === x - size && n.y === y)){\n        let left = nodes.find(n => n.x === x - size && n.y === y)\n        neighbor_nodes.push(left)\n    }\n\n    if(neighbor_nodes.length > 0){\n        let next_node = neighbor_nodes[Math.floor(Math.random() * neighbor_nodes.length)]\n        stack.unshift(next_node)\n        visited_nodes.push(next_node)\n        let left_right = next_node.x - current_node.x\n        let up_down = next_node.y - current_node.y\n\n        if(left_right > 0) { // right \n            current_node.walls[1] = false \n            next_node.walls[3] = false \n        }else if(left_right < 0){ // left\n            current_node.walls[3] = false \n            next_node.walls[1] = false \n        } \n\n        if(up_down > 0) { // down\n            current_node.walls[2] = false \n            next_node.walls[0] = false \n        }else if(up_down < 0){ // up\n            current_node.walls[0] = false \n            next_node.walls[2] = false \n        }\n        block.x = next_node.x \n        block.y = next_node.y\n    }else{\n        block.x = current_node.x \n        block.y = current_node.y\n        stack.shift()\n    }\n    block.draw()\n}\n\nexport {depth_first_search_maze , stop_depth_first_search_draw_maze}","import { Node , Block } from './helper_method'\nimport { breadth_first_search , stop_breadth_first_search }from './solve_maze/breadth_first_search'\nimport { depth_first_search , stop_depth_first_search }from './solve_maze/depth_first_search'\nimport { a_star , stop_a_star }from './solve_maze/a_star'\nimport { greedy_best_first_search , stop_greedy_best_first_search }from './solve_maze/greedy_best_first_search'\nimport { dijkstra , stop_dijkstra }from './solve_maze/dijkstra'\nimport { bidirectional_dijkstra , stop_bidirectional_dijkstra }from './solve_maze/bidirectional_dijkstra'\nimport { bidirectional_a_star , stop_bidirectional_a_star }from './solve_maze/bidirectional_a_star'\n\nimport { recursive_dividion_maze } from './draw_maze/recursive_division_maze_generation'\nimport { prims_maze , stop_prims_draw_maze} from './draw_maze/prims_maze_generation'\nimport { depth_first_search_maze , stop_depth_first_search_draw_maze } from './draw_maze/depth_first_search_maze_generation'\n\nlet size , width , height , cols , rows , select_draw_algorithims , speed \n\nlet delay, canvas , c , start_node, end_node , nodes , stack , frame_per_second , maze_speed , myTimeOut , start_location , end_location \n\nconst setUp = (props) => {\n  stop_breadth_first_search()\n  stop_depth_first_search()\n  stop_a_star()\n  stop_dijkstra()\n  stop_bidirectional_dijkstra()\n  stop_greedy_best_first_search()\n  stop_bidirectional_a_star()\n\n  stop_depth_first_search_draw_maze()\n  stop_prims_draw_maze()\n\n  c = props.c\n  canvas = props.canvas \n  stack = []\n\n  cols = props.cols \n  rows = props.rows \n  size = props.size \n  width = props.width\n  height = props.height\n  select_draw_algorithims = props.select_draw_algorithims\n\n  size = Math.floor(width / cols)\n\n  start_location = {x: size / 2 , y: size / 2}\n  end_location = {x: (cols - 1) * size + (size / 2) , y: (rows - 1) * size + (size / 2)}\n\n  delay = 0 \n  speed = props.speed\n  maze_speed = 700\n\n  frame_per_second = 1000\n\n  canvas.width = width\n  canvas.height = height\n\n  nodes = []\n  draw_divide_maze(props)\n  clearTimeout(myTimeOut)\n  return nodes\n}\n\nconst draw_divide_maze = (props) => {\n  for(let i = 0; i < rows ; i ++){\n    for(let j = 0; j < cols ; j ++){\n      let walls = select_draw_algorithims === \"Recursive Division\" \n        ? [false , false , false ,false] \n        : [true , true , true , true]\n\n      let x = j * size + (size / 2)\n      let y = i * size + (size / 2)\n      let node = new Node(x, y , c , size , walls)\n      if(i === 0){\n        node.walls[0] = true\n      }else if(i === rows - 1){\n        node.walls[2] = true\n      }\n\n      if(j === 0){\n        node.walls[3] = true\n      }else if(j === cols - 1){\n        node.walls[1] = true\n      }\n\n      if(i === 0 && j === 0) {\n          node.walls[0] = false \n      }\n      if(j === cols - 1 && i === rows - 1){\n        node.walls[1] = false\n      }\n\n      if(i === 0 && j === 0){\n          stack.push(node)\n      }\n      nodes.push(node)\n    }\n  }\n\n  start_node = new Block(start_location.x , start_location.y , c , size , \"blue\")\n  end_node = new Block(end_location.x , end_location.y , c , size , \"green\" )\n\n  switch (select_draw_algorithims) {\n    case \"Depth first search\":\n      depth_first_search_maze({nodes , canvas , c , stack , size , cols , rows , frame_per_second , speed })\n      break\n    case \"Prim's\": \n      prims_maze({size , nodes , cols , rows , canvas , c , frame_per_second , speed})\n      break \n    case \"Recursive Division\": \n      let draw_delay = recursive_dividion_maze({delay , speed , size , cols , rows , nodes})\n      if(draw_delay){\n        setTimeout(() => {\n            props.check_recursive_delay(true)\n          }, draw_delay * speed);\n        }\n      break \n    default:\n      break \n  }\n}\n\nconst run_solve_maze = (algorithms) => {\n  stop_greedy_best_first_search()\n  stop_a_star()\n  stop_dijkstra()\n  stop_breadth_first_search()\n  stop_depth_first_search()\n  stop_bidirectional_dijkstra()\n  stop_bidirectional_a_star()\n\n  switch (algorithms) {\n    case \"A star\":\n      a_star({start_node , end_node , nodes , c , canvas , size})\n      break\n    case \"Depth first search\": \n      depth_first_search({nodes , start_node , end_node , c , canvas , size})\n      break\n    case \"Breadth first search\": \n      breadth_first_search({c , canvas , size , nodes , start_node , end_node })\n      break \n    case \"Dijkstra's\": \n      dijkstra({start_node , end_node , nodes , c , canvas , size})\n      break \n    case \"Greedy best first search\": \n      greedy_best_first_search({start_node , end_node , nodes , c , canvas , size})\n      break \n    case \"Bidirectional a star\": \n      bidirectional_a_star({start_node , end_node , nodes , c , canvas , size})\n      break \n    case \"Bidirectional dijkstra's\": \n      bidirectional_dijkstra({start_node , end_node , nodes , c , canvas , size})\n      break \n  }\n}\n\nconst update_info = props => {\n  if(props.start_location){\n    start_location = props.start_location\n    start_node = new Block(start_location.x , start_location.y , c , size , \"blue\")\n  }\n\n  if(props.end_location){\n    end_location = props.end_location\n    end_node = new Block(end_location.x , end_location.y , c , size , \"green\" )\n  }\n}\n\nexport {setUp , run_solve_maze , update_info}\n","\n\nconst Node = function(x , y , c , size , walls , neighbor_node = [], prev_node = null){\n    this.x = x\n    this.y = y\n    this.neighbor_node = neighbor_node\n    this.prev_node = prev_node \n    this.walls = walls// [top, right , bottom , left ]\n    this.grid = false \n\n    this.draw = (color = \"black\") => {\n        let x = this.x - (size / 2)\n        let y = this.y - (size / 2)\n        // Top \n        if(this.walls[0]){\n            c.beginPath()\n            c.moveTo(x, y)\n            c.lineTo(x + size , y)\n            c.lineWidth = 4\n            c.lineCap = \"round\"\n            c.strokeStyle = color\n            c.stroke()\n        }\n\n        // right\n        if(this.walls[1]){\n            c.beginPath()\n            c.moveTo(x + size, y)\n            c.lineTo(x + size , y +size)\n            c.lineWidth = 4\n            c.lineCap = \"round\"\n            c.strokeStyle = color\n            c.stroke()\n        }\n\n        // bottom\n        if(this.walls[2]){\n            c.beginPath()\n            c.moveTo(x + size, y + size)\n            c.lineTo(x, y +size)\n            c.lineWidth = 4\n            c.lineCap = \"round\"\n            c.strokeStyle = color\n            c.stroke()\n        }\n\n        // left \n        if(this.walls[3]){\n            c.beginPath()\n            c.moveTo(x, y + size)\n            c.lineTo(x, y)\n            c.lineWidth = 4\n            c.lineCap = \"round\"\n            c.strokeStyle = color\n            c.stroke()\n        }\n\n        if(this.walls.every( e => e === true) && this.grid){\n            c.beginPath()\n            c.rect(x, y, size, size)\n            c.fillStyle = 'black'\n            c.fill()\n        }\n    }\n}\n\nconst Block = function(x , y , c , size, color = \"red\", prev_node = null , g = null , h = null , f = null , distance = Infinity){\n    this.x = x \n    this.y = y \n    this.prev_node = prev_node\n    this.color = color\n    this.g = g \n    this.h = h \n    this.f = f\n    this.distance = distance\n  \n    this.draw = () => {\n        c.beginPath()\n        c.rect(this.x - (size / 3), this.y - (size / 3), size * 2/3, size * 2/3)\n        c.fillStyle = this.color\n        c.fill()\n    }\n}\n\nexport {Node , Block}","const get_top_right_bottom_left = (node , array , size) => {\n    let {x , y} = node\n    let top = array.find(n => n.x === x && n.y === y - size)\n    let right = array.find(n => n.x === x + size && n.y === y)\n    let bottom = array.find(n => n.x === x && n.y === y + size)\n    let left = array.find(n => n.x === x - size && n.y === y)\n\n    return {top , right , bottom , left }\n}\n\nconst add_to_heap = (node, array, method) => {\n    array.push(node)\n    let i = array.length \n    while(array[Math.floor(i / 2) - 1] && method(array[i - 1] , array[Math.floor(i / 2) - 1])){\n      let current_node = array[i - 1]\n      array[i - 1] = array[Math.floor(i / 2) - 1]\n      array[Math.floor(i / 2) - 1] = current_node\n      i = Math.floor(i / 2)\n    }\n    return array \n  }\n  \n  const remove_from_heap = (array , method) => {\n    let i = 1\n    array[0] = array[array.length - 1]\n    array.pop()\n    let current_node = array[0]\n    let stop = false\n    while(!stop) {\n      let left_child = array[(2 * i) - 1]\n      let right_child = array[(2 * i)]\n      let max_child_index \n      if(left_child && right_child){\n        max_child_index = method(left_child,right_child) ? 2 * i : 2 * i + 1\n      }else if(left_child || right_child){\n        max_child_index = left_child ? 2 * i : 2 * i + 1\n      }\n  \n      if(max_child_index && method(array[max_child_index - 1] ,current_node)){\n        array[i - 1] = array[max_child_index - 1]\n        array[max_child_index - 1] = current_node \n        current_node = array[max_child_index - 1]\n        i = max_child_index\n      }else{\n        stop = true\n      }\n    }\n    return array \n  }\n\nexport {get_top_right_bottom_left , add_to_heap , remove_from_heap}","import React , {Component} from 'react'\nimport {setUp , run_solve_maze , update_info} from './Algorithms/mazeController'\nimport {connect} from 'react-redux'\nimport swal from '@sweetalert/with-react'\n\nlet select_start = false\nlet select_end = false \nlet display_points = false \n\nclass App extends Component{\n  constructor(){\n    super()\n    this.state = {\n      width: (window.innerWidth * .95),\n      height: (window.innerHeight * .92),\n      select_draw_algorithims: \"Depth first search\", \n      select_solve_algorithims: \"A star\",\n      rows: 15, \n      dispay_draw_button: true , \n      speed: \"Normal\", \n      start_location: {x: 40 , y: 170}, \n\n      end_location: {x: 40 , y: 170}, \n    }\n  }\n\n  run_set_point = () => {\n    let canvas = this.refs.maze\n    let {width , rows } = this.state \n    let cols = Math.floor(rows * ((window.innerWidth * .95) / (window.innerHeight * .9))) \n    let size = Math.floor(width / cols)\n    let {offsetLeft , offsetTop} = canvas\n    let start_location = {x: offsetLeft + (size / 2) , y: offsetTop + (size / 2)}\n    let end_location = {x: offsetLeft + ((cols - 1) * size + (size / 2)) , y: offsetTop + ((rows - 1) * size + (size / 2))}\n    this.setState({start_location , end_location})\n    canvas.addEventListener('mousedown' , (e) => {\n      let {pageX , pageY} = e\n      let x = Math.floor(((pageX - offsetLeft) / size)) * (size) + (size / 2) + offsetLeft\n      let y = Math.floor(((pageY - offsetTop) / size)) * (size) + (size / 2) + offsetTop\n      if(x < (cols * size) + offsetLeft && y < (rows * size) + offsetTop){\n        if(select_end){\n          end_location = {x , y}\n          this.setState({end_location})\n          update_info({end_location: {x: x - offsetLeft ,y: y - offsetTop}})\n        }\n\n        if(select_start){\n          start_location = {x , y}\n          this.setState({start_location})\n          update_info({start_location: {x: x - offsetLeft ,y: y - offsetTop}})\n        }\n      }\n    })\n  }\n\n  check_recursive_delay = (value) => {\n    this.setState({dispay_draw_button: value})\n  }\n\n  updateCanvas = () => {\n    // rows == min 15 and max 50\n    display_points = true\n    let {rows , height , width , select_draw_algorithims} = this.state\n\n    let speed = this.props.speed[select_draw_algorithims][this.state.speed]\n\n    if(select_draw_algorithims === \"Recursive Division\"){\n      this.check_recursive_delay(false)\n    }\n\n    let cols = Math.floor(rows * ((window.innerWidth * .95) / (window.innerHeight * .9))) \n\n    const canvas = this.refs.maze\n    const c = canvas.getContext('2d');\n\n    if(rows < 15 || rows > 50){\n      swal({\n        button: false, \n        content: (\n          <div style={{color: 'black'}}>\n            <h3>Rows should be minimum 15 and maximum 50.</h3>\n          </div>\n        )\n      })\n      return\n    }\n    setUp({c , canvas , cols , rows, width , height , select_draw_algorithims , \n    check_recursive_delay: this.check_recursive_delay , speed})\n  }\n\n  render(){\n    let {width , height , select_solve_algorithims , dispay_draw_button} = this.state\n    let {draw_maze_algorithims , solve_maze_algorithims} = this.props\n    let speed = [\"Slow\", \"Normal\", \"Fast\" , \"Supper fast\"]\n    let start_x = this.state.start_location.x\n    let start_y = this.state.start_location.y\n\n    let end_x = this.state.end_location.x\n    let end_y = this.state.end_location.y\n    return(\n      <div className=\"mt-1\">\n        <nav className=\"navbar\">\n          <div className=\"d-flex flex-wrap\">\n            <div className=\"input-group p-2\" style={{minWidth: 600}}>\n              <div className=\"input-group-prepend\">\n                <span className=\"input-group-text\">Algorithms</span>\n              </div>\n              <select \n                className=\"custom-select\" \n                id=\"inputGroupSelect04\" \n                aria-label=\"Example select with button addon\"\n                style={{minWidth: 250}}\n                onChange={(e) => this.setState({select_draw_algorithims: e.target.value})}\n              >\n                {draw_maze_algorithims.map(algorithm => \n                  <option value={algorithm}>{algorithm}</option>\n                )}\n              </select>\n              <div className=\"input-group-prepend\">\n                <span className=\"input-group-text\">Speed</span>\n              </div>\n              <select \n                className=\"custom-select\" \n                id=\"inputGroupSelect04\" \n                aria-label=\"Example select with button addon\"\n                style={{maxWidth: 150}}\n                onChange={(e) => this.setState({speed: e.target.value})}\n              >\n                {speed.map(s => \n                  s === \"Normal\"\n                    ? <option value={s} selected>{s}</option>\n                    : <option value={s} >{s}</option>\n                )}\n              </select>\n              <div className=\"input-group-prepend\">\n                <span className=\"input-group-text\">Size(rows)</span>\n              </div>\n              <input \n                type=\"number\" \n                className=\"form-control\" \n                min='15'\n                max='50'\n                placeholder=\"Minimum 15 and Maximum 50\"\n                style={{minWidth: 100}}\n                onChange={(e) => {\n                  let rows = Math.floor(e.target.value)\n                  this.setState({rows})\n                }}\n              ></input>\n            <div className=\"input-group-append\">\n              {dispay_draw_button ? \n                <button \n                  className=\"btn btn-outline-light\" \n                  type=\"submit\"\n                  onClick={() => {\n                    this.updateCanvas()\n                    this.run_set_point()\n                  }}\n                >\n                  Generate Maze\n                </button>\n              : null }\n            </div>\n          </div>\n          <div className=\"input-group p-2\" style={{maxWidth: 500}}>\n            <div className=\"input-group-prepend\">\n              <span className=\"input-group-text\">Algorithms</span>\n            </div>\n            <select \n              className=\"custom-select\" \n              id=\"inputGroupSelect04\" \n              aria-label=\"Example select with button addon\"\n              onChange={(e) => this.setState({select_solve_algorithims: e.target.value})}\n            >\n              {solve_maze_algorithims.map(algorithm => \n                <option value={algorithm}>{algorithm}</option>\n              )}\n            </select>\n            <div className=\"input-group-append\">\n              <button \n                className=\"btn btn-outline-light\" \n                type=\"button\"\n                onClick={() => run_solve_maze(select_solve_algorithims)}\n              >\n                Solve Maze\n              </button>\n            </div>\n          </div>\n          <button \n            className=\"btn btn-outline-light m-2\" \n            type=\"button\"\n            onClick={() => {\n              this.updateCanvas(false)\n              this.run_set_point()\n            }}\n            style={{width: 100}}\n          >\n            Grid\n          </button>\n          <button \n            className=\"btn m-2\" \n            style={{color: select_start ? 'black' :'white'}}\n            onClick={() => {\n              select_end = false\n              select_start = !select_start\n              this.setState({})\n            }}\n            >\n            <i class=\"fas fa-star\" style={{color: select_start ? 'black' :'white'}}></i> Start Point\n          </button>\n          <button \n            className=\"btn m-2\" \n            style={{color: select_end ? 'black' :'white'}}\n            onClick={() => {\n              select_start = false\n              select_end = !select_end \n              this.setState({})\n            }}\n          >\n            <i class=\"fas fa-bullseye\" style={{color: select_end ? 'black' :'white'}}></i> End Point\n          </button>\n          </div>\n        </nav>\n        <div className=\"m-5\">\n          {display_points ? \n            <i \n              class=\"fas fa-star\" \n              style={{position: \"absolute\", width: 10 , height: 10, top: start_y - 10, left: start_x - 10 , backgroundColor: 'transparent'}}></i>\n          : null } \n          {display_points ? \n            <i \n              class=\"fas fa-bullseye\" \n              style={{position: \"absolute\", width: 6, height: 6, top: end_y - 6, left: end_x - 6 , backgroundColor: 'transparent'}}></i>\n          : null }\n          <canvas ref=\"maze\" style={{width, height}}></canvas>\n        </div> \n      </div>\n    )\n  }\n}\n\nconst mapStateToProps = state => {\n  return {\n    draw_maze_algorithims: state.draw_maze_algorithims,\n    solve_maze_algorithims: state.solve_maze_algorithims,\n    speed: state.speed \n  }\n}\n\nexport default connect(mapStateToProps)(App)\n","let init_state = {\n    draw_maze_algorithims: [\"Depth first search\" , \"Prim's\" , \"Recursive Division\"], \n    solve_maze_algorithims: [\"A star\" , \"Depth first search\" , \"Breadth first search\" , \"Dijkstra's\" , \"Greedy best first search\" , \"Bidirectional a star\" , \"Bidirectional dijkstra's\"], \n    rows: 15,\n    speed: {\n        \"Depth first search\": {\n            \"Slow\": 10, \n            \"Normal\": 50, \n            \"Fast\": 150, \n            \"Supper fast\": 300\n        },\n        \"Prim's\": {\n            \"Slow\": 10, \n            \"Normal\": 50, \n            \"Fast\": 150, \n            \"Supper fast\": 300\n        },\n        \"Recursive Division\": {\n            \"Supper fast\": 10, \n            \"Fast\": 50, \n            \"Normal\": 150, \n            \"Slow\": 300\n        }\n    }\n}\n\nconst mazeGenerationReducer = (state = init_state , action) => {\n    return state \n}\n\nexport default mazeGenerationReducer","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nimport {createStore} from 'redux'\nimport {Provider} from 'react-redux'\n\nimport mazeGeneratorReducer from './reducer/mazeGeneratorReducer'\n\nlet store = createStore(              //==> take reducer\n  mazeGeneratorReducer,\n  window._REDUX_DEVTOOLS_EXTENSION_ && window._REDUX_DEVTOOLS_EXTENSION_()\n)\n\nReactDOM.render(\n  <Provider store = {store}>\n    <App />\n  </Provider>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}