{"version":3,"sources":["Algorithms/solve_maze/breadth_first_search.js","Algorithms/solve_maze/depth_first_search.js","Algorithms/solve_maze/a_star.js","Algorithms/solve_maze/greedy_best_first_search.js","Algorithms/solve_maze/dijkstra.js","Algorithms/solve_maze/bidirectional_dijkstra.js","Algorithms/solve_maze/bidirectional_a_star.js","Algorithms/draw_maze/recursive_division_maze_generation.js","Algorithms/draw_maze/prims_maze_generation.js","Algorithms/draw_maze/depth_first_search_maze_generation.js","Algorithms/mazeController.js","Algorithms/helper_method.js","Algorithms/solve_maze/helper_method/algorithms_helper_method.js","App.js","reducer/mazeGeneratorReducer.js","index.js"],"names":["c","canvas","size","nodes","start_node","end_node","visited_nodes","quere","current_node","finish_path","myReq","stack","open_list","close_list","close_list_1","close_list_2","open_list_1","current_node_1","open_list_2","current_node_2","finish_search","delay","speed","cols","rows","frame_per_second","neighbors_node","visited_neighbors_node","current_neighbor_node","myReqDraw","block","width","height","select_draw_algorithims","start_location","end_location","Node","x","y","walls","neighbor_node","prev_node","this","grid","draw","color","beginPath","moveTo","lineTo","lineWidth","lineCap","strokeStyle","stroke","every","e","rect","fillStyle","fill","Block","g","h","f","distance","Infinity","rect_size","r","arcTo","closePath","get_top_right_bottom_left","node","array","top","find","n","right","bottom","left","add_to_heap","method","push","i","length","Math","floor","remove_from_heap","pop","stop","left_child","right_child","max_child_index","stop_breadth_first_search","cancelAnimationFrame","run_solve_maze","requestAnimationFrame","clearRect","find_path","solve_maze","quere_nodes","shift","check_neighbor_node","current_find_node","c_n","add_node","wall_num","new_block","stop_depth_first_search","stop_a_star","find_child_node","a","b","node_in_open","n_g","update_node","new_node","set_node","x_1","y_1","x_2","y_2","abs","parent","stop_greedy_best_first_search","sort","filter","stop_dijkstra","create_new_node","find_distance","stop_bidirectional_dijkstra","print_close_and_open_list","close_color","open_color","c_node","next_close_list","neighbor_close_list","check_for_mix_node","stop_bidirectional_a_star","target_node","target_close_list","draw_maze","nodes_array","x_max","y_max","x_min","y_min","random_x","getRandom","random_y","x_or_y","setTimeout","neightbor_node","min","max","random","setup_prims_maze","w","midd_x","midd_y","center_node","draw_prims_maze","clearInterval","add_neighbor_node","create_neighbor_node","link_node_with_random_neighbor","random_num","random_neighbor","move_block","neighbor_nodes","next_node","unshift","left_right","up_down","setUp","props","draw_divide_maze","clearTimeout","myTimeOut","j","depth_first_search_maze","prims_maze","draw_delay","recursive_dividion_maze","check_recursive_delay","default_grid","algorithms","depth_first_search","breadth_first_search","dijkstra","greedy_best_first_search","bidirectional_a_star","bidirectional_dijkstra","update_info","select_start","select_end","display_points","App","run_set_point","refs","maze","state","window","innerWidth","innerHeight","offsetLeft","offsetTop","setState","addEventListener","pageX","pageY","value","dispay_draw_button","updateCanvas","getContext","swal","button","content","style","select_solve_algorithims","draw_maze_algorithims","solve_maze_algorithims","start_x","start_y","end_x","end_y","className","minWidth","id","aria-label","onChange","target","map","algorithm","maxWidth","s","selected","type","placeholder","onClick","class","position","backgroundColor","ref","Component","connect","init_state","mazeGenerationReducer","store","createStore","mazeGeneratorReducer","_REDUX_DEVTOOLS_EXTENSION_","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.ce497b50.chunk.js","sourcesContent":["import {Block} from '../helper_method'\nimport {get_top_right_bottom_left} from './helper_method/algorithms_helper_method'\n\nlet c , canvas , size , nodes , start_node , end_node \n    \nlet visited_nodes ,  quere , current_node , finish_path , myReq\n\nconst breadth_first_search = (props) => {\n    c = props.c\n    canvas = props.canvas \n    size = props.size \n    visited_nodes = []\n    nodes = props.nodes \n\n    quere = []\n    finish_path = false \n    current_node = null  \n    start_node = props.start_node\n    end_node = props.end_node\n\n    end_node.prev_node = null\n\n    quere.push(start_node)\n    cancelAnimationFrame(myReq)\n    run_solve_maze()\n}\n\nconst stop_breadth_first_search = () => {\n    cancelAnimationFrame(myReq)\n}\n\nconst run_solve_maze = () => {\n    myReq = requestAnimationFrame(run_solve_maze)\n    c.clearRect(0,0,canvas.width, canvas.height)\n\n    for(let i = 0; i < nodes.length; i ++){\n        nodes[i].draw()\n    }\n\n    for(let i = 0; i < visited_nodes.length; i ++){\n        visited_nodes[i].draw()\n    }\n\n    if(end_node.prev_node && !finish_path){\n        end_node.color = \"SpringGreen\"\n        end_node.draw()\n        find_path()\n    }\n    \n    if(finish_path){\n        cancelAnimationFrame(myReq)\n    }\n    if(!end_node.prev_node && !finish_path){\n        solve_maze()\n    }\n}\n  \nconst solve_maze = () => {\n    let quere_nodes = [...quere]\n    quere.shift()\n    // visited_nodes_for_path.push(current_node)\n    if(end_node.prev_node){\n        return\n    }\n    for(let i = 0; i < quere_nodes.length ; i ++){\n        check_neighbor_node(quere_nodes[i])\n    }\n}\n  \nconst check_neighbor_node = (node) => {\n    let current_find_node = nodes.find(c_n => c_n.x === node.x && c_n.y === node.y )\n    let { top , right , bottom , left } = get_top_right_bottom_left(node , nodes , size)\n    // top \n    add_node(top , node , 0 , current_find_node)\n\n    // right\n    add_node(right , node , 1 , current_find_node)\n\n    // bottom\n    add_node(bottom , node , 2 , current_find_node)\n\n    // left \n    add_node(left , node , 3 , current_find_node)\n}\n\nconst add_node = (neighbor_node , node , wall_num , current_find_node) => {\n    let color = 'MediumBlue' \n    if(neighbor_node && !current_find_node.walls[wall_num] && !visited_nodes.find(n => n.x === neighbor_node.x && n.y === neighbor_node.y)){\n        let {x , y} = neighbor_node\n        if(x === end_node.x && y === end_node.y){\n            end_node.prev_node = node \n            current_node = node \n        }else{\n            let new_block = new Block(x, y , c , size , color, node)\n            quere.push(new_block)\n            visited_nodes.push(new_block)\n        }\n    }\n    return \n}\n  \nconst find_path = () => {\n    current_node.color = \"SpringGreen\"\n    if(!current_node.prev_node){\n        start_node.color = \"SpringGreen\"\n        start_node.draw()\n        finish_path = true\n    }\n    current_node = current_node.prev_node\n}\n\nexport { breadth_first_search ,  stop_breadth_first_search}\n\n","import {Block} from '../helper_method'\nimport {get_top_right_bottom_left} from './helper_method/algorithms_helper_method'\n\nlet c , canvas , size ,  nodes , start_node , end_node \n    \nlet visited_nodes , stack , current_node ,  finish_path , myReq\n\nconst depth_first_search = (props) => {\n    c = props.c\n    canvas = props.canvas \n    size = props.size \n    nodes = props.nodes \n\n    finish_path = false  \n    start_node = props.start_node\n    end_node = props.end_node\n\n    end_node.prev_node = null\n\n    stack = [start_node]\n    visited_nodes = [start_node]\n    current_node = start_node \n\n    stack.push(start_node)\n    cancelAnimationFrame(myReq)\n    run_solve_maze()\n}\n\nconst stop_depth_first_search = () => {\n    cancelAnimationFrame(myReq)\n}\n\nconst run_solve_maze = () => {\n    myReq = requestAnimationFrame(run_solve_maze)\n    c.clearRect(0,0,canvas.width, canvas.height)\n\n    for(let i = 0; i < nodes.length; i ++){\n        nodes[i].draw()\n    }\n\n    for(let i = 0 ; i < visited_nodes.length; i ++){\n        if(!end_node.prev_node){\n            visited_nodes[i].color = 'MediumBlue' \n        }\n        visited_nodes[i].draw()\n    }\n\n    if(!end_node.prev_node){\n        for(let i = 0 ; i < stack.length ; i ++){\n            stack[i].color = 'LightSkyBlue' \n            stack[i].draw()\n        }\n    }\n\n    if(stack.length > 0 && !end_node.prev_node){\n        current_node = stack[0]\n        if(!check_neighbor_node()){\n            stack.shift()\n        }\n    }\n\n    if(end_node.prev_node){\n        end_node.color = \"SpringGreen\"\n        end_node.draw()\n        find_path() \n    }\n\n    if(finish_path){\n        cancelAnimationFrame(myReq)\n    }\n}\n\nconst find_path = () => {\n    current_node.color = \"SpringGreen\"\n    if(current_node.x === start_node.x && current_node.y === start_node.y){\n        start_node.color = \"SpringGreen\"\n        start_node.draw()\n        finish_path = true\n        return\n    }\n    current_node = current_node.prev_node\n}\n\nconst check_neighbor_node = () => {\n    let {x , y} = current_node // block \n    // let color = \"MidnightBlue\"\n    let current_find_node = nodes.find(c_n => c_n.x === x && c_n.y === y )\n    let {top , right , bottom , left } = get_top_right_bottom_left(current_node , nodes , size)\n\n    // bottom\n    if(add_node(bottom , current_find_node , 2)) return true \n\n    // right\n    if(add_node(right , current_find_node , 1)) return true \n\n    // top \n    if(add_node(top , current_find_node , 0)) return true \n\n    // left \n    if(add_node(left , current_find_node , 3)) return true \n\n    return false \n}\n\nconst add_node = (neighbor_node , current_find_node , wall_num) => {\n    let color = 'MediumBlue'\n    if(\n        neighbor_node \n        && !current_find_node.walls[wall_num] \n        && !visited_nodes.find(n => n.x === neighbor_node.x  && n.y === neighbor_node.y)\n    ){\n        let {x , y} = neighbor_node\n        if(x === end_node.x && y === end_node.y){\n            end_node.prev_node = current_node\n        }else{\n            let new_block = new Block(x, y, c , size ,color , current_node)\n            stack = [new_block,...stack]\n            visited_nodes.push(new_block)\n        }\n        return true \n    }\n    return false \n}\n\nexport { depth_first_search ,  stop_depth_first_search}","import { Block } from '../helper_method'\nimport {get_top_right_bottom_left , add_to_heap , remove_from_heap} from './helper_method/algorithms_helper_method'\n\nlet start_node , end_node , nodes , c , canvas , size \n\nlet open_list , close_list , current_node , myReq\n\nconst a_star = props => {\n    start_node = props.start_node\n    end_node = props.end_node \n    nodes = props.nodes\n    c = props.c \n    canvas = props.canvas \n    size = props.size \n\n    end_node.prev_node = null\n\n    open_list = add_to_heap(start_node , [] , (a,b) => a.f < b.f)\n    close_list = []\n    current_node = null \n\n    cancelAnimationFrame(myReq)\n    run_solve_maze()\n}\n\nconst stop_a_star = () => {\n    cancelAnimationFrame(myReq)\n}\n\nconst run_solve_maze = () => {\n    myReq = requestAnimationFrame(run_solve_maze)\n    c.clearRect(0,0,canvas.width, canvas.height)\n\n    for(let i = 0 ; i < nodes.length ; i ++){\n        nodes[i].draw()\n    }\n\n    for(let i = 0 ; i < close_list.length ; i ++){\n        if(!end_node.prev_node){\n            close_list[i].color = 'MediumBlue'\n        }\n        close_list[i].draw()\n    }\n\n    for(let i = 0 ; i < open_list.length ; i ++){\n        open_list[i].color = 'LightSkyBlue'\n        open_list[i].draw()\n    }\n\n    if(current_node && end_node.x === current_node.x && end_node.y === current_node.y){\n        end_node.prev_node = current_node.prev_node\n    }\n\n    if(open_list.length > 0 && !end_node.prev_node){\n        current_node = open_list[0]\n        close_list.push(current_node)\n        find_child_node()\n    }\n\n    if(end_node.prev_node && current_node){\n        current_node.color = \"SpringGreen\"\n        current_node.draw()\n        current_node = current_node.prev_node\n    }\n\n    if(!current_node){\n        cancelAnimationFrame(myReq)\n    }\n}\n\nconst find_child_node = () => {\n\n    open_list = remove_from_heap(open_list , (a,b) => a.f < b.f)\n    let {top , right , bottom , left} = get_top_right_bottom_left(current_node , nodes , size)\n\n    // right (x + size , y)\n    add_node(right , 3)\n\n    // top (x , y - size)\n    add_node(top , 2)\n\n    // left (x - size , y )\n    add_node(left , 1)\n\n    // bottom (x , y + size)\n    add_node(bottom , 0)\n}\n\nconst add_node = (neighbor_node , wall_num) => {\n    if(\n        neighbor_node \n        && !neighbor_node.walls[wall_num] \n        &&  !close_list.find(node => node.x === neighbor_node.x && node.y === neighbor_node.y)\n    ){\n        let {x , y} = neighbor_node\n        let node_in_open = open_list.find(n => n.x === x  && n.y === y)\n        let n_g = current_node.g + size \n\n        if(node_in_open && n_g < node_in_open.g){\n            update_node(node_in_open, n_g , current_node )\n        }else{\n            let new_node = set_node(neighbor_node, n_g)\n            open_list = add_to_heap(new_node, open_list , (a,b) => a.f < b.f)\n        }\n    }\n}\n\nconst set_node = (node, g) => {\n    let color = 'MediumBlue'\n    let x_1 = node.x \n    let y_1 = node.y \n    let x_2 = end_node.x \n    let y_2 = end_node.y    \n    let h = (Math.abs(x_1 - x_2) + Math.abs(y_1 - y_2)) * size \n    let f = h + g \n    let new_node = new Block(x_1 , y_1 , c , size , color , current_node , g , h , f)\n    return new_node \n}\n\nconst update_node = (node , g , parent) => {\n    node.g = g \n    node.f = g + node.h \n    node.parent = parent \n}\n\nexport {a_star , stop_a_star}","import { Block } from '../helper_method'\nimport {get_top_right_bottom_left} from './helper_method/algorithms_helper_method'\n\nlet start_node , end_node , nodes , c , canvas , size \n\nlet open_list , close_list , current_node , myReq , finish_path\n\nconst greedy_best_first_search = props => {\n    start_node = props.start_node\n    end_node = props.end_node \n    nodes = props.nodes\n    c = props.c \n    canvas = props.canvas \n    size = props.size \n\n    end_node.prev_node = null\n    \n    open_list = [start_node]\n    close_list = []\n    current_node = null \n    finish_path = false \n\n    cancelAnimationFrame(myReq)\n    run_solve_maze()\n}\n\nconst stop_greedy_best_first_search = () => {\n    cancelAnimationFrame(myReq)\n}\n\nconst run_solve_maze = () => {\n    myReq = requestAnimationFrame(run_solve_maze)\n    c.clearRect(0,0,canvas.width, canvas.height)\n\n    for(let i = 0 ; i < nodes.length ; i ++){\n        nodes[i].draw()\n    }\n\n    for(let i = 0 ; i < close_list.length ; i ++){\n        if(!end_node.prev_node){\n            close_list[i].color = 'MediumBlue'\n        }\n        close_list[i].draw()\n    }\n\n    for(let i = 0 ; i < open_list.length ; i ++){\n        open_list[i].color = 'LightSkyBlue' \n        open_list[i].draw()\n    }\n\n    if(current_node && end_node.x === current_node.x && end_node.y === current_node.y){\n        end_node.prev_node = current_node.prev_node\n    }\n\n    if(open_list.length > 0 && !end_node.prev_node){\n        // h is the distance between current node to end node \n        current_node = open_list.sort((a,b) => a.h - b.h)[0] \n        close_list.push(current_node)\n        find_child_node()\n    }\n\n    if(end_node.prev_node){\n        end_node.color = \"SpringGreen\"\n        end_node.draw()\n        find_path() \n    }\n    if(finish_path){\n        cancelAnimationFrame(myReq)\n    }\n}\n\nconst find_child_node = () => {\n\n    let {top , right , bottom , left} = get_top_right_bottom_left(current_node , nodes , size)\n\n    // right (x + size , y)\n    add_node(right , 3)\n\n    // top (x , y - size)\n    add_node(top , 2)\n\n    // left (x - size , y )\n    add_node(left , 1)\n\n    // bottom (x , y + size)\n    add_node(bottom , 0)\n\n    open_list = open_list.filter(node => node.x === current_node.x && node.y === current_node.y ? false : true )\n}\n\nconst add_node = (neighbor_node , wall_num) => {\n    if(\n        neighbor_node \n        && !neighbor_node.walls[wall_num] \n        &&!close_list.find(node => node.x === neighbor_node.x && node.y === neighbor_node.y)\n    ){\n        let {x , y} = neighbor_node\n        let node_in_open = open_list.find(n => n.x === x  && n.y === y)\n        if(!node_in_open) open_list.push(set_node(neighbor_node))\n    }\n}\n\nconst find_path = () => {\n    current_node.color = \"SpringGreen\"\n    if(!current_node.prev_node){\n        start_node.color = \"SpringGreen\"\n        start_node.draw()\n        finish_path = true\n        return\n    }\n    current_node = current_node.prev_node\n    return \n}\n\nconst set_node = (node) => {\n    let color = 'MediumBlue'\n    let x_1 = node.x \n    let y_1 = node.y \n    let x_2 = end_node.x \n    let y_2 = end_node.y    \n    let h = (Math.abs(x_1 - x_2) + Math.abs(y_1 - y_2)) * size\n    let new_node = new Block(x_1 , y_1 , c , size , color , current_node , null , h )\n    return new_node \n}\n\nexport {greedy_best_first_search , stop_greedy_best_first_search}","import { Block } from '../helper_method'\n\nimport {get_top_right_bottom_left , add_to_heap , remove_from_heap} from './helper_method/algorithms_helper_method'\n\nlet start_node , end_node , nodes , c , canvas , size \n\nlet open_list , close_list , current_node , myReq , finish_path\n\nconst dijkstra = props => {\n    start_node = props.start_node\n    start_node.distance = 0\n    end_node = props.end_node \n    nodes = props.nodes\n    c = props.c \n    canvas = props.canvas \n    size = props.size \n\n    end_node.prev_node = null\n    \n    open_list = [start_node]\n    close_list = []\n    current_node = null \n    finish_path = false \n\n    cancelAnimationFrame(myReq)\n    run_solve_maze()\n}\n\nconst stop_dijkstra = () => {\n    cancelAnimationFrame(myReq)\n}\n\nconst run_solve_maze = () => {\n    myReq = requestAnimationFrame(run_solve_maze)\n    c.clearRect(0,0,canvas.width, canvas.height)\n\n    for(let i = 0 ; i < nodes.length ; i ++){\n        nodes[i].draw()\n    }\n\n    for(let i = 0 ; i < close_list.length ; i ++){\n        if(!end_node.prev_node){\n            close_list[i].color = 'MediumBlue'\n        }\n        close_list[i].draw()\n    }\n\n    for(let i = 0 ; i < open_list.length ; i ++){\n        if(!end_node.prev_node){\n            open_list[i].color = 'LightSkyBlue' \n        }\n        open_list[i].draw()\n    }\n\n    if(current_node && end_node.x === current_node.x && end_node.y === current_node.y){\n        end_node.prev_node = current_node.prev_node\n    }\n\n    if(open_list.length > 0 && !end_node.prev_node){\n        current_node = open_list[0] \n        close_list.push(current_node)\n        find_child_node()\n    }\n\n    if(end_node.prev_node){\n        end_node.color = \"SpringGreen\"\n        end_node.draw()\n        find_path() \n    }\n\n    if(finish_path){\n        cancelAnimationFrame(myReq)\n    }\n}\n\nconst find_child_node = () => {\n    open_list = remove_from_heap(open_list , (a,b) => a.distance < b.distance)\n    let {top , right , bottom , left} = get_top_right_bottom_left(current_node , nodes , size)\n\n    // right (x + size , y)\n    add_node(right , 3)\n\n    // top (x , y - size)\n    add_node(top , 2)\n\n    // left (x - size , y )\n    add_node(left , 1)\n\n    // bottom (x , y + size)\n    add_node(bottom , 0)\n\n    open_list = open_list.filter(node => node.x === current_node.x && node.y === current_node.y ? false : true )\n}\n\nconst add_node = (neighbor_node , wall_num) => {\n    if(\n        neighbor_node \n        && !neighbor_node.walls[wall_num] \n        &&!close_list.find(node => node.x === neighbor_node.x && node.y === neighbor_node.y)\n    ){\n        let {x , y} = neighbor_node\n        let node_in_open = open_list.find(n => n.x === x  && n.y === y)\n        \n        if(node_in_open){\n            update_node(node_in_open)\n        }else{\n            let new_node = create_new_node(neighbor_node)\n            open_list = add_to_heap(new_node , open_list , (a,b) => a.distance < b.distance)\n        }\n            \n    }\n}\n\nconst find_path = () => {\n    current_node.color = \"SpringGreen\"\n    if(!current_node.prev_node){\n        start_node.color = \"SpringGreen\"\n        start_node.draw()\n        finish_path = true\n        return\n    }\n    current_node = current_node.prev_node\n    return \n}\n\nconst create_new_node = (node) => {\n    let distance = find_distance(node)\n    return new Block(node.x , node.y , c , size , 'MediumBlue' , current_node , null , null , null , distance)\n}\n\nconst find_distance = (node) => {\n    // find distance from current node to next node \n    let x_1 = current_node.x \n    let y_1 = current_node.y \n\n    let x_2 = node.x \n    let y_2 = node.y\n\n   return ((Math.abs(x_1 - x_2) + Math.abs(y_1 - y_2)) * size ) + current_node.distance\n}\n\nconst update_node = node => {\n    if(current_node.distance + size < node.distance){\n        node.distance = find_distance(node)\n    }\n}\n\nexport {dijkstra , stop_dijkstra}","import { Block } from '../helper_method'\nimport {get_top_right_bottom_left , add_to_heap , remove_from_heap} from './helper_method/algorithms_helper_method'\n\nlet start_node , end_node , nodes , c , canvas , size \n\nlet close_list_1 , close_list_2 , open_list_1 , current_node_1 , open_list_2, current_node_2 , myReq , finish_path , finish_search \n\nconst bidirectional_dijkstra = props => {\n    start_node = props.start_node\n    start_node.distance = 0\n    \n    end_node = props.end_node \n    end_node.distance = 0\n\n    nodes = props.nodes\n    c = props.c \n    canvas = props.canvas \n    size = props.size \n    \n    open_list_1 = [start_node]\n    close_list_1 = []\n\n    open_list_2 = [end_node]\n    close_list_2 = []\n\n    current_node_1 = start_node\n    current_node_2 = end_node \n\n    finish_path = false \n    finish_search = false \n\n    cancelAnimationFrame(myReq)\n    run_solve_maze()\n}\n\nconst stop_bidirectional_dijkstra = () => {\n    cancelAnimationFrame(myReq)\n}\n\nconst run_solve_maze = () => {\n    myReq = requestAnimationFrame(run_solve_maze)\n    c.clearRect(0,0,canvas.width, canvas.height)\n\n    for(let i = 0 ; i < nodes.length ; i ++){\n        nodes[i].draw()\n    }\n\n    print_close_and_open_list(close_list_1 , open_list_1 , 'MediumBlue' , 'LightSkyBlue' )\n    print_close_and_open_list(close_list_2 , open_list_2 , 'CadetBlue' , 'LightCyan')\n\n    if(open_list_2.length > 0 && !finish_search){\n        current_node_2 = open_list_2[0] \n        close_list_2.push(current_node_2)\n        open_list_2 = find_child_node(current_node_2 , open_list_2 , close_list_2 , close_list_1)\n    }\n\n    if(open_list_1.length > 0 && !finish_search){\n        current_node_1 = open_list_1[0] \n        close_list_1.push(current_node_1)\n        open_list_1 = find_child_node(current_node_1 , open_list_1 , close_list_1 , close_list_2)\n    }\n\n    if(finish_search){\n        start_node.draw()\n        end_node.draw()\n\n        if(!current_node_1 && !current_node_2){\n            finish_path = true\n        }\n\n        find_path() \n    }\n\n    if(finish_path){\n        cancelAnimationFrame(myReq)\n    }\n}\n\nconst print_close_and_open_list = (close_list , open_list , close_color , open_color ) => {\n    if(!finish_search){\n        for(let i = 0 ; i < open_list.length ; i ++){\n            open_list[i].color = open_color\n            open_list[i].draw()\n        }\n    }\n\n    for(let i = 0 ; i < close_list.length ; i ++){\n        if(!finish_search){\n            close_list[i].color = close_color \n        }\n        close_list[i].draw()\n    }\n}\n\nconst check_for_mix_node = (next_close_list , x , y) => {\n    let node = next_close_list.find(node => node.x === x && node.y === y)\n    if(node){\n        finish_search = true \n        if(close_list_1.find(node => node.x === x  && node.y === y)){\n            current_node_1 = node\n        }else{\n            current_node_2 = node\n        }\n        return true \n    }\n    return false \n}\n\nconst find_child_node = (c_node , open_list , close_list , next_close_list) => {\n    open_list = remove_from_heap(open_list , (a,b) => a.distance < b.distance)\n    let {top , right , bottom , left} = get_top_right_bottom_left(c_node , nodes , size)\n\n    // Right (x + size , y)\n    open_list = add_node(right , c_node , 3 , close_list , open_list , next_close_list) // 3\n\n    // top (x , y - size)\n    open_list = add_node(top , c_node , 2 , close_list , open_list , next_close_list) // 2\n\n    // left (x - size , y )\n    open_list = add_node(left , c_node , 1 , close_list , open_list , next_close_list) // 1\n\n    // bottom (x , y + size)\n    open_list = add_node(bottom , c_node , 0 , close_list , open_list , next_close_list) // 0\n\n    return open_list\n}\n\nconst add_node = (neighbor_node , c_node , wall_num , close_list , open_list , neighbor_close_list) => {\n    if(neighbor_node && !neighbor_node.walls[wall_num] &&!close_list.find(node => node.x === neighbor_node.x && node.y === neighbor_node.y)){\n        let {x , y} = neighbor_node\n        let node_in_open = open_list.find(n => n.x === x  && n.y === y)\n        \n        if(!check_for_mix_node(neighbor_close_list , x , y)){\n            if(node_in_open){\n                update_node(node_in_open , c_node) \n            } else{\n                let new_node = create_new_node(neighbor_node , c_node)\n                open_list = add_to_heap(new_node , open_list , (a,b) => a.distance < b.distance)\n            }\n        }\n    }\n    return open_list\n}\n\nconst find_path = () => {\n    let color = \"SpringGreen\"\n    if(current_node_1){\n        current_node_1.color = color\n        current_node_1 = current_node_1.prev_node\n    }\n    if(current_node_2){\n        current_node_2.color = color\n        current_node_2 = current_node_2.prev_node \n    }\n}\n\nconst create_new_node = (node , c_node) => {\n    let distance = find_distance(node , c_node)\n    return new Block(node.x , node.y , c , size , 'MidnightBlue' , c_node , null , null , null , distance)\n}\n\nconst find_distance = (node , c_node) => {\n    // find distance from current node to next node \n    let x_1 = c_node.x \n    let y_1 = c_node.y\n\n    let x_2 = node.x \n    let y_2 = node.y\n\n   return ((Math.abs(x_1 - x_2) + Math.abs(y_1 - y_2)) * size ) + c_node.distance\n}\n\nconst update_node = (node , c_node) => {\n    if(c_node.distance + size < node.distance){\n        node.distance = find_distance(node , c_node)\n    }\n    return node\n}\n\nexport {bidirectional_dijkstra , stop_bidirectional_dijkstra}","import { Block } from '../helper_method'\nimport {get_top_right_bottom_left , add_to_heap , remove_from_heap} from './helper_method/algorithms_helper_method'\n\nlet start_node , end_node , nodes , c , canvas , size \n\nlet open_list_1 , close_list_1 , current_node_1 , open_list_2 , close_list_2 , current_node_2 , myReq , finish_path , finish_search \n\nconst bidirectional_a_star = props => {\n    start_node = props.start_node\n    end_node = props.end_node \n    nodes = props.nodes\n    c = props.c \n    canvas = props.canvas \n    size = props.size \n\n    open_list_1 = [start_node]\n    close_list_1 = []\n\n    open_list_2 = [end_node]\n    close_list_2 = []\n\n    current_node_1 = null \n    current_node_2 = null \n\n    finish_path = false \n    finish_search = false \n\n    cancelAnimationFrame(myReq)\n    run_solve_maze()\n}\n\nconst stop_bidirectional_a_star = () => {\n    cancelAnimationFrame(myReq)\n}\n\nconst run_solve_maze = () => {\n    myReq = requestAnimationFrame(run_solve_maze)\n    c.clearRect(0,0,canvas.width, canvas.height)\n\n    for(let i = 0 ; i < nodes.length ; i ++){\n        nodes[i].draw()\n    }\n\n    print_close_and_open_list(close_list_1 , open_list_1 , 'MediumBlue' , 'LightSkyBlue' )\n    print_close_and_open_list(close_list_2 , open_list_2 , 'CadetBlue' , 'LightCyan')\n\n    if(open_list_1.length > 0 && !finish_search){\n        current_node_1= open_list_1[0]\n        close_list_1.push(current_node_1)\n        open_list_1 = find_child_node(current_node_1 , end_node, open_list_1 , close_list_1 , close_list_2)\n    }\n\n    if(open_list_2.length > 0 && !finish_search){\n        current_node_2= open_list_2[0]\n        close_list_2.push(current_node_2)\n        open_list_2 = find_child_node(current_node_2 , start_node, open_list_2 , close_list_2 , close_list_1)\n    }\n\n    if(finish_search){\n        start_node.draw()\n        end_node.draw()\n\n        if(!current_node_1 && !current_node_2){\n            finish_path = true\n        }\n        find_path() \n    }\n\n    if(finish_path){\n        cancelAnimationFrame(myReq)\n    }\n}\n\nconst print_close_and_open_list = (close_list , open_list , close_color , open_color) => {\n    if(!finish_search){\n        for(let i = 0 ; i < open_list.length ; i ++){\n            open_list[i].color = open_color\n            open_list[i].draw()\n        }\n    }\n\n    for(let i = 0 ; i < close_list.length ; i ++){\n        if(!finish_search){\n            close_list[i].color = close_color \n        }\n        close_list[i].draw()\n    }\n}\n\nconst check_for_mix_node = (target_close_list , x , y) => {\n    let node = target_close_list.find(node => node.x === x && node.y === y)\n    if(node){\n        finish_search = true \n        if(close_list_1.find(node => node.x === x  && node.y === y)){\n            current_node_1 = node\n        }else{\n            current_node_2 = node\n        }\n        return true \n    }\n    return false \n}\n\nconst find_child_node = (c_node , target_node , open_list , close_list , target_close_list) => {\n    open_list = remove_from_heap(open_list , (a,b) => a.f < b.f)\n    let {top , right , bottom , left} = get_top_right_bottom_left(c_node , nodes , size)\n\n    // right (x + size , y)\n    open_list = add_node(c_node , right , 3 , close_list , open_list , target_close_list , target_node)\n\n    // top (x , y - size)\n    open_list = add_node(c_node , top , 2 , close_list , open_list , target_close_list , target_node)\n\n    // left (x - size , y )\n    open_list = add_node(c_node , left , 1 , close_list , open_list , target_close_list , target_node)\n\n    // bottom (x , y + size)\n    open_list = add_node(c_node , bottom , 0 , close_list , open_list , target_close_list , target_node)\n\n    return open_list\n}\n\nconst add_node = (c_node , neighbor_node , wall_num , close_list , open_list , target_close_list , target_node) => {\n    if(\n        neighbor_node \n        && !neighbor_node.walls[wall_num] \n        && !close_list.find(node => node.x === neighbor_node.x  && node.y === neighbor_node.y)\n    ){\n        let {x , y} = neighbor_node \n        let node_in_open = open_list.find(n => n.x === x  && n.y === y)\n        let n_g = c_node.g + size\n\n        if(!check_for_mix_node(target_close_list , x , y)){\n            if(node_in_open && n_g < node_in_open.g){ \n                update_node(node_in_open, n_g , c_node )\n            }else{\n                let new_node = set_node(neighbor_node , n_g , c_node , target_node)\n                open_list = add_to_heap(new_node , open_list , (a,b) => a.f < b.f)\n            }\n        }\n    }\n    return open_list\n}\n\nconst find_path = () => {\n    let color = \"SpringGreen\"\n    if(current_node_1){\n        current_node_1.color = color\n        current_node_1 = current_node_1.prev_node\n    }\n    if(current_node_2){\n        current_node_2.color = color\n        current_node_2 = current_node_2.prev_node \n    }\n}\n\nconst set_node = (node, g , c_node , target_node) => {\n    let color = \"MediumBlue\"\n    let x_1 = node.x \n    let y_1 = node.y \n    let x_2 = target_node.x \n    let y_2 = target_node.y    \n    let h = (Math.abs(x_1 - x_2) + Math.abs(y_1 - y_2)) * size \n    let f = h + g \n    let new_node = new Block(x_1 , y_1 , c , size , color , c_node , g , h , f)\n    return new_node \n}\n\nconst update_node = (node , g , parent) => {\n    node.g = g \n    node.f = g + node.h \n    node.parent = parent \n}\n\nexport {bidirectional_a_star , stop_bidirectional_a_star}","let delay , speed , size , cols , rows , nodes\n\nconst recursive_dividion_maze = (props) => {\n    delay = props.delay\n    speed = props.speed \n    size = props.size \n    cols = props.cols \n    rows = props.rows\n    nodes = props.nodes\n\n    return draw_maze(nodes , cols , rows , 0, 0 , delay , speed , size)\n}\n\nconst draw_maze = (nodes_array , x_max, y_max, x_min , y_min) => {\n\n    if(x_max - x_min < 1 || y_max - y_min < 1) return\n  \n    let random_x = getRandom(x_min,x_max)\n    let random_y = getRandom(y_min,y_max)\n    let x_or_y = getRandom(-20, 20) \n  \n    delay ++\n  \n    setTimeout(() => {\n      for(let i = 0; i < nodes_array.length; i ++){\n          if(x_or_y > 0) { // x\n              if (\n                  nodes_array[i].x === random_x * size + (size / 2) \n                  && nodes_array[i].y <= y_max * size + (size / 2)\n                  && nodes_array[i].y >= y_min * size + (size / 2)\n                  && nodes_array[i].x !== (cols - 1) * size + (size / 2)\n                  ){\n                  if (nodes_array[i].y !== random_y * size + (size / 2)){\n                      nodes_array[i].walls[1] = true\n                      let {x , y} = nodes_array[i]\n                      let neightbor_node = nodes_array.find(node => node.x === (x + size) && node.y === y) \n                      if(neightbor_node){\n                          neightbor_node.walls[3] = true\n                      } \n                  }\n              }\n          }else{\n              if(\n                  nodes_array[i].y === random_y * size + (size / 2)\n                  && nodes_array[i].x <= x_max * size + (size / 2)\n                  && nodes_array[i].x >= x_min * size + (size / 2)\n                  ){\n                  if(nodes_array[i].x !== random_x * size + (size / 2)){\n                      nodes_array[i].walls[2] = true\n                      let {x , y} = nodes_array[i]\n                      let neightbor_node = nodes_array.find(node => node.x === x && node.y === (y + size)) \n                      if(neightbor_node){\n                        neightbor_node.walls[0] = true\n                      } \n                  }\n              }\n          }\n            nodes_array[i].draw()\n        }\n    }, delay * speed)\n  \n    if(x_or_y > 0){ \n      draw_maze(nodes_array, random_x, y_max, x_min, y_min) // right \n      draw_maze(nodes_array, x_max, y_max, random_x + 1, y_min) // left \n    }else{\n      draw_maze(nodes_array, x_max, random_y, x_min, y_min) // top \n      draw_maze(nodes_array, x_max, y_max, x_min , random_y + 1) // bottom\n    }\n  \n    return delay \n}\n\nconst getRandom = (min,max) => {\n    return Math.floor(Math.random() * (max - min) + min)\n}\n\nexport {recursive_dividion_maze}","import {get_top_right_bottom_left} from '../solve_maze/helper_method/algorithms_helper_method'\n\nlet size , nodes , cols , rows , canvas , c , frame_per_second , speed \nlet neighbors_node , visited_neighbors_node , current_neighbor_node , myReqDraw \nconst prims_maze = props => {\n    size = props.size\n    nodes = props.nodes \n    cols = props.cols \n    rows = props.rows \n    canvas = props.canvas \n    c = props.c \n\n    frame_per_second = props.frame_per_second\n    speed = props.speed\n\n    neighbors_node = []\n    visited_neighbors_node = []\n    current_neighbor_node = null \n    \n    clearInterval(myReqDraw)\n    setup_prims_maze(nodes , cols , rows)\n}\n\nconst stop_prims_draw_maze = () => {\n    clearInterval(myReqDraw)\n}\n\nconst setup_prims_maze = (nodes_array , w , h) => {\n    let midd_x =  Math.floor(w / 2) * size + (size / 2)\n    let midd_y =  Math.floor(h / 2) * size + (size / 2)\n    let center_node = nodes_array.find(node => node.x === midd_x && node.y === midd_y)\n    neighbors_node.push(center_node)\n    visited_neighbors_node.push(center_node)\n    current_neighbor_node = center_node\n\n    draw_prims_maze()\n}\n\nconst draw_prims_maze = () => {\n    myReqDraw = setTimeout(() => {\n        draw_prims_maze()\n    }, frame_per_second / speed)\n    c.clearRect(0,0,canvas.width, canvas.height)\n\n    for(let i = 0; i < nodes.length; i ++){\n        nodes[i].draw()\n    }\n\n    if(neighbors_node.length === 0){\n        clearInterval(myReqDraw)\n    }\n\n    add_neighbor_node()\n}\n\nconst add_neighbor_node = () => {\n    let {x , y} = current_neighbor_node\n    let {top , right , bottom , left} = get_top_right_bottom_left(current_neighbor_node , nodes , size) \n\n    // top \n    create_neighbor_node(top)\n\n    // right \n    create_neighbor_node(right)\n\n    //bottom \n    create_neighbor_node(bottom)\n\n    //left \n    create_neighbor_node(left)\n\n    neighbors_node = neighbors_node.filter(node => node.x === x && node.y === y ? false : true )\n\n    link_node_with_random_neighbor()\n}\n\nconst create_neighbor_node = (neighbor_node) => {\n    if(\n        neighbor_node \n        && !visited_neighbors_node.find(node => node.x === neighbor_node.x && node.y === neighbor_node.y)\n        && !neighbors_node.find(node => node.x === neighbor_node.x && node.y === neighbor_node.y)\n    ){\n        neighbors_node.push(neighbor_node)\n        neighbor_node.prev_node = current_neighbor_node\n    }\n}\n\nconst link_node_with_random_neighbor = () => {\n    if(neighbors_node.length === 0) return\n    let random_num = getRandom(0 , neighbors_node.length)\n    let random_neighbor = neighbors_node[random_num]\n    let {top , right , bottom , left} = get_top_right_bottom_left(random_neighbor,visited_neighbors_node , size)\n\n    if(top && top.x === random_neighbor.prev_node.x && top.y === random_neighbor.prev_node.y){\n        random_neighbor.walls[0] = false \n        top.walls[2] = false\n    }\n\n    if(right && right.x === random_neighbor.prev_node.x && right.y === random_neighbor.prev_node.y){\n        random_neighbor.walls[1] = false \n        right.walls[3] = false\n    }\n\n    if(bottom && bottom.x === random_neighbor.prev_node.x && bottom.y === random_neighbor.prev_node.y){\n        random_neighbor.walls[2] = false \n        bottom.walls[0] = false\n    }\n\n    if(left && left.x === random_neighbor.prev_node.x && left.y === random_neighbor.prev_node.y){\n        random_neighbor.walls[3] = false \n        left.walls[1] = false\n    }\n\n    current_neighbor_node = random_neighbor\n    visited_neighbors_node.push(random_neighbor)\n}\n\nconst getRandom = (min,max) => {\n    return Math.floor(Math.random() * (max - min) + min)\n}\n\nexport {prims_maze , stop_prims_draw_maze}\n\n","import {Block} from '../helper_method'\nlet nodes , canvas , c , stack , size , cols , rows , frame_per_second , speed \n\nlet block , myReq , visited_nodes , width , height \n\nconst depth_first_search_maze = props => {\n    nodes = props.nodes \n    canvas = props.canvas \n    c = props.c \n    stack = props.stack\n    size = props.size\n    cols = props.cols \n    rows = props.rows\n    frame_per_second = props.frame_per_second\n    speed = props.speed\n\n    block = new Block(size / 2,size / 2 , c , size)\n\n    width = cols * size \n    height = rows * size  \n\n    let start_node = nodes.find(n => n.x === (size / 2) && n.y === (size / 2))\n\n    visited_nodes = [start_node]\n\n    clearInterval(myReq)\n    draw_maze()\n}\n\nconst stop_depth_first_search_draw_maze = () => {\n    clearInterval(myReq)\n}\n\nconst draw_maze = () => {\n    myReq = setTimeout(() => {\n        draw_maze()\n    }, frame_per_second / speed);\n    c.clearRect(0,0,canvas.width, canvas.height)\n\n    for(let i = 0; i < nodes.length; i ++){\n        nodes[i].draw()\n    }\n\n    if(stack.length === 0){\n        clearInterval(myReq)\n    }else{ \n        move_block()  \n    }\n}\n\nconst move_block = () => {\n    let current_node = stack[0]\n    let neighbor_nodes = []\n    let x = current_node.x\n    let y = current_node.y\n\n    // top\n    if(y - size > 0 && !visited_nodes.find(n => n.x === x && n.y === y - size)){\n        let top = nodes.find(n => n.x === x && n.y === y - size)\n        neighbor_nodes.push(top)\n    }\n\n    // right \n    if(x + size < width && !visited_nodes.find(n => n.x === x + size && n.y === y)){\n        let right = nodes.find(n => n.x === x + size && n.y === y)\n        neighbor_nodes.push(right)\n    }\n\n    // bottom\n    if(y + size < height && !visited_nodes.find(n => n.x === x && n.y === y + size)){\n        let bottom = nodes.find(n => n.x === x && n.y === y + size)\n        neighbor_nodes.push(bottom)\n    }\n\n    // left\n    if(x - size > 0 && !visited_nodes.find(n => n.x === x - size && n.y === y)){\n        let left = nodes.find(n => n.x === x - size && n.y === y)\n        neighbor_nodes.push(left)\n    }\n\n    if(neighbor_nodes.length > 0){\n        let next_node = neighbor_nodes[Math.floor(Math.random() * neighbor_nodes.length)]\n        stack.unshift(next_node)\n        visited_nodes.push(next_node)\n        let left_right = next_node.x - current_node.x\n        let up_down = next_node.y - current_node.y\n\n        if(left_right > 0) { // right \n            current_node.walls[1] = false \n            next_node.walls[3] = false \n        }else if(left_right < 0){ // left\n            current_node.walls[3] = false \n            next_node.walls[1] = false \n        } \n\n        if(up_down > 0) { // down\n            current_node.walls[2] = false \n            next_node.walls[0] = false \n        }else if(up_down < 0){ // up\n            current_node.walls[0] = false \n            next_node.walls[2] = false \n        }\n        block.x = next_node.x \n        block.y = next_node.y\n    }else{\n        block.x = current_node.x \n        block.y = current_node.y\n        stack.shift()\n    }\n    block.draw()\n}\n\nexport {depth_first_search_maze , stop_depth_first_search_draw_maze}","import { Node , Block } from './helper_method'\nimport { breadth_first_search , stop_breadth_first_search }from './solve_maze/breadth_first_search'\nimport { depth_first_search , stop_depth_first_search }from './solve_maze/depth_first_search'\nimport { a_star , stop_a_star }from './solve_maze/a_star'\nimport { greedy_best_first_search , stop_greedy_best_first_search }from './solve_maze/greedy_best_first_search'\nimport { dijkstra , stop_dijkstra }from './solve_maze/dijkstra'\nimport { bidirectional_dijkstra , stop_bidirectional_dijkstra }from './solve_maze/bidirectional_dijkstra'\nimport { bidirectional_a_star , stop_bidirectional_a_star }from './solve_maze/bidirectional_a_star'\n\nimport { recursive_dividion_maze } from './draw_maze/recursive_division_maze_generation'\nimport { prims_maze , stop_prims_draw_maze} from './draw_maze/prims_maze_generation'\nimport { depth_first_search_maze , stop_depth_first_search_draw_maze } from './draw_maze/depth_first_search_maze_generation'\n\nlet size , width , height , cols , rows , select_draw_algorithims , speed \n\nlet delay, canvas , c , start_node, end_node , nodes , stack , frame_per_second , maze_speed , myTimeOut , start_location , end_location \n\nconst setUp = (props) => {\n  stop_breadth_first_search()\n  stop_depth_first_search()\n  stop_a_star()\n  stop_dijkstra()\n  stop_bidirectional_dijkstra()\n  stop_greedy_best_first_search()\n  stop_bidirectional_a_star()\n\n  stop_depth_first_search_draw_maze()\n  stop_prims_draw_maze()\n\n  c = props.c\n  canvas = props.canvas \n  stack = []\n\n  cols = props.cols \n  rows = props.rows \n  size = props.size \n  width = props.width\n  height = props.height\n  select_draw_algorithims = props.select_draw_algorithims\n\n  size = Math.floor(width / cols)\n\n  start_location = {x: size / 2 , y: size / 2}\n  end_location = {x: (cols - 1) * size + (size / 2) , y: (rows - 1) * size + (size / 2)}\n\n  delay = 0 \n  speed = props.speed\n  maze_speed = 700\n\n  frame_per_second = 1000\n\n  canvas.width = width\n  canvas.height = height\n\n  nodes = []\n  draw_divide_maze(props)\n  clearTimeout(myTimeOut)\n  return nodes\n}\n\nconst draw_divide_maze = (props) => {\n  for(let i = 0; i < rows ; i ++){\n    for(let j = 0; j < cols ; j ++){\n      let walls = select_draw_algorithims === \"Recursive Division\" \n        ? [false , false , false ,false]  \n        : [true , true , true , true]\n\n      let x = j * size + (size / 2)\n      let y = i * size + (size / 2)\n      let node = new Node(x, y , c , size , walls)\n      if(select_draw_algorithims !== \"\"){\n        if(i === 0){\n          node.walls[0] = true\n        }else if(i === rows - 1){\n          node.walls[2] = true\n        }\n\n        if(j === 0){\n          node.walls[3] = true\n        }else if(j === cols - 1){\n          node.walls[1] = true\n        }\n\n        if(i === 0 && j === 0) {\n            node.walls[0] = false \n        }\n        if(j === cols - 1 && i === rows - 1){\n          node.walls[1] = false\n        }\n\n        if(i === 0 && j === 0){\n            stack.push(node)\n        }\n      }\n      nodes.push(node)\n    }\n  }\n\n  start_node = new Block(start_location.x , start_location.y , c , size , \"blue\")\n  end_node = new Block(end_location.x , end_location.y , c , size , \"green\" )\n\n  switch (select_draw_algorithims) {\n    case \"Depth first search\":\n      depth_first_search_maze({nodes , canvas , c , stack , size , cols , rows , frame_per_second , speed })\n      break\n    case \"Prim's\": \n      prims_maze({size , nodes , cols , rows , canvas , c , frame_per_second , speed})\n      break \n    case \"Recursive Division\": \n      let draw_delay = recursive_dividion_maze({delay , speed , size , cols , rows , nodes})\n      if(draw_delay){\n        setTimeout(() => {\n            props.check_recursive_delay(true)\n          }, draw_delay * speed);\n        }\n      break \n    default:\n      default_grid()\n      break \n  }\n}\n\nconst default_grid = () => {\n  for(let i = 0 ; i < nodes.length ; i ++){\n    nodes[i].draw()\n  }\n}\n\nconst run_solve_maze = (algorithms) => {\n  stop_greedy_best_first_search()\n  stop_a_star()\n  stop_dijkstra()\n  stop_breadth_first_search()\n  stop_depth_first_search()\n  stop_bidirectional_dijkstra()\n  stop_bidirectional_a_star()\n\n  switch (algorithms) {\n    case \"A star\":\n      a_star({start_node , end_node , nodes , c , canvas , size})\n      break\n    case \"Depth first search\": \n      depth_first_search({nodes , start_node , end_node , c , canvas , size})\n      break\n    case \"Breadth first search\": \n      breadth_first_search({c , canvas , size , nodes , start_node , end_node })\n      break \n    case \"Dijkstra's\": \n      dijkstra({start_node , end_node , nodes , c , canvas , size})\n      break \n    case \"Greedy best first search\": \n      greedy_best_first_search({start_node , end_node , nodes , c , canvas , size})\n      break \n    case \"Bidirectional a star\": \n      bidirectional_a_star({start_node , end_node , nodes , c , canvas , size})\n      break \n    case \"Bidirectional dijkstra's\": \n      bidirectional_dijkstra({start_node , end_node , nodes , c , canvas , size})\n      break \n  }\n}\n\nconst update_info = props => {\n  if(props.start_location){\n    start_location = props.start_location\n    start_node = new Block(start_location.x , start_location.y , c , size , \"blue\")\n  }\n\n  if(props.end_location){\n    end_location = props.end_location\n    end_node = new Block(end_location.x , end_location.y , c , size , \"green\" )\n  }\n}\n\nexport {setUp , run_solve_maze , update_info}\n","\n\nconst Node = function(x , y , c , size , walls , neighbor_node = [], prev_node = null){\n    this.x = x\n    this.y = y\n    this.neighbor_node = neighbor_node\n    this.prev_node = prev_node \n    this.walls = walls// [top, right , bottom , left ]\n    this.grid = false \n\n    this.draw = (color = \"black\") => {\n        let x = this.x - (size / 2)\n        let y = this.y - (size / 2)\n        // Top \n        if(this.walls[0]){\n            c.beginPath()\n            c.moveTo(x, y)\n            c.lineTo(x + size , y)\n            c.lineWidth = 4\n            c.lineCap = \"round\"\n            c.strokeStyle = color\n            c.stroke()\n        }\n\n        // right\n        if(this.walls[1]){\n            c.beginPath()\n            c.moveTo(x + size, y)\n            c.lineTo(x + size , y +size)\n            c.lineWidth = 4\n            c.lineCap = \"round\"\n            c.strokeStyle = color\n            c.stroke()\n        }\n\n        // bottom\n        if(this.walls[2]){\n            c.beginPath()\n            c.moveTo(x + size, y + size)\n            c.lineTo(x, y +size)\n            c.lineWidth = 4\n            c.lineCap = \"round\"\n            c.strokeStyle = color\n            c.stroke()\n        }\n\n        // left \n        if(this.walls[3]){\n            c.beginPath()\n            c.moveTo(x, y + size)\n            c.lineTo(x, y)\n            c.lineWidth = 4\n            c.lineCap = \"round\"\n            c.strokeStyle = color\n            c.stroke()\n        }\n\n        if(this.walls.every( e => e === true) && this.grid){\n            c.beginPath()\n            c.rect(x, y, size, size)\n            c.fillStyle = 'black'\n            c.fill()\n        }\n    }\n}\n\nconst Block = function(x , y , c , size, color = \"red\", prev_node = null , g = null , h = null , f = null , distance = Infinity){\n    this.x = x \n    this.y = y \n    this.prev_node = prev_node\n    this.color = color\n    this.g = g \n    this.h = h \n    this.f = f\n    this.distance = distance\n  \n    this.draw = () => {\n        let x = this.x - (size / 3) \n        let y = this.y - (size / 3)\n        let rect_size = size * 2/3\n        let r = rect_size * 1/4\n        c.beginPath()\n        c.moveTo(x+r, y)\n        c.arcTo(x+rect_size, y,   x+rect_size, y+rect_size, r)\n        c.arcTo(x+rect_size, y+rect_size, x,   y+rect_size, r)\n        c.arcTo(x,   y+rect_size, x,   y,   r)\n        c.arcTo(x,   y,   x+rect_size, y,   r)\n        c.fillStyle = this.color\n        c.fill()\n        c.closePath()\n    }\n}\n\nexport {Node , Block}","const get_top_right_bottom_left = (node , array , size) => {\n    let {x , y} = node\n    let top = array.find(n => n.x === x && n.y === y - size)\n    let right = array.find(n => n.x === x + size && n.y === y)\n    let bottom = array.find(n => n.x === x && n.y === y + size)\n    let left = array.find(n => n.x === x - size && n.y === y)\n\n    return {top , right , bottom , left }\n}\n\nconst add_to_heap = (node, array, method) => {\n    array.push(node)\n    let i = array.length \n    while(array[Math.floor(i / 2) - 1] && method(array[i - 1] , array[Math.floor(i / 2) - 1])){\n      let current_node = array[i - 1]\n      array[i - 1] = array[Math.floor(i / 2) - 1]\n      array[Math.floor(i / 2) - 1] = current_node\n      i = Math.floor(i / 2)\n    }\n    return array \n  }\n  \n  const remove_from_heap = (array , method) => {\n    let i = 1\n    array[0] = array[array.length - 1]\n    array.pop()\n    let current_node = array[0]\n    let stop = false\n    while(!stop) {\n      let left_child = array[(2 * i) - 1]\n      let right_child = array[(2 * i)]\n      let max_child_index \n      if(left_child && right_child){\n        max_child_index = method(left_child,right_child) ? 2 * i : 2 * i + 1\n      }else if(left_child || right_child){\n        max_child_index = left_child ? 2 * i : 2 * i + 1\n      }\n  \n      if(max_child_index && method(array[max_child_index - 1] ,current_node)){\n        array[i - 1] = array[max_child_index - 1]\n        array[max_child_index - 1] = current_node \n        current_node = array[max_child_index - 1]\n        i = max_child_index\n      }else{\n        stop = true\n      }\n    }\n    return array \n  }\n\nexport {get_top_right_bottom_left , add_to_heap , remove_from_heap}","import React , {Component} from 'react'\nimport {setUp , run_solve_maze , update_info} from './Algorithms/mazeController'\nimport {connect} from 'react-redux'\nimport swal from '@sweetalert/with-react'\n\nlet select_start = false\nlet select_end = false \nlet display_points = false \n\nclass App extends Component{\n  constructor(){\n    super()\n    this.state = {\n      width: (window.innerWidth * .95),\n      height: (window.innerHeight * .92),\n      select_draw_algorithims: \"Depth first search\", \n      select_solve_algorithims: \"A star\",\n      rows: 15, \n      dispay_draw_button: true , \n      speed: \"Normal\", \n      start_location: {x: 40 , y: 170}, \n\n      end_location: {x: 40 , y: 170}, \n    }\n  }\n\n  componentDidMount(){\n    this.updateCanvas(\"\")\n  }\n\n  run_set_point = () => {\n    let canvas = this.refs.maze\n    let {width , rows } = this.state \n    let cols = Math.floor(rows * ((window.innerWidth * .95) / (window.innerHeight * .9))) \n    let size = Math.floor(width / cols)\n    let {offsetLeft , offsetTop} = canvas\n    let start_location = {x: offsetLeft + (size / 2) , y: offsetTop + (size / 2)}\n    let end_location = {x: offsetLeft + ((cols - 1) * size + (size / 2)) , y: offsetTop + ((rows - 1) * size + (size / 2))}\n    this.setState({start_location , end_location})\n    canvas.addEventListener('mousedown' , (e) => {\n      let {pageX , pageY} = e\n      let x = Math.floor(((pageX - offsetLeft) / size)) * (size) + (size / 2) + offsetLeft\n      let y = Math.floor(((pageY - offsetTop) / size)) * (size) + (size / 2) + offsetTop\n      if(x < (cols * size) + offsetLeft && y < (rows * size) + offsetTop){\n        if(select_end){\n          end_location = {x , y}\n          this.setState({end_location})\n          update_info({end_location: {x: x - offsetLeft ,y: y - offsetTop}})\n        }\n\n        if(select_start){\n          start_location = {x , y}\n          this.setState({start_location})\n          update_info({start_location: {x: x - offsetLeft ,y: y - offsetTop}})\n        }\n      }\n    })\n  }\n\n  check_recursive_delay = (value) => {\n    this.setState({dispay_draw_button: value})\n  }\n\n  updateCanvas = (select_draw_algorithims = this.state.select_draw_algorithims) => {\n    // rows == min 15 and max 50\n    display_points = true\n    let {rows , height , width } = this.state\n\n    let speed = this.props.speed[select_draw_algorithims][this.state.speed]\n\n    if(select_draw_algorithims === \"Recursive Division\"){\n      this.check_recursive_delay(false)\n    }\n\n    let cols = Math.floor(rows * ((window.innerWidth * .95) / (window.innerHeight * .9))) \n\n    const canvas = this.refs.maze\n    const c = canvas.getContext('2d');\n\n    if(rows < 15 || rows > 50){\n      swal({\n        button: false, \n        content: (\n          <div style={{color: 'black'}}>\n            <h3>Rows should be minimum 15 and maximum 50.</h3>\n          </div>\n        )\n      })\n      return\n    }\n    setUp({c , canvas , cols , rows, width , height , select_draw_algorithims , \n    check_recursive_delay: this.check_recursive_delay , speed })\n  }\n\n  render(){\n    let {width , height , select_solve_algorithims , dispay_draw_button} = this.state\n    let {draw_maze_algorithims , solve_maze_algorithims} = this.props\n    let speed = [\"Slow\", \"Normal\", \"Fast\" , \"Supper fast\"]\n    let start_x = this.state.start_location.x\n    let start_y = this.state.start_location.y\n\n    let end_x = this.state.end_location.x\n    let end_y = this.state.end_location.y\n    return(\n      <div className=\"mt-1\">\n        <nav className=\"navbar\">\n          <div className=\"d-flex flex-wrap\">\n            <div className=\"input-group p-2\" style={{minWidth: 600}}>\n              <div className=\"input-group-prepend\">\n                <span className=\"input-group-text\">Algorithms</span>\n              </div>\n              <select \n                className=\"custom-select\" \n                id=\"inputGroupSelect04\" \n                aria-label=\"Example select with button addon\"\n                style={{minWidth: 250}}\n                onChange={(e) => this.setState({select_draw_algorithims: e.target.value})}\n              >\n                {draw_maze_algorithims.map(algorithm => \n                  <option value={algorithm}>{algorithm}</option>\n                )}\n              </select>\n              <div className=\"input-group-prepend\">\n                <span className=\"input-group-text\">Speed</span>\n              </div>\n              <select \n                className=\"custom-select\" \n                id=\"inputGroupSelect04\" \n                aria-label=\"Example select with button addon\"\n                style={{maxWidth: 150}}\n                onChange={(e) => this.setState({speed: e.target.value})}\n              >\n                {speed.map(s => \n                  s === \"Normal\"\n                    ? <option value={s} selected>{s}</option>\n                    : <option value={s} >{s}</option>\n                )}\n              </select>\n              <div className=\"input-group-prepend\">\n                <span className=\"input-group-text\">Size(rows)</span>\n              </div>\n              <input \n                type=\"number\" \n                className=\"form-control\" \n                min='15'\n                max='50'\n                placeholder=\"Minimum 15 and Maximum 50\"\n                style={{minWidth: 100}}\n                onChange={(e) => {\n                  let rows = Math.floor(e.target.value)\n                  this.setState({rows})\n                }}\n              ></input>\n            <div className=\"input-group-append\">\n              {dispay_draw_button ? \n                <button \n                  className=\"btn btn-outline-light\" \n                  type=\"submit\"\n                  onClick={() => {\n                    this.updateCanvas()\n                    this.run_set_point()\n                  }}\n                >\n                  Generate Maze\n                </button>\n              : null }\n            </div>\n          </div>\n          <div className=\"input-group p-2\" style={{maxWidth: 500}}>\n            <div className=\"input-group-prepend\">\n              <span className=\"input-group-text\">Algorithms</span>\n            </div>\n            <select \n              className=\"custom-select\" \n              id=\"inputGroupSelect04\" \n              aria-label=\"Example select with button addon\"\n              onChange={(e) => this.setState({select_solve_algorithims: e.target.value})}\n            >\n              {solve_maze_algorithims.map(algorithm => \n                <option value={algorithm}>{algorithm}</option>\n              )}\n            </select>\n            <div className=\"input-group-append\">\n              <button \n                className=\"btn btn-outline-light\" \n                type=\"button\"\n                onClick={() => run_solve_maze(select_solve_algorithims)}\n              >\n                Solve Maze\n              </button>\n            </div>\n          </div>\n          <button \n            className=\"btn m-2\" \n            style={{color: select_start ? 'black' :'white'}}\n            onClick={() => {\n              select_end = false\n              select_start = !select_start\n              this.setState({})\n            }}\n            >\n            <i class=\"fas fa-star\" style={{color: select_start ? 'black' :'white'}}></i> Start Point\n          </button>\n          <button \n            className=\"btn m-2\" \n            style={{color: select_end ? 'black' :'white'}}\n            onClick={() => {\n              select_start = false\n              select_end = !select_end \n              this.setState({})\n            }}\n          >\n            <i class=\"fas fa-bullseye\" style={{color: select_end ? 'black' :'white'}}></i> End Point\n          </button>\n          </div>\n        </nav>\n        <div className=\"m-5\">\n          {display_points ? \n            <i \n              class=\"fas fa-star\" \n              style={{position: \"absolute\", width: 10 , height: 10, top: start_y - 10, left: start_x - 10 , backgroundColor: 'transparent'}}></i>\n          : null } \n          {display_points ? \n            <i \n              class=\"fas fa-bullseye\" \n              style={{position: \"absolute\", width: 6, height: 6, top: end_y - 6, left: end_x - 6 , backgroundColor: 'transparent'}}></i>\n          : null }\n          <canvas ref=\"maze\" style={{width, height}}></canvas>\n        </div> \n      </div>\n    )\n  }\n}\n\nconst mapStateToProps = state => {\n  return {\n    draw_maze_algorithims: state.draw_maze_algorithims,\n    solve_maze_algorithims: state.solve_maze_algorithims,\n    speed: state.speed \n  }\n}\n\nexport default connect(mapStateToProps)(App)\n","let init_state = {\n    draw_maze_algorithims: [\"Depth first search\" , \"Prim's\" , \"Recursive Division\"], \n    solve_maze_algorithims: [\"A star\" , \"Depth first search\" , \"Breadth first search\" , \"Dijkstra's\" , \"Greedy best first search\" , \"Bidirectional a star\" , \"Bidirectional dijkstra's\"], \n    rows: 15,\n    speed: {\n        \"Depth first search\": {\n            \"Slow\": 10, \n            \"Normal\": 50, \n            \"Fast\": 150, \n            \"Supper fast\": 300\n        },\n        \"Prim's\": {\n            \"Slow\": 10, \n            \"Normal\": 50, \n            \"Fast\": 150, \n            \"Supper fast\": 300\n        },\n        \"Recursive Division\": {\n            \"Supper fast\": 10, \n            \"Fast\": 50, \n            \"Normal\": 150, \n            \"Slow\": 300\n        },\n        \"\": {\n            \"Supper fast\": 0, \n            \"Fast\": 0, \n            \"Normal\": 0, \n            \"Slow\": 0\n        }\n    }\n}\n\nconst mazeGenerationReducer = (state = init_state , action) => {\n    return state \n}\n\nexport default mazeGenerationReducer","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nimport {createStore} from 'redux'\nimport {Provider} from 'react-redux'\n\nimport mazeGeneratorReducer from './reducer/mazeGeneratorReducer'\n\nlet store = createStore(              //==> take reducer\n  mazeGeneratorReducer,\n  window._REDUX_DEVTOOLS_EXTENSION_ && window._REDUX_DEVTOOLS_EXTENSION_()\n)\n\nReactDOM.render(\n  <Provider store = {store}>\n    <App />\n  </Provider>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}